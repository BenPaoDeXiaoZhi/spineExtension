(function () {
  'use strict';

  /* deploy by Github CI/CD
   - Deploy time: 2025/12/14 11:56:55
   - Commit id: undefined
   - Repository: undefined
   - Actor: undefined*/

  // src/scratch/register.ts
  function registerExtDetail(ext, info) {
    window.tempExt = Object.assign(
      {
        Extension: ext
      },
      info
    );
  }

  // src/i18n/zh_cn.ts
  var zh_cn_default = {
    // Metadata
    extensionName: "spine骨骼动画",
    description: "在scratch中使用spine骨骼动画!",
    // Blocks
    "loadSkeleton.text": "加载配置为[CONFIG]的spine骨骼并命名为[NAME]",
    "loadSkeleton.configError": "请输入有效配置",
    "setSkinSkeleton.text": "将角色[TARGET_NAME]的skin设为骨骼[SKELETON]",
    // Menu
    "spriteMenu.currentTarget": "当前角色",
    // Utils
    "SpineSkinReport.type": "spine skin",
    "SpineSkinReport.id": "id为 {id}",
    "SpineSkinReport.version": "版本为 {version}",
    "SpineSkinReport.nameText": "名称为 {name}",
    "SpineSkinReport.monitor": "(spine皮肤) id为{id}, 版本为{version}, 名称为{name}",
    "SpineSkeletonReport.type": "spine骨骼"
  };

  // src/i18n/en.ts
  var en_default = {
    // Metadata
    extensionName: "spine animation",
    description: "Use Spine animation in Scratch!",
    // Blocks
    "loadSkeleton.text": "Load the spine skeleton with configuration [CONFIG] and name it [NAME]",
    "loadSkeleton.configError": "please input correct configs",
    "setSkinSkeleton.text": "Set the skin of character [TARGET_NAME] to Skeleton:[SKELETON]",
    // Menu
    "spriteMenu.currentTarget": "Current target",
    // Utils
    "SpineSkinReport.type": "Spine Skin",
    "SpineSkinReport.id": "Id is {id}",
    "SpineSkinReport.version": "Version is {version}",
    "SpineSkinReport.nameText": "Name is {name}",
    "SpineSkinReport.monitor": "(Spine Skin) Id is {id}, Version is {version}, Name is {name}",
    "SpineSkeletonReport.type": "Spine Skeleton"
  };

  // src/i18n/translate.ts
  function getTranslate(runtime2) {
    const fmt = runtime2.getFormatMessage({ "zh-cn": zh_cn_default, en: en_default });
    return function(id, args) {
      return fmt(
        {
          default: id
        },
        args
      );
    };
  }

  // src/scratch/simpleExt.ts
  var SimpleExt = class {
    info;
    constructor(id, name) {
      this.info = { id, name, blocks: [], menus: {} };
    }
    getInfo() {
      return this.info;
    }
  };

  // src/util/storage/style.asset.css
  var style_asset_default = ".bg {\r\n    width: 100%;\r\n    height: 100%;\r\n    position: fixed;\r\n    left: 0;\r\n    top: 0;\r\n    z-index: 540;\r\n    background-color: #0000004c;\r\n    user-select: none;\r\n}\r\n.modal {\r\n    margin: 100px auto;\r\n    width: 580px;\r\n    background-color: var(--theme-color-300, #2e3644);\r\n    border: 1px solid var(--theme-color-200, #3e495b);\r\n    border-radius: 12px;\r\n    min-height: 100px;\r\n    user-select: none;\r\n    position: relative;\r\n    z-index: 550;\r\n}\r\n.header {\r\n    color: white;\r\n    display: flex;\r\n    font-size: 18px;\r\n    border-bottom: 1px solid var(--theme-color-350, #1d2634);\r\n    height: 100%;\r\n    padding: 10px;\r\n}\r\n.close {\r\n    background-color: transparent;\r\n    border: none;\r\n    border-radius: 5px;\r\n    position: absolute;\r\n    right: 5px;\r\n    padding: 0;\r\n    width: 24px;\r\n    height: 24px;\r\n    transition: background-color 0.15s ease-out;\r\n    cursor: pointer;\r\n}\r\n.close:hover {\r\n    background-color: rgba(255, 255, 255, 0.16);\r\n}\r\n";

  // src/util/storage/close.svg
  var close_default = '<svg width="24" height="24" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n    <path d="M17.657 6.112L6.343 17.426m0-11.314l11.314 11.314" stroke="#566276" stroke-width="2" stroke-linecap="round"\r\n        stroke-linejoin="round"></path>\r\n</svg>';

  // src/util/storage.ts
  var scratchStroageUI = class {
    storage;
    extId;
    constructor(storage, extId = "test") {
      this.storage = storage;
      this.extId = extId;
    }
    loadFile(assetId) {
      return fetch(`https://m.ccw.site/user_projects_assets/${assetId}`);
    }
    async storeFile(contentType = "text/plain", fileName, extName = "", data) {
      let fileData;
      if (data instanceof String) {
        const enc = new TextEncoder();
        fileData = enc.encode(data).buffer;
      } else if (data instanceof Blob) {
        fileData = await data.arrayBuffer();
      } else if (data instanceof Uint8Array) {
        fileData = data.buffer;
      } else if (data instanceof ArrayBuffer) {
        fileData = data;
      } else {
        throw new Error(`cannot convert ${data} to array buffer`);
      }
      return this.storage.store(
        { contentType },
        extName,
        fileData,
        fileName
      );
    }
    createUI() {
      if (!customElements.get("scratch-storage-ui")) {
        customElements.define("scratch-storage-ui", Container);
      }
    }
  };
  var Container = class extends HTMLElement {
    constructor() {
      super();
    }
    connectedCallback() {
      const shadow = this.attachShadow({ mode: "open" });
      const style = document.createElement("style");
      style.innerHTML = style_asset_default;
      const container = document.createElement("div");
      container.className = "bg";
      const modal = document.createElement("div");
      modal.className = "modal";
      const header = document.createElement("header");
      header.className = "header";
      const headerText = document.createElement("div");
      headerText.style.width = "fit-content";
      headerText.style.margin = "auto";
      headerText.innerText = "上传spine文件";
      const close = document.createElement("button");
      close.className = "close";
      close.innerHTML = close_default;
      close.addEventListener("click", (e) => {
        this.remove();
      });
      header.appendChild(headerText);
      header.appendChild(close);
      modal.appendChild(header);
      container.appendChild(modal);
      shadow.appendChild(container);
      shadow.appendChild(style);
    }
  };

  // src/spineSkin.ts
  var Skin = Scratch.runtime.renderer.exports.Skin;
  console.log(Skin);
  function patchSpineSkin(runtime2) {
    const [id, skin] = runtime2.renderer.createSpineSkin();
    runtime2.renderer._allSkins[id] = void 0;
    runtime2.renderer._nextSkinId--;
    Object.defineProperty(
      Object.getPrototypeOf(skin).constructor,
      Symbol.hasInstance,
      {
        value: function(instance) {
          if (instance instanceof SpineSkin || (instance == null ? void 0 : instance.spine)) {
            return true;
          }
          return false;
        },
        writable: true
      }
    );
    console.log(Object.getPrototypeOf(skin).constructor);
  }
  var SpineSkin = class extends Skin {
    gl;
    manager;
    _size;
    skeleton;
    animationState;
    tk;
    name;
    constructor(id, renderer, manager, skeleton2, animationState, tk, name) {
      super(id);
      this.gl = renderer.gl;
      this.manager = manager;
      this.skeleton = skeleton2;
      this.tk = tk;
      this.animationState = animationState;
      this.name = name;
      this._texture = this.gl.createTexture();
      this.size = [640, 360];
      this._rotationCenter = [320, 180];
    }
    set size(size) {
      this._size = size;
    }
    get size() {
      return this._size;
    }
    getTexture(scale) {
      return this._texture;
    }
    render() {
      this.manager.drawSkeleton(this.skeleton, this.tk, this.animationState);
      this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
      requestAnimationFrame(() => this.emit(Skin.Events.WasAltered));
    }
  };

  // src/spine/3.8/spine-webgl.js
  var __extends = /* @__PURE__ */ (function() {
    var extendStatics = function(d, b) {
      return (extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) Object.prototype.hasOwnProperty.call(b2, p) && (d2[p] = b2[p]);
      })(d, b);
    };
    return function(d, b) {
      if ("function" != typeof b && null !== b) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      function __() {
        this.constructor = d;
      }
      extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  })();
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  var spine;
  !(function(spine4) {
    var Animation = (function() {
      function Animation2(name, timelines, duration) {
        if (null == name) throw new Error("name cannot be null.");
        if (null == timelines) throw new Error("timelines cannot be null.");
        this.name = name, this.timelines = timelines, this.timelineIds = [];
        for (var i = 0; i < timelines.length; i++) this.timelineIds[timelines[i].getPropertyId()] = true;
        this.duration = duration;
      }
      return Animation2.prototype.hasTimeline = function(id) {
        return 1 == this.timelineIds[id];
      }, Animation2.prototype.apply = function(skeleton2, lastTime, time, loop, events, alpha, blend, direction) {
        if (null == skeleton2) throw new Error("skeleton cannot be null.");
        loop && 0 != this.duration && (time %= this.duration, lastTime > 0 && (lastTime %= this.duration));
        for (var timelines = this.timelines, i = 0, n = timelines.length; i < n; i++) timelines[i].apply(skeleton2, lastTime, time, events, alpha, blend, direction);
      }, Animation2.binarySearch = function(values, target, step) {
        void 0 === step && (step = 1);
        var low = 0, high = values.length / step - 2;
        if (0 == high) return step;
        for (var current = high >>> 1; ; ) {
          if (values[(current + 1) * step] <= target ? low = current + 1 : high = current, low == high) return (low + 1) * step;
          current = low + high >>> 1;
        }
      }, Animation2.linearSearch = function(values, target, step) {
        for (var i = 0, last = values.length - step; i <= last; i += step) if (values[i] > target) return i;
        return -1;
      }, Animation2;
    })(), MixBlend, MixDirection, TimelineType;
    spine4.Animation = Animation, (function(MixBlend2) {
      MixBlend2[MixBlend2.setup = 0] = "setup", MixBlend2[MixBlend2.first = 1] = "first", MixBlend2[MixBlend2.replace = 2] = "replace", MixBlend2[MixBlend2.add = 3] = "add";
    })(MixBlend = spine4.MixBlend || (spine4.MixBlend = {})), (function(MixDirection2) {
      MixDirection2[MixDirection2.mixIn = 0] = "mixIn", MixDirection2[MixDirection2.mixOut = 1] = "mixOut";
    })(MixDirection = spine4.MixDirection || (spine4.MixDirection = {})), (function(TimelineType2) {
      TimelineType2[TimelineType2.rotate = 0] = "rotate", TimelineType2[TimelineType2.translate = 1] = "translate", TimelineType2[TimelineType2.scale = 2] = "scale", TimelineType2[TimelineType2.shear = 3] = "shear", TimelineType2[TimelineType2.attachment = 4] = "attachment", TimelineType2[TimelineType2.color = 5] = "color", TimelineType2[TimelineType2.deform = 6] = "deform", TimelineType2[TimelineType2.event = 7] = "event", TimelineType2[TimelineType2.drawOrder = 8] = "drawOrder", TimelineType2[TimelineType2.ikConstraint = 9] = "ikConstraint", TimelineType2[TimelineType2.transformConstraint = 10] = "transformConstraint", TimelineType2[TimelineType2.pathConstraintPosition = 11] = "pathConstraintPosition", TimelineType2[TimelineType2.pathConstraintSpacing = 12] = "pathConstraintSpacing", TimelineType2[TimelineType2.pathConstraintMix = 13] = "pathConstraintMix", TimelineType2[TimelineType2.twoColor = 14] = "twoColor";
    })(TimelineType = spine4.TimelineType || (spine4.TimelineType = {}));
    var CurveTimeline = (function() {
      function CurveTimeline2(frameCount) {
        if (frameCount <= 0) throw new Error("frameCount must be > 0: " + frameCount);
        this.curves = spine4.Utils.newFloatArray((frameCount - 1) * CurveTimeline2.BEZIER_SIZE);
      }
      return CurveTimeline2.prototype.getFrameCount = function() {
        return this.curves.length / CurveTimeline2.BEZIER_SIZE + 1;
      }, CurveTimeline2.prototype.setLinear = function(frameIndex) {
        this.curves[frameIndex * CurveTimeline2.BEZIER_SIZE] = CurveTimeline2.LINEAR;
      }, CurveTimeline2.prototype.setStepped = function(frameIndex) {
        this.curves[frameIndex * CurveTimeline2.BEZIER_SIZE] = CurveTimeline2.STEPPED;
      }, CurveTimeline2.prototype.getCurveType = function(frameIndex) {
        var index = frameIndex * CurveTimeline2.BEZIER_SIZE;
        if (index == this.curves.length) return CurveTimeline2.LINEAR;
        var type = this.curves[index];
        return type == CurveTimeline2.LINEAR ? CurveTimeline2.LINEAR : type == CurveTimeline2.STEPPED ? CurveTimeline2.STEPPED : CurveTimeline2.BEZIER;
      }, CurveTimeline2.prototype.setCurve = function(frameIndex, cx1, cy1, cx2, cy2) {
        var tmpx = 0.03 * (2 * -cx1 + cx2), tmpy = 0.03 * (2 * -cy1 + cy2), dddfx = 6e-3 * (3 * (cx1 - cx2) + 1), dddfy = 6e-3 * (3 * (cy1 - cy2) + 1), ddfx = 2 * tmpx + dddfx, ddfy = 2 * tmpy + dddfy, dfx = 0.3 * cx1 + tmpx + 0.16666667 * dddfx, dfy = 0.3 * cy1 + tmpy + 0.16666667 * dddfy, i = frameIndex * CurveTimeline2.BEZIER_SIZE, curves = this.curves;
        curves[i++] = CurveTimeline2.BEZIER;
        for (var x = dfx, y = dfy, n = i + CurveTimeline2.BEZIER_SIZE - 1; i < n; i += 2) curves[i] = x, curves[i + 1] = y, dfx += ddfx, dfy += ddfy, ddfx += dddfx, ddfy += dddfy, x += dfx, y += dfy;
      }, CurveTimeline2.prototype.getCurvePercent = function(frameIndex, percent) {
        percent = spine4.MathUtils.clamp(percent, 0, 1);
        var curves = this.curves, i = frameIndex * CurveTimeline2.BEZIER_SIZE, type = curves[i];
        if (type == CurveTimeline2.LINEAR) return percent;
        if (type == CurveTimeline2.STEPPED) return 0;
        for (var x = 0, start = ++i, n = i + CurveTimeline2.BEZIER_SIZE - 1; i < n; i += 2) if ((x = curves[i]) >= percent) {
          var prevX = void 0, prevY = void 0;
          return i == start ? (prevX = 0, prevY = 0) : (prevX = curves[i - 2], prevY = curves[i - 1]), prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);
        }
        var y = curves[i - 1];
        return y + (1 - y) * (percent - x) / (1 - x);
      }, CurveTimeline2.LINEAR = 0, CurveTimeline2.STEPPED = 1, CurveTimeline2.BEZIER = 2, CurveTimeline2.BEZIER_SIZE = 19, CurveTimeline2;
    })();
    spine4.CurveTimeline = CurveTimeline;
    var RotateTimeline = (function(_super) {
      function RotateTimeline2(frameCount) {
        var _this = _super.call(this, frameCount) || this;
        return _this.frames = spine4.Utils.newFloatArray(frameCount << 1), _this;
      }
      return __extends(RotateTimeline2, _super), RotateTimeline2.prototype.getPropertyId = function() {
        return (TimelineType.rotate << 24) + this.boneIndex;
      }, RotateTimeline2.prototype.setFrame = function(frameIndex, time, degrees) {
        frameIndex <<= 1, this.frames[frameIndex] = time, this.frames[frameIndex + RotateTimeline2.ROTATION] = degrees;
      }, RotateTimeline2.prototype.apply = function(skeleton2, lastTime, time, events, alpha, blend, direction) {
        var frames = this.frames, bone = Skeleton.bones[this.boneIndex];
        if (bone.active) if (time < frames[0]) switch (blend) {
          case MixBlend.setup:
            return void (bone.rotation = bone.data.rotation);
          case MixBlend.first:
            var r_1 = bone.data.rotation - bone.rotation;
            bone.rotation += (r_1 - 360 * (16384 - (16384.499999999996 - r_1 / 360 | 0))) * alpha;
        }
        else if (time >= frames[frames.length - RotateTimeline2.ENTRIES]) {
          var r_2 = frames[frames.length + RotateTimeline2.PREV_ROTATION];
          switch (blend) {
            case MixBlend.setup:
              bone.rotation = bone.data.rotation + r_2 * alpha;
              break;
            case MixBlend.first:
            case MixBlend.replace:
              r_2 += bone.data.rotation - bone.rotation, r_2 -= 360 * (16384 - (16384.499999999996 - r_2 / 360 | 0));
            case MixBlend.add:
              bone.rotation += r_2 * alpha;
          }
        } else {
          var frame = Animation.binarySearch(frames, time, RotateTimeline2.ENTRIES), prevRotation = frames[frame + RotateTimeline2.PREV_ROTATION], frameTime = frames[frame], percent = this.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + RotateTimeline2.PREV_TIME] - frameTime)), r = frames[frame + RotateTimeline2.ROTATION] - prevRotation;
          switch (r = prevRotation + (r - 360 * (16384 - (16384.499999999996 - r / 360 | 0))) * percent, blend) {
            case MixBlend.setup:
              bone.rotation = bone.data.rotation + (r - 360 * (16384 - (16384.499999999996 - r / 360 | 0))) * alpha;
              break;
            case MixBlend.first:
            case MixBlend.replace:
              r += bone.data.rotation - bone.rotation;
            case MixBlend.add:
              bone.rotation += (r - 360 * (16384 - (16384.499999999996 - r / 360 | 0))) * alpha;
          }
        }
      }, RotateTimeline2.ENTRIES = 2, RotateTimeline2.PREV_TIME = -2, RotateTimeline2.PREV_ROTATION = -1, RotateTimeline2.ROTATION = 1, RotateTimeline2;
    })(CurveTimeline);
    spine4.RotateTimeline = RotateTimeline;
    var TranslateTimeline = (function(_super) {
      function TranslateTimeline2(frameCount) {
        var _this = _super.call(this, frameCount) || this;
        return _this.frames = spine4.Utils.newFloatArray(frameCount * TranslateTimeline2.ENTRIES), _this;
      }
      return __extends(TranslateTimeline2, _super), TranslateTimeline2.prototype.getPropertyId = function() {
        return (TimelineType.translate << 24) + this.boneIndex;
      }, TranslateTimeline2.prototype.setFrame = function(frameIndex, time, x, y) {
        frameIndex *= TranslateTimeline2.ENTRIES, this.frames[frameIndex] = time, this.frames[frameIndex + TranslateTimeline2.X] = x, this.frames[frameIndex + TranslateTimeline2.Y] = y;
      }, TranslateTimeline2.prototype.apply = function(skeleton2, lastTime, time, events, alpha, blend, direction) {
        var frames = this.frames, bone = Skeleton.bones[this.boneIndex];
        if (bone.active) if (time < frames[0]) switch (blend) {
          case MixBlend.setup:
            return bone.x = bone.data.x, void (bone.y = bone.data.y);
          case MixBlend.first:
            bone.x += (bone.data.x - bone.x) * alpha, bone.y += (bone.data.y - bone.y) * alpha;
        }
        else {
          var x = 0, y = 0;
          if (time >= frames[frames.length - TranslateTimeline2.ENTRIES]) x = frames[frames.length + TranslateTimeline2.PREV_X], y = frames[frames.length + TranslateTimeline2.PREV_Y];
          else {
            var frame = Animation.binarySearch(frames, time, TranslateTimeline2.ENTRIES);
            x = frames[frame + TranslateTimeline2.PREV_X], y = frames[frame + TranslateTimeline2.PREV_Y];
            var frameTime = frames[frame], percent = this.getCurvePercent(frame / TranslateTimeline2.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TranslateTimeline2.PREV_TIME] - frameTime));
            x += (frames[frame + TranslateTimeline2.X] - x) * percent, y += (frames[frame + TranslateTimeline2.Y] - y) * percent;
          }
          switch (blend) {
            case MixBlend.setup:
              bone.x = bone.data.x + x * alpha, bone.y = bone.data.y + y * alpha;
              break;
            case MixBlend.first:
            case MixBlend.replace:
              bone.x += (bone.data.x + x - bone.x) * alpha, bone.y += (bone.data.y + y - bone.y) * alpha;
              break;
            case MixBlend.add:
              bone.x += x * alpha, bone.y += y * alpha;
          }
        }
      }, TranslateTimeline2.ENTRIES = 3, TranslateTimeline2.PREV_TIME = -3, TranslateTimeline2.PREV_X = -2, TranslateTimeline2.PREV_Y = -1, TranslateTimeline2.X = 1, TranslateTimeline2.Y = 2, TranslateTimeline2;
    })(CurveTimeline);
    spine4.TranslateTimeline = TranslateTimeline;
    var ScaleTimeline = (function(_super) {
      function ScaleTimeline2(frameCount) {
        return _super.call(this, frameCount) || this;
      }
      return __extends(ScaleTimeline2, _super), ScaleTimeline2.prototype.getPropertyId = function() {
        return (TimelineType.scale << 24) + this.boneIndex;
      }, ScaleTimeline2.prototype.apply = function(skeleton2, lastTime, time, events, alpha, blend, direction) {
        var frames = this.frames, bone = Skeleton.bones[this.boneIndex];
        if (bone.active) if (time < frames[0]) switch (blend) {
          case MixBlend.setup:
            return bone.scaleX = bone.data.scaleX, void (bone.scaleY = bone.data.scaleY);
          case MixBlend.first:
            bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha, bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;
        }
        else {
          var x = 0, y = 0;
          if (time >= frames[frames.length - ScaleTimeline2.ENTRIES]) x = frames[frames.length + ScaleTimeline2.PREV_X] * bone.data.scaleX, y = frames[frames.length + ScaleTimeline2.PREV_Y] * bone.data.scaleY;
          else {
            var frame = Animation.binarySearch(frames, time, ScaleTimeline2.ENTRIES);
            x = frames[frame + ScaleTimeline2.PREV_X], y = frames[frame + ScaleTimeline2.PREV_Y];
            var frameTime = frames[frame], percent = this.getCurvePercent(frame / ScaleTimeline2.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ScaleTimeline2.PREV_TIME] - frameTime));
            x = (x + (frames[frame + ScaleTimeline2.X] - x) * percent) * bone.data.scaleX, y = (y + (frames[frame + ScaleTimeline2.Y] - y) * percent) * bone.data.scaleY;
          }
          if (1 == alpha) blend == MixBlend.add ? (bone.scaleX += x - bone.data.scaleX, bone.scaleY += y - bone.data.scaleY) : (bone.scaleX = x, bone.scaleY = y);
          else {
            var bx = 0, by = 0;
            if (direction == MixDirection.mixOut) switch (blend) {
              case MixBlend.setup:
                bx = bone.data.scaleX, by = bone.data.scaleY, bone.scaleX = bx + (Math.abs(x) * spine4.MathUtils.signum(bx) - bx) * alpha, bone.scaleY = by + (Math.abs(y) * spine4.MathUtils.signum(by) - by) * alpha;
                break;
              case MixBlend.first:
              case MixBlend.replace:
                bx = bone.scaleX, by = bone.scaleY, bone.scaleX = bx + (Math.abs(x) * spine4.MathUtils.signum(bx) - bx) * alpha, bone.scaleY = by + (Math.abs(y) * spine4.MathUtils.signum(by) - by) * alpha;
                break;
              case MixBlend.add:
                bx = bone.scaleX, by = bone.scaleY, bone.scaleX = bx + (Math.abs(x) * spine4.MathUtils.signum(bx) - bone.data.scaleX) * alpha, bone.scaleY = by + (Math.abs(y) * spine4.MathUtils.signum(by) - bone.data.scaleY) * alpha;
            }
            else switch (blend) {
              case MixBlend.setup:
                bx = Math.abs(bone.data.scaleX) * spine4.MathUtils.signum(x), by = Math.abs(bone.data.scaleY) * spine4.MathUtils.signum(y), bone.scaleX = bx + (x - bx) * alpha, bone.scaleY = by + (y - by) * alpha;
                break;
              case MixBlend.first:
              case MixBlend.replace:
                bx = Math.abs(bone.scaleX) * spine4.MathUtils.signum(x), by = Math.abs(bone.scaleY) * spine4.MathUtils.signum(y), bone.scaleX = bx + (x - bx) * alpha, bone.scaleY = by + (y - by) * alpha;
                break;
              case MixBlend.add:
                bx = spine4.MathUtils.signum(x), by = spine4.MathUtils.signum(y), bone.scaleX = Math.abs(bone.scaleX) * bx + (x - Math.abs(bone.data.scaleX) * bx) * alpha, bone.scaleY = Math.abs(bone.scaleY) * by + (y - Math.abs(bone.data.scaleY) * by) * alpha;
            }
          }
        }
      }, ScaleTimeline2;
    })(TranslateTimeline);
    spine4.ScaleTimeline = ScaleTimeline;
    var ShearTimeline = (function(_super) {
      function ShearTimeline2(frameCount) {
        return _super.call(this, frameCount) || this;
      }
      return __extends(ShearTimeline2, _super), ShearTimeline2.prototype.getPropertyId = function() {
        return (TimelineType.shear << 24) + this.boneIndex;
      }, ShearTimeline2.prototype.apply = function(skeleton2, lastTime, time, events, alpha, blend, direction) {
        var frames = this.frames, bone = Skeleton.bones[this.boneIndex];
        if (bone.active) if (time < frames[0]) switch (blend) {
          case MixBlend.setup:
            return bone.shearX = bone.data.shearX, void (bone.shearY = bone.data.shearY);
          case MixBlend.first:
            bone.shearX += (bone.data.shearX - bone.shearX) * alpha, bone.shearY += (bone.data.shearY - bone.shearY) * alpha;
        }
        else {
          var x = 0, y = 0;
          if (time >= frames[frames.length - ShearTimeline2.ENTRIES]) x = frames[frames.length + ShearTimeline2.PREV_X], y = frames[frames.length + ShearTimeline2.PREV_Y];
          else {
            var frame = Animation.binarySearch(frames, time, ShearTimeline2.ENTRIES);
            x = frames[frame + ShearTimeline2.PREV_X], y = frames[frame + ShearTimeline2.PREV_Y];
            var frameTime = frames[frame], percent = this.getCurvePercent(frame / ShearTimeline2.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ShearTimeline2.PREV_TIME] - frameTime));
            x += (frames[frame + ShearTimeline2.X] - x) * percent, y += (frames[frame + ShearTimeline2.Y] - y) * percent;
          }
          switch (blend) {
            case MixBlend.setup:
              bone.shearX = bone.data.shearX + x * alpha, bone.shearY = bone.data.shearY + y * alpha;
              break;
            case MixBlend.first:
            case MixBlend.replace:
              bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha, bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;
              break;
            case MixBlend.add:
              bone.shearX += x * alpha, bone.shearY += y * alpha;
          }
        }
      }, ShearTimeline2;
    })(TranslateTimeline);
    spine4.ShearTimeline = ShearTimeline;
    var ColorTimeline = (function(_super) {
      function ColorTimeline2(frameCount) {
        var _this = _super.call(this, frameCount) || this;
        return _this.frames = spine4.Utils.newFloatArray(frameCount * ColorTimeline2.ENTRIES), _this;
      }
      return __extends(ColorTimeline2, _super), ColorTimeline2.prototype.getPropertyId = function() {
        return (TimelineType.color << 24) + this.slotIndex;
      }, ColorTimeline2.prototype.setFrame = function(frameIndex, time, r, g, b, a) {
        frameIndex *= ColorTimeline2.ENTRIES, this.frames[frameIndex] = time, this.frames[frameIndex + ColorTimeline2.R] = r, this.frames[frameIndex + ColorTimeline2.G] = g, this.frames[frameIndex + ColorTimeline2.B] = b, this.frames[frameIndex + ColorTimeline2.A] = a;
      }, ColorTimeline2.prototype.apply = function(skeleton2, lastTime, time, events, alpha, blend, direction) {
        var slot = Skeleton.slots[this.slotIndex];
        if (slot.bone.active) {
          var frames = this.frames;
          if (time < frames[0]) switch (blend) {
            case MixBlend.setup:
              return void slot.color.setFromColor(slot.data.color);
            case MixBlend.first:
              var color = slot.color, setup = slot.data.color;
              color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);
          }
          else {
            var r = 0, g = 0, b = 0, a = 0;
            if (time >= frames[frames.length - ColorTimeline2.ENTRIES]) {
              var i = frames.length;
              r = frames[i + ColorTimeline2.PREV_R], g = frames[i + ColorTimeline2.PREV_G], b = frames[i + ColorTimeline2.PREV_B], a = frames[i + ColorTimeline2.PREV_A];
            } else {
              var frame = Animation.binarySearch(frames, time, ColorTimeline2.ENTRIES);
              r = frames[frame + ColorTimeline2.PREV_R], g = frames[frame + ColorTimeline2.PREV_G], b = frames[frame + ColorTimeline2.PREV_B], a = frames[frame + ColorTimeline2.PREV_A];
              var frameTime = frames[frame], percent = this.getCurvePercent(frame / ColorTimeline2.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ColorTimeline2.PREV_TIME] - frameTime));
              r += (frames[frame + ColorTimeline2.R] - r) * percent, g += (frames[frame + ColorTimeline2.G] - g) * percent, b += (frames[frame + ColorTimeline2.B] - b) * percent, a += (frames[frame + ColorTimeline2.A] - a) * percent;
            }
            if (1 == alpha) slot.color.set(r, g, b, a);
            else {
              var color = slot.color;
              blend == MixBlend.setup && color.setFromColor(slot.data.color), color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);
            }
          }
        }
      }, ColorTimeline2.ENTRIES = 5, ColorTimeline2.PREV_TIME = -5, ColorTimeline2.PREV_R = -4, ColorTimeline2.PREV_G = -3, ColorTimeline2.PREV_B = -2, ColorTimeline2.PREV_A = -1, ColorTimeline2.R = 1, ColorTimeline2.G = 2, ColorTimeline2.B = 3, ColorTimeline2.A = 4, ColorTimeline2;
    })(CurveTimeline);
    spine4.ColorTimeline = ColorTimeline;
    var TwoColorTimeline = (function(_super) {
      function TwoColorTimeline2(frameCount) {
        var _this = _super.call(this, frameCount) || this;
        return _this.frames = spine4.Utils.newFloatArray(frameCount * TwoColorTimeline2.ENTRIES), _this;
      }
      return __extends(TwoColorTimeline2, _super), TwoColorTimeline2.prototype.getPropertyId = function() {
        return (TimelineType.twoColor << 24) + this.slotIndex;
      }, TwoColorTimeline2.prototype.setFrame = function(frameIndex, time, r, g, b, a, r2, g2, b2) {
        frameIndex *= TwoColorTimeline2.ENTRIES, this.frames[frameIndex] = time, this.frames[frameIndex + TwoColorTimeline2.R] = r, this.frames[frameIndex + TwoColorTimeline2.G] = g, this.frames[frameIndex + TwoColorTimeline2.B] = b, this.frames[frameIndex + TwoColorTimeline2.A] = a, this.frames[frameIndex + TwoColorTimeline2.R2] = r2, this.frames[frameIndex + TwoColorTimeline2.G2] = g2, this.frames[frameIndex + TwoColorTimeline2.B2] = b2;
      }, TwoColorTimeline2.prototype.apply = function(skeleton2, lastTime, time, events, alpha, blend, direction) {
        var slot = Skeleton.slots[this.slotIndex];
        if (slot.bone.active) {
          var frames = this.frames;
          if (time < frames[0]) switch (blend) {
            case MixBlend.setup:
              return slot.color.setFromColor(slot.data.color), void slot.darkColor.setFromColor(slot.data.darkColor);
            case MixBlend.first:
              var light = slot.color, dark = slot.darkColor, setupLight = slot.data.color, setupDark = slot.data.darkColor;
              light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha), dark.add((setupDark.r - dark.r) * alpha, (setupDark.g - dark.g) * alpha, (setupDark.b - dark.b) * alpha, 0);
          }
          else {
            var r = 0, g = 0, b = 0, a = 0, r2 = 0, g2 = 0, b2 = 0;
            if (time >= frames[frames.length - TwoColorTimeline2.ENTRIES]) {
              var i = frames.length;
              r = frames[i + TwoColorTimeline2.PREV_R], g = frames[i + TwoColorTimeline2.PREV_G], b = frames[i + TwoColorTimeline2.PREV_B], a = frames[i + TwoColorTimeline2.PREV_A], r2 = frames[i + TwoColorTimeline2.PREV_R2], g2 = frames[i + TwoColorTimeline2.PREV_G2], b2 = frames[i + TwoColorTimeline2.PREV_B2];
            } else {
              var frame = Animation.binarySearch(frames, time, TwoColorTimeline2.ENTRIES);
              r = frames[frame + TwoColorTimeline2.PREV_R], g = frames[frame + TwoColorTimeline2.PREV_G], b = frames[frame + TwoColorTimeline2.PREV_B], a = frames[frame + TwoColorTimeline2.PREV_A], r2 = frames[frame + TwoColorTimeline2.PREV_R2], g2 = frames[frame + TwoColorTimeline2.PREV_G2], b2 = frames[frame + TwoColorTimeline2.PREV_B2];
              var frameTime = frames[frame], percent = this.getCurvePercent(frame / TwoColorTimeline2.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TwoColorTimeline2.PREV_TIME] - frameTime));
              r += (frames[frame + TwoColorTimeline2.R] - r) * percent, g += (frames[frame + TwoColorTimeline2.G] - g) * percent, b += (frames[frame + TwoColorTimeline2.B] - b) * percent, a += (frames[frame + TwoColorTimeline2.A] - a) * percent, r2 += (frames[frame + TwoColorTimeline2.R2] - r2) * percent, g2 += (frames[frame + TwoColorTimeline2.G2] - g2) * percent, b2 += (frames[frame + TwoColorTimeline2.B2] - b2) * percent;
            }
            if (1 == alpha) slot.color.set(r, g, b, a), slot.darkColor.set(r2, g2, b2, 1);
            else {
              var light = slot.color, dark = slot.darkColor;
              blend == MixBlend.setup && (light.setFromColor(slot.data.color), dark.setFromColor(slot.data.darkColor)), light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha), dark.add((r2 - dark.r) * alpha, (g2 - dark.g) * alpha, (b2 - dark.b) * alpha, 0);
            }
          }
        }
      }, TwoColorTimeline2.ENTRIES = 8, TwoColorTimeline2.PREV_TIME = -8, TwoColorTimeline2.PREV_R = -7, TwoColorTimeline2.PREV_G = -6, TwoColorTimeline2.PREV_B = -5, TwoColorTimeline2.PREV_A = -4, TwoColorTimeline2.PREV_R2 = -3, TwoColorTimeline2.PREV_G2 = -2, TwoColorTimeline2.PREV_B2 = -1, TwoColorTimeline2.R = 1, TwoColorTimeline2.G = 2, TwoColorTimeline2.B = 3, TwoColorTimeline2.A = 4, TwoColorTimeline2.R2 = 5, TwoColorTimeline2.G2 = 6, TwoColorTimeline2.B2 = 7, TwoColorTimeline2;
    })(CurveTimeline);
    spine4.TwoColorTimeline = TwoColorTimeline;
    var AttachmentTimeline = (function() {
      function AttachmentTimeline2(frameCount) {
        this.frames = spine4.Utils.newFloatArray(frameCount), this.attachmentNames = new Array(frameCount);
      }
      return AttachmentTimeline2.prototype.getPropertyId = function() {
        return (TimelineType.attachment << 24) + this.slotIndex;
      }, AttachmentTimeline2.prototype.getFrameCount = function() {
        return this.frames.length;
      }, AttachmentTimeline2.prototype.setFrame = function(frameIndex, time, attachmentName) {
        this.frames[frameIndex] = time, this.attachmentNames[frameIndex] = attachmentName;
      }, AttachmentTimeline2.prototype.apply = function(skeleton2, lastTime, time, events, alpha, blend, direction) {
        var slot = Skeleton.slots[this.slotIndex];
        if (slot.bone.active) if (direction != MixDirection.mixOut) {
          var frames = this.frames;
          if (time < frames[0]) blend != MixBlend.setup && blend != MixBlend.first || this.setAttachment(skeleton2, slot, slot.data.attachmentName);
          else {
            var frameIndex = 0;
            frameIndex = time >= frames[frames.length - 1] ? frames.length - 1 : Animation.binarySearch(frames, time, 1) - 1;
            var attachmentName = this.attachmentNames[frameIndex];
            skeleton2.slots[this.slotIndex].setAttachment(null == attachmentName ? null : Skeleton.getAttachment(this.slotIndex, attachmentName));
          }
        } else blend == MixBlend.setup && this.setAttachment(skeleton2, slot, slot.data.attachmentName);
      }, AttachmentTimeline2.prototype.setAttachment = function(skeleton2, slot, attachmentName) {
        slot.setAttachment(null == attachmentName ? null : Skeleton.getAttachment(this.slotIndex, attachmentName));
      }, AttachmentTimeline2;
    })();
    spine4.AttachmentTimeline = AttachmentTimeline;
    var zeros = null, DeformTimeline = (function(_super) {
      function DeformTimeline2(frameCount) {
        var _this = _super.call(this, frameCount) || this;
        return _this.frames = spine4.Utils.newFloatArray(frameCount), _this.frameVertices = new Array(frameCount), null == zeros && (zeros = spine4.Utils.newFloatArray(64)), _this;
      }
      return __extends(DeformTimeline2, _super), DeformTimeline2.prototype.getPropertyId = function() {
        return (TimelineType.deform << 27) + +this.attachment.id + this.slotIndex;
      }, DeformTimeline2.prototype.setFrame = function(frameIndex, time, vertices) {
        this.frames[frameIndex] = time, this.frameVertices[frameIndex] = vertices;
      }, DeformTimeline2.prototype.apply = function(skeleton2, lastTime, time, firedEvents, alpha, blend, direction) {
        var slot = Skeleton.slots[this.slotIndex];
        if (slot.bone.active) {
          var slotAttachment = slot.getAttachment();
          if (slotAttachment instanceof spine4.VertexAttachment && slotAttachment.deformAttachment == this.attachment) {
            var deformArray = slot.deform;
            0 == deformArray.length && (blend = MixBlend.setup);
            var frameVertices = this.frameVertices, vertexCount = frameVertices[0].length, frames = this.frames;
            if (time < frames[0]) {
              var vertexAttachment = slotAttachment;
              switch (blend) {
                case MixBlend.setup:
                  return void (deformArray.length = 0);
                case MixBlend.first:
                  if (1 == alpha) {
                    deformArray.length = 0;
                    break;
                  }
                  var deform_1 = spine4.Utils.setArraySize(deformArray, vertexCount);
                  if (null == vertexAttachment.bones) for (var setupVertices = vertexAttachment.vertices, i = 0; i < vertexCount; i++) deform_1[i] += (setupVertices[i] - deform_1[i]) * alpha;
                  else {
                    alpha = 1 - alpha;
                    for (var i = 0; i < vertexCount; i++) deform_1[i] *= alpha;
                  }
              }
            } else {
              var deform = spine4.Utils.setArraySize(deformArray, vertexCount);
              if (time >= frames[frames.length - 1]) {
                var lastVertices = frameVertices[frames.length - 1], vertexAttachment;
                if (1 == alpha) if (blend == MixBlend.add) if (null == (vertexAttachment = slotAttachment).bones) for (var setupVertices = vertexAttachment.vertices, i_1 = 0; i_1 < vertexCount; i_1++) deform[i_1] += lastVertices[i_1] - setupVertices[i_1];
                else for (var i_2 = 0; i_2 < vertexCount; i_2++) deform[i_2] += lastVertices[i_2];
                else spine4.Utils.arrayCopy(lastVertices, 0, deform, 0, vertexCount);
                else switch (blend) {
                  case MixBlend.setup:
                    var vertexAttachment_1 = slotAttachment;
                    if (null == vertexAttachment_1.bones) for (var setupVertices = vertexAttachment_1.vertices, i_3 = 0; i_3 < vertexCount; i_3++) {
                      var setup = setupVertices[i_3];
                      deform[i_3] = setup + (lastVertices[i_3] - setup) * alpha;
                    }
                    else for (var i_4 = 0; i_4 < vertexCount; i_4++) deform[i_4] = lastVertices[i_4] * alpha;
                    break;
                  case MixBlend.first:
                  case MixBlend.replace:
                    for (var i_5 = 0; i_5 < vertexCount; i_5++) deform[i_5] += (lastVertices[i_5] - deform[i_5]) * alpha;
                    break;
                  case MixBlend.add:
                    var vertexAttachment;
                    if (null == (vertexAttachment = slotAttachment).bones) for (var setupVertices = vertexAttachment.vertices, i_6 = 0; i_6 < vertexCount; i_6++) deform[i_6] += (lastVertices[i_6] - setupVertices[i_6]) * alpha;
                    else for (var i_7 = 0; i_7 < vertexCount; i_7++) deform[i_7] += lastVertices[i_7] * alpha;
                }
              } else {
                var frame = Animation.binarySearch(frames, time), prevVertices = frameVertices[frame - 1], nextVertices = frameVertices[frame], frameTime = frames[frame], percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime)), vertexAttachment;
                if (1 == alpha) if (blend == MixBlend.add) if (null == (vertexAttachment = slotAttachment).bones) for (var setupVertices = vertexAttachment.vertices, i_8 = 0; i_8 < vertexCount; i_8++) {
                  var prev = prevVertices[i_8];
                  deform[i_8] += prev + (nextVertices[i_8] - prev) * percent - setupVertices[i_8];
                }
                else for (var i_9 = 0; i_9 < vertexCount; i_9++) {
                  var prev = prevVertices[i_9];
                  deform[i_9] += prev + (nextVertices[i_9] - prev) * percent;
                }
                else for (var i_10 = 0; i_10 < vertexCount; i_10++) {
                  var prev = prevVertices[i_10];
                  deform[i_10] = prev + (nextVertices[i_10] - prev) * percent;
                }
                else switch (blend) {
                  case MixBlend.setup:
                    var vertexAttachment_2 = slotAttachment;
                    if (null == vertexAttachment_2.bones) for (var setupVertices = vertexAttachment_2.vertices, i_11 = 0; i_11 < vertexCount; i_11++) {
                      var prev = prevVertices[i_11], setup = setupVertices[i_11];
                      deform[i_11] = setup + (prev + (nextVertices[i_11] - prev) * percent - setup) * alpha;
                    }
                    else for (var i_12 = 0; i_12 < vertexCount; i_12++) {
                      var prev = prevVertices[i_12];
                      deform[i_12] = (prev + (nextVertices[i_12] - prev) * percent) * alpha;
                    }
                    break;
                  case MixBlend.first:
                  case MixBlend.replace:
                    for (var i_13 = 0; i_13 < vertexCount; i_13++) {
                      var prev = prevVertices[i_13];
                      deform[i_13] += (prev + (nextVertices[i_13] - prev) * percent - deform[i_13]) * alpha;
                    }
                    break;
                  case MixBlend.add:
                    var vertexAttachment;
                    if (null == (vertexAttachment = slotAttachment).bones) for (var setupVertices = vertexAttachment.vertices, i_14 = 0; i_14 < vertexCount; i_14++) {
                      var prev = prevVertices[i_14];
                      deform[i_14] += (prev + (nextVertices[i_14] - prev) * percent - setupVertices[i_14]) * alpha;
                    }
                    else for (var i_15 = 0; i_15 < vertexCount; i_15++) {
                      var prev = prevVertices[i_15];
                      deform[i_15] += (prev + (nextVertices[i_15] - prev) * percent) * alpha;
                    }
                }
              }
            }
          }
        }
      }, DeformTimeline2;
    })(CurveTimeline);
    spine4.DeformTimeline = DeformTimeline;
    var EventTimeline = (function() {
      function EventTimeline2(frameCount) {
        this.frames = spine4.Utils.newFloatArray(frameCount), this.events = new Array(frameCount);
      }
      return EventTimeline2.prototype.getPropertyId = function() {
        return TimelineType.event << 24;
      }, EventTimeline2.prototype.getFrameCount = function() {
        return this.frames.length;
      }, EventTimeline2.prototype.setFrame = function(frameIndex, event) {
        this.frames[frameIndex] = event.time, this.events[frameIndex] = event;
      }, EventTimeline2.prototype.apply = function(skeleton2, lastTime, time, firedEvents, alpha, blend, direction) {
        if (null != firedEvents) {
          var frames = this.frames, frameCount = this.frames.length;
          if (lastTime > time) this.apply(skeleton2, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction), lastTime = -1;
          else if (lastTime >= frames[frameCount - 1]) return;
          if (!(time < frames[0])) {
            var frame = 0;
            if (lastTime < frames[0]) frame = 0;
            else for (var frameTime = frames[frame = Animation.binarySearch(frames, lastTime)]; frame > 0 && frames[frame - 1] == frameTime; ) frame--;
            for (; frame < frameCount && time >= frames[frame]; frame++) firedEvents.push(this.events[frame]);
          }
        }
      }, EventTimeline2;
    })();
    spine4.EventTimeline = EventTimeline;
    var DrawOrderTimeline = (function() {
      function DrawOrderTimeline2(frameCount) {
        this.frames = spine4.Utils.newFloatArray(frameCount), this.drawOrders = new Array(frameCount);
      }
      return DrawOrderTimeline2.prototype.getPropertyId = function() {
        return TimelineType.drawOrder << 24;
      }, DrawOrderTimeline2.prototype.getFrameCount = function() {
        return this.frames.length;
      }, DrawOrderTimeline2.prototype.setFrame = function(frameIndex, time, drawOrder) {
        this.frames[frameIndex] = time, this.drawOrders[frameIndex] = drawOrder;
      }, DrawOrderTimeline2.prototype.apply = function(skeleton2, lastTime, time, firedEvents, alpha, blend, direction) {
        var drawOrder = Skeleton.drawOrder, slots = Skeleton.slots;
        if (direction != MixDirection.mixOut) {
          var frames = this.frames;
          if (time < frames[0]) blend != MixBlend.setup && blend != MixBlend.first || spine4.Utils.arrayCopy(skeleton2.slots, 0, Skeleton.drawOrder, 0, Skeleton.slots.length);
          else {
            var frame = 0;
            frame = time >= frames[frames.length - 1] ? frames.length - 1 : Animation.binarySearch(frames, time) - 1;
            var drawOrderToSetupIndex = this.drawOrders[frame];
            if (null == drawOrderToSetupIndex) spine4.Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);
            else for (var i = 0, n = drawOrderToSetupIndex.length; i < n; i++) drawOrder[i] = slots[drawOrderToSetupIndex[i]];
          }
        } else blend == MixBlend.setup && spine4.Utils.arrayCopy(skeleton2.slots, 0, Skeleton.drawOrder, 0, Skeleton.slots.length);
      }, DrawOrderTimeline2;
    })();
    spine4.DrawOrderTimeline = DrawOrderTimeline;
    var IkConstraintTimeline = (function(_super) {
      function IkConstraintTimeline2(frameCount) {
        var _this = _super.call(this, frameCount) || this;
        return _this.frames = spine4.Utils.newFloatArray(frameCount * IkConstraintTimeline2.ENTRIES), _this;
      }
      return __extends(IkConstraintTimeline2, _super), IkConstraintTimeline2.prototype.getPropertyId = function() {
        return (TimelineType.ikConstraint << 24) + this.ikConstraintIndex;
      }, IkConstraintTimeline2.prototype.setFrame = function(frameIndex, time, mix, softness, bendDirection, compress, stretch) {
        frameIndex *= IkConstraintTimeline2.ENTRIES, this.frames[frameIndex] = time, this.frames[frameIndex + IkConstraintTimeline2.MIX] = mix, this.frames[frameIndex + IkConstraintTimeline2.SOFTNESS] = softness, this.frames[frameIndex + IkConstraintTimeline2.BEND_DIRECTION] = bendDirection, this.frames[frameIndex + IkConstraintTimeline2.COMPRESS] = compress ? 1 : 0, this.frames[frameIndex + IkConstraintTimeline2.STRETCH] = stretch ? 1 : 0;
      }, IkConstraintTimeline2.prototype.apply = function(skeleton2, lastTime, time, firedEvents, alpha, blend, direction) {
        var frames = this.frames, constraint = Skeleton.ikConstraints[this.ikConstraintIndex];
        if (constraint.active) if (time < frames[0]) switch (blend) {
          case MixBlend.setup:
            return constraint.mix = constraint.data.mix, constraint.softness = constraint.data.softness, constraint.bendDirection = constraint.data.bendDirection, constraint.compress = constraint.data.compress, void (constraint.stretch = constraint.data.stretch);
          case MixBlend.first:
            constraint.mix += (constraint.data.mix - constraint.mix) * alpha, constraint.softness += (constraint.data.softness - constraint.softness) * alpha, constraint.bendDirection = constraint.data.bendDirection, constraint.compress = constraint.data.compress, constraint.stretch = constraint.data.stretch;
        }
        else if (time >= frames[frames.length - IkConstraintTimeline2.ENTRIES]) blend == MixBlend.setup ? (constraint.mix = constraint.data.mix + (frames[frames.length + IkConstraintTimeline2.PREV_MIX] - constraint.data.mix) * alpha, constraint.softness = constraint.data.softness + (frames[frames.length + IkConstraintTimeline2.PREV_SOFTNESS] - constraint.data.softness) * alpha, direction == MixDirection.mixOut ? (constraint.bendDirection = constraint.data.bendDirection, constraint.compress = constraint.data.compress, constraint.stretch = constraint.data.stretch) : (constraint.bendDirection = frames[frames.length + IkConstraintTimeline2.PREV_BEND_DIRECTION], constraint.compress = 0 != frames[frames.length + IkConstraintTimeline2.PREV_COMPRESS], constraint.stretch = 0 != frames[frames.length + IkConstraintTimeline2.PREV_STRETCH])) : (constraint.mix += (frames[frames.length + IkConstraintTimeline2.PREV_MIX] - constraint.mix) * alpha, constraint.softness += (frames[frames.length + IkConstraintTimeline2.PREV_SOFTNESS] - constraint.softness) * alpha, direction == MixDirection.mixIn && (constraint.bendDirection = frames[frames.length + IkConstraintTimeline2.PREV_BEND_DIRECTION], constraint.compress = 0 != frames[frames.length + IkConstraintTimeline2.PREV_COMPRESS], constraint.stretch = 0 != frames[frames.length + IkConstraintTimeline2.PREV_STRETCH]));
        else {
          var frame = Animation.binarySearch(frames, time, IkConstraintTimeline2.ENTRIES), mix = frames[frame + IkConstraintTimeline2.PREV_MIX], softness = frames[frame + IkConstraintTimeline2.PREV_SOFTNESS], frameTime = frames[frame], percent = this.getCurvePercent(frame / IkConstraintTimeline2.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + IkConstraintTimeline2.PREV_TIME] - frameTime));
          blend == MixBlend.setup ? (constraint.mix = constraint.data.mix + (mix + (frames[frame + IkConstraintTimeline2.MIX] - mix) * percent - constraint.data.mix) * alpha, constraint.softness = constraint.data.softness + (softness + (frames[frame + IkConstraintTimeline2.SOFTNESS] - softness) * percent - constraint.data.softness) * alpha, direction == MixDirection.mixOut ? (constraint.bendDirection = constraint.data.bendDirection, constraint.compress = constraint.data.compress, constraint.stretch = constraint.data.stretch) : (constraint.bendDirection = frames[frame + IkConstraintTimeline2.PREV_BEND_DIRECTION], constraint.compress = 0 != frames[frame + IkConstraintTimeline2.PREV_COMPRESS], constraint.stretch = 0 != frames[frame + IkConstraintTimeline2.PREV_STRETCH])) : (constraint.mix += (mix + (frames[frame + IkConstraintTimeline2.MIX] - mix) * percent - constraint.mix) * alpha, constraint.softness += (softness + (frames[frame + IkConstraintTimeline2.SOFTNESS] - softness) * percent - constraint.softness) * alpha, direction == MixDirection.mixIn && (constraint.bendDirection = frames[frame + IkConstraintTimeline2.PREV_BEND_DIRECTION], constraint.compress = 0 != frames[frame + IkConstraintTimeline2.PREV_COMPRESS], constraint.stretch = 0 != frames[frame + IkConstraintTimeline2.PREV_STRETCH]));
        }
      }, IkConstraintTimeline2.ENTRIES = 6, IkConstraintTimeline2.PREV_TIME = -6, IkConstraintTimeline2.PREV_MIX = -5, IkConstraintTimeline2.PREV_SOFTNESS = -4, IkConstraintTimeline2.PREV_BEND_DIRECTION = -3, IkConstraintTimeline2.PREV_COMPRESS = -2, IkConstraintTimeline2.PREV_STRETCH = -1, IkConstraintTimeline2.MIX = 1, IkConstraintTimeline2.SOFTNESS = 2, IkConstraintTimeline2.BEND_DIRECTION = 3, IkConstraintTimeline2.COMPRESS = 4, IkConstraintTimeline2.STRETCH = 5, IkConstraintTimeline2;
    })(CurveTimeline);
    spine4.IkConstraintTimeline = IkConstraintTimeline;
    var TransformConstraintTimeline = (function(_super) {
      function TransformConstraintTimeline2(frameCount) {
        var _this = _super.call(this, frameCount) || this;
        return _this.frames = spine4.Utils.newFloatArray(frameCount * TransformConstraintTimeline2.ENTRIES), _this;
      }
      return __extends(TransformConstraintTimeline2, _super), TransformConstraintTimeline2.prototype.getPropertyId = function() {
        return (TimelineType.transformConstraint << 24) + this.transformConstraintIndex;
      }, TransformConstraintTimeline2.prototype.setFrame = function(frameIndex, time, rotateMix, translateMix, scaleMix, shearMix) {
        frameIndex *= TransformConstraintTimeline2.ENTRIES, this.frames[frameIndex] = time, this.frames[frameIndex + TransformConstraintTimeline2.ROTATE] = rotateMix, this.frames[frameIndex + TransformConstraintTimeline2.TRANSLATE] = translateMix, this.frames[frameIndex + TransformConstraintTimeline2.SCALE] = scaleMix, this.frames[frameIndex + TransformConstraintTimeline2.SHEAR] = shearMix;
      }, TransformConstraintTimeline2.prototype.apply = function(skeleton2, lastTime, time, firedEvents, alpha, blend, direction) {
        var frames = this.frames, constraint = Skeleton.transformConstraints[this.transformConstraintIndex];
        if (constraint.active) if (time < frames[0]) {
          var data = constraint.data;
          switch (blend) {
            case MixBlend.setup:
              return constraint.rotateMix = data.rotateMix, constraint.translateMix = data.translateMix, constraint.scaleMix = data.scaleMix, void (constraint.shearMix = data.shearMix);
            case MixBlend.first:
              constraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha, constraint.translateMix += (data.translateMix - constraint.translateMix) * alpha, constraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha, constraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;
          }
        } else {
          var rotate = 0, translate = 0, scale = 0, shear = 0;
          if (time >= frames[frames.length - TransformConstraintTimeline2.ENTRIES]) {
            var i = frames.length;
            rotate = frames[i + TransformConstraintTimeline2.PREV_ROTATE], translate = frames[i + TransformConstraintTimeline2.PREV_TRANSLATE], scale = frames[i + TransformConstraintTimeline2.PREV_SCALE], shear = frames[i + TransformConstraintTimeline2.PREV_SHEAR];
          } else {
            var frame = Animation.binarySearch(frames, time, TransformConstraintTimeline2.ENTRIES);
            rotate = frames[frame + TransformConstraintTimeline2.PREV_ROTATE], translate = frames[frame + TransformConstraintTimeline2.PREV_TRANSLATE], scale = frames[frame + TransformConstraintTimeline2.PREV_SCALE], shear = frames[frame + TransformConstraintTimeline2.PREV_SHEAR];
            var frameTime = frames[frame], percent = this.getCurvePercent(frame / TransformConstraintTimeline2.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TransformConstraintTimeline2.PREV_TIME] - frameTime));
            rotate += (frames[frame + TransformConstraintTimeline2.ROTATE] - rotate) * percent, translate += (frames[frame + TransformConstraintTimeline2.TRANSLATE] - translate) * percent, scale += (frames[frame + TransformConstraintTimeline2.SCALE] - scale) * percent, shear += (frames[frame + TransformConstraintTimeline2.SHEAR] - shear) * percent;
          }
          if (blend == MixBlend.setup) {
            var data = constraint.data;
            constraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha, constraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha, constraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha, constraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;
          } else constraint.rotateMix += (rotate - constraint.rotateMix) * alpha, constraint.translateMix += (translate - constraint.translateMix) * alpha, constraint.scaleMix += (scale - constraint.scaleMix) * alpha, constraint.shearMix += (shear - constraint.shearMix) * alpha;
        }
      }, TransformConstraintTimeline2.ENTRIES = 5, TransformConstraintTimeline2.PREV_TIME = -5, TransformConstraintTimeline2.PREV_ROTATE = -4, TransformConstraintTimeline2.PREV_TRANSLATE = -3, TransformConstraintTimeline2.PREV_SCALE = -2, TransformConstraintTimeline2.PREV_SHEAR = -1, TransformConstraintTimeline2.ROTATE = 1, TransformConstraintTimeline2.TRANSLATE = 2, TransformConstraintTimeline2.SCALE = 3, TransformConstraintTimeline2.SHEAR = 4, TransformConstraintTimeline2;
    })(CurveTimeline);
    spine4.TransformConstraintTimeline = TransformConstraintTimeline;
    var PathConstraintPositionTimeline = (function(_super) {
      function PathConstraintPositionTimeline2(frameCount) {
        var _this = _super.call(this, frameCount) || this;
        return _this.frames = spine4.Utils.newFloatArray(frameCount * PathConstraintPositionTimeline2.ENTRIES), _this;
      }
      return __extends(PathConstraintPositionTimeline2, _super), PathConstraintPositionTimeline2.prototype.getPropertyId = function() {
        return (TimelineType.pathConstraintPosition << 24) + this.pathConstraintIndex;
      }, PathConstraintPositionTimeline2.prototype.setFrame = function(frameIndex, time, value) {
        frameIndex *= PathConstraintPositionTimeline2.ENTRIES, this.frames[frameIndex] = time, this.frames[frameIndex + PathConstraintPositionTimeline2.VALUE] = value;
      }, PathConstraintPositionTimeline2.prototype.apply = function(skeleton2, lastTime, time, firedEvents, alpha, blend, direction) {
        var frames = this.frames, constraint = Skeleton.pathConstraints[this.pathConstraintIndex];
        if (constraint.active) if (time < frames[0]) switch (blend) {
          case MixBlend.setup:
            return void (constraint.position = constraint.data.position);
          case MixBlend.first:
            constraint.position += (constraint.data.position - constraint.position) * alpha;
        }
        else {
          var position = 0;
          if (time >= frames[frames.length - PathConstraintPositionTimeline2.ENTRIES]) position = frames[frames.length + PathConstraintPositionTimeline2.PREV_VALUE];
          else {
            var frame = Animation.binarySearch(frames, time, PathConstraintPositionTimeline2.ENTRIES);
            position = frames[frame + PathConstraintPositionTimeline2.PREV_VALUE];
            var frameTime = frames[frame], percent = this.getCurvePercent(frame / PathConstraintPositionTimeline2.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintPositionTimeline2.PREV_TIME] - frameTime));
            position += (frames[frame + PathConstraintPositionTimeline2.VALUE] - position) * percent;
          }
          blend == MixBlend.setup ? constraint.position = constraint.data.position + (position - constraint.data.position) * alpha : constraint.position += (position - constraint.position) * alpha;
        }
      }, PathConstraintPositionTimeline2.ENTRIES = 2, PathConstraintPositionTimeline2.PREV_TIME = -2, PathConstraintPositionTimeline2.PREV_VALUE = -1, PathConstraintPositionTimeline2.VALUE = 1, PathConstraintPositionTimeline2;
    })(CurveTimeline);
    spine4.PathConstraintPositionTimeline = PathConstraintPositionTimeline;
    var PathConstraintSpacingTimeline = (function(_super) {
      function PathConstraintSpacingTimeline2(frameCount) {
        return _super.call(this, frameCount) || this;
      }
      return __extends(PathConstraintSpacingTimeline2, _super), PathConstraintSpacingTimeline2.prototype.getPropertyId = function() {
        return (TimelineType.pathConstraintSpacing << 24) + this.pathConstraintIndex;
      }, PathConstraintSpacingTimeline2.prototype.apply = function(skeleton2, lastTime, time, firedEvents, alpha, blend, direction) {
        var frames = this.frames, constraint = Skeleton.pathConstraints[this.pathConstraintIndex];
        if (constraint.active) if (time < frames[0]) switch (blend) {
          case MixBlend.setup:
            return void (constraint.spacing = constraint.data.spacing);
          case MixBlend.first:
            constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;
        }
        else {
          var spacing = 0;
          if (time >= frames[frames.length - PathConstraintSpacingTimeline2.ENTRIES]) spacing = frames[frames.length + PathConstraintSpacingTimeline2.PREV_VALUE];
          else {
            var frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline2.ENTRIES);
            spacing = frames[frame + PathConstraintSpacingTimeline2.PREV_VALUE];
            var frameTime = frames[frame], percent = this.getCurvePercent(frame / PathConstraintSpacingTimeline2.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline2.PREV_TIME] - frameTime));
            spacing += (frames[frame + PathConstraintSpacingTimeline2.VALUE] - spacing) * percent;
          }
          blend == MixBlend.setup ? constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha : constraint.spacing += (spacing - constraint.spacing) * alpha;
        }
      }, PathConstraintSpacingTimeline2;
    })(PathConstraintPositionTimeline);
    spine4.PathConstraintSpacingTimeline = PathConstraintSpacingTimeline;
    var PathConstraintMixTimeline = (function(_super) {
      function PathConstraintMixTimeline2(frameCount) {
        var _this = _super.call(this, frameCount) || this;
        return _this.frames = spine4.Utils.newFloatArray(frameCount * PathConstraintMixTimeline2.ENTRIES), _this;
      }
      return __extends(PathConstraintMixTimeline2, _super), PathConstraintMixTimeline2.prototype.getPropertyId = function() {
        return (TimelineType.pathConstraintMix << 24) + this.pathConstraintIndex;
      }, PathConstraintMixTimeline2.prototype.setFrame = function(frameIndex, time, rotateMix, translateMix) {
        frameIndex *= PathConstraintMixTimeline2.ENTRIES, this.frames[frameIndex] = time, this.frames[frameIndex + PathConstraintMixTimeline2.ROTATE] = rotateMix, this.frames[frameIndex + PathConstraintMixTimeline2.TRANSLATE] = translateMix;
      }, PathConstraintMixTimeline2.prototype.apply = function(skeleton2, lastTime, time, firedEvents, alpha, blend, direction) {
        var frames = this.frames, constraint = Skeleton.pathConstraints[this.pathConstraintIndex];
        if (constraint.active) if (time < frames[0]) switch (blend) {
          case MixBlend.setup:
            return constraint.rotateMix = constraint.data.rotateMix, void (constraint.translateMix = constraint.data.translateMix);
          case MixBlend.first:
            constraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha, constraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;
        }
        else {
          var rotate = 0, translate = 0;
          if (time >= frames[frames.length - PathConstraintMixTimeline2.ENTRIES]) rotate = frames[frames.length + PathConstraintMixTimeline2.PREV_ROTATE], translate = frames[frames.length + PathConstraintMixTimeline2.PREV_TRANSLATE];
          else {
            var frame = Animation.binarySearch(frames, time, PathConstraintMixTimeline2.ENTRIES);
            rotate = frames[frame + PathConstraintMixTimeline2.PREV_ROTATE], translate = frames[frame + PathConstraintMixTimeline2.PREV_TRANSLATE];
            var frameTime = frames[frame], percent = this.getCurvePercent(frame / PathConstraintMixTimeline2.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintMixTimeline2.PREV_TIME] - frameTime));
            rotate += (frames[frame + PathConstraintMixTimeline2.ROTATE] - rotate) * percent, translate += (frames[frame + PathConstraintMixTimeline2.TRANSLATE] - translate) * percent;
          }
          blend == MixBlend.setup ? (constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha, constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha) : (constraint.rotateMix += (rotate - constraint.rotateMix) * alpha, constraint.translateMix += (translate - constraint.translateMix) * alpha);
        }
      }, PathConstraintMixTimeline2.ENTRIES = 3, PathConstraintMixTimeline2.PREV_TIME = -3, PathConstraintMixTimeline2.PREV_ROTATE = -2, PathConstraintMixTimeline2.PREV_TRANSLATE = -1, PathConstraintMixTimeline2.ROTATE = 1, PathConstraintMixTimeline2.TRANSLATE = 2, PathConstraintMixTimeline2;
    })(CurveTimeline);
    spine4.PathConstraintMixTimeline = PathConstraintMixTimeline;
  })(spine || (spine = {})), (function(spine4) {
    var AnimationState = (function() {
      function AnimationState2(data) {
        this.tracks = new Array(), this.timeScale = 1, this.unkeyedState = 0, this.events = new Array(), this.listeners = new Array(), this.queue = new EventQueue(this), this.propertyIDs = new spine4.IntSet(), this.animationsChanged = false, this.trackEntryPool = new spine4.Pool((function() {
          return new TrackEntry();
        })), this.data = data;
      }
      return AnimationState2.prototype.update = function(delta) {
        delta *= this.timeScale;
        for (var tracks = this.tracks, i = 0, n = tracks.length; i < n; i++) {
          var current = tracks[i];
          if (null != current) {
            current.animationLast = current.nextAnimationLast, current.trackLast = current.nextTrackLast;
            var currentDelta = delta * current.timeScale;
            if (current.delay > 0) {
              if (current.delay -= currentDelta, current.delay > 0) continue;
              currentDelta = -current.delay, current.delay = 0;
            }
            var next = current.next;
            if (null != next) {
              var nextTime = current.trackLast - next.delay;
              if (nextTime >= 0) {
                for (next.delay = 0, next.trackTime += 0 == current.timeScale ? 0 : (nextTime / current.timeScale + delta) * next.timeScale, current.trackTime += currentDelta, this.setCurrent(i, next, true); null != next.mixingFrom; ) next.mixTime += delta, next = next.mixingFrom;
                continue;
              }
            } else if (current.trackLast >= current.trackEnd && null == current.mixingFrom) {
              tracks[i] = null, this.queue.end(current), this.disposeNext(current);
              continue;
            }
            if (null != current.mixingFrom && this.updateMixingFrom(current, delta)) {
              var from = current.mixingFrom;
              for (current.mixingFrom = null, null != from && (from.mixingTo = null); null != from; ) this.queue.end(from), from = from.mixingFrom;
            }
            current.trackTime += currentDelta;
          }
        }
        this.queue.drain();
      }, AnimationState2.prototype.updateMixingFrom = function(to, delta) {
        var from = to.mixingFrom;
        if (null == from) return true;
        var finished = this.updateMixingFrom(from, delta);
        return from.animationLast = from.nextAnimationLast, from.trackLast = from.nextTrackLast, to.mixTime > 0 && to.mixTime >= to.mixDuration ? (0 != from.totalAlpha && 0 != to.mixDuration || (to.mixingFrom = from.mixingFrom, null != from.mixingFrom && (from.mixingFrom.mixingTo = to), to.interruptAlpha = from.interruptAlpha, this.queue.end(from)), finished) : (from.trackTime += delta * from.timeScale, to.mixTime += delta, false);
      }, AnimationState2.prototype.apply = function(skeleton2) {
        if (null == skeleton2) throw new Error("skeleton cannot be null.");
        this.animationsChanged && this._animationsChanged();
        for (var events = this.events, tracks = this.tracks, applied = false, i_16 = 0, n_1 = tracks.length; i_16 < n_1; i_16++) {
          var current = tracks[i_16];
          if (!(null == current || current.delay > 0)) {
            applied = true;
            var blend = 0 == i_16 ? spine4.MixBlend.first : current.mixBlend, mix = current.alpha;
            null != current.mixingFrom ? mix *= this.applyMixingFrom(current, Skeleton, blend) : current.trackTime >= current.trackEnd && null == current.next && (mix = 0);
            var animationLast = current.animationLast, animationTime = current.getAnimationTime(), timelineCount = current.animation.timelines.length, timelines = current.animation.timelines;
            if (0 == i_16 && 1 == mix || blend == spine4.MixBlend.add) for (var ii = 0; ii < timelineCount; ii++) {
              spine4.Utils.webkit602BugfixHelper(mix, blend);
              var timeline = timelines[ii];
              timeline instanceof spine4.AttachmentTimeline ? this.applyAttachmentTimeline(timeline, Skeleton, animationTime, blend, true) : timeline.apply(skeleton2, animationLast, animationTime, events, mix, blend, spine4.MixDirection.mixIn);
            }
            else {
              var timelineMode = current.timelineMode, firstFrame = 0 == current.timelinesRotation.length;
              firstFrame && spine4.Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);
              for (var timelinesRotation = current.timelinesRotation, ii = 0; ii < timelineCount; ii++) {
                var timeline_1 = timelines[ii], timelineBlend = timelineMode[ii] == AnimationState2.SUBSEQUENT ? blend : spine4.MixBlend.setup;
                timeline_1 instanceof spine4.RotateTimeline ? this.applyRotateTimeline(timeline_1, Skeleton, animationTime, mix, timelineBlend, timelinesRotation, ii << 1, firstFrame) : timeline_1 instanceof spine4.AttachmentTimeline ? this.applyAttachmentTimeline(timeline_1, Skeleton, animationTime, blend, true) : (spine4.Utils.webkit602BugfixHelper(mix, blend), timeline_1.apply(skeleton2, animationLast, animationTime, events, mix, timelineBlend, spine4.MixDirection.mixIn));
              }
            }
            this.queueEvents(current, animationTime), events.length = 0, current.nextAnimationLast = animationTime, current.nextTrackLast = current.trackTime;
          }
        }
        for (var setupState = this.unkeyedState + AnimationState2.SETUP, slots = Skeleton.slots, i = 0, n = Skeleton.slots.length; i < n; i++) {
          var slot = slots[i];
          if (slot.attachmentState == setupState) {
            var attachmentName = slot.data.attachmentName;
            slot.setAttachment(null == attachmentName ? null : Skeleton.getAttachment(slot.data.index, attachmentName));
          }
        }
        return this.unkeyedState += 2, this.queue.drain(), applied;
      }, AnimationState2.prototype.applyMixingFrom = function(to, Skeleton2, blend) {
        var from = to.mixingFrom;
        null != from.mixingFrom && this.applyMixingFrom(from, Skeleton2, blend);
        var mix = 0;
        0 == to.mixDuration ? (mix = 1, blend == spine4.MixBlend.first && (blend = spine4.MixBlend.setup)) : ((mix = to.mixTime / to.mixDuration) > 1 && (mix = 1), blend != spine4.MixBlend.first && (blend = from.mixBlend));
        var events = mix < from.eventThreshold ? this.events : null, attachments = mix < from.attachmentThreshold, drawOrder = mix < from.drawOrderThreshold, animationLast = from.animationLast, animationTime = from.getAnimationTime(), timelineCount = from.animation.timelines.length, timelines = from.animation.timelines, alphaHold = from.alpha * to.interruptAlpha, alphaMix = alphaHold * (1 - mix);
        if (blend == spine4.MixBlend.add) for (var i = 0; i < timelineCount; i++) timelines[i].apply(skeleton, animationLast, animationTime, events, alphaMix, blend, spine4.MixDirection.mixOut);
        else {
          var timelineMode = from.timelineMode, timelineHoldMix = from.timelineHoldMix, firstFrame = 0 == from.timelinesRotation.length;
          firstFrame && spine4.Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);
          var timelinesRotation = from.timelinesRotation;
          from.totalAlpha = 0;
          for (var i = 0; i < timelineCount; i++) {
            var timeline = timelines[i], direction = spine4.MixDirection.mixOut, timelineBlend = void 0, alpha = 0;
            switch (timelineMode[i]) {
              case AnimationState2.SUBSEQUENT:
                if (!drawOrder && timeline instanceof spine4.DrawOrderTimeline) continue;
                timelineBlend = blend, alpha = alphaMix;
                break;
              case AnimationState2.FIRST:
                timelineBlend = spine4.MixBlend.setup, alpha = alphaMix;
                break;
              case AnimationState2.HOLD_SUBSEQUENT:
                timelineBlend = blend, alpha = alphaHold;
                break;
              case AnimationState2.HOLD_FIRST:
                timelineBlend = spine4.MixBlend.setup, alpha = alphaHold;
                break;
              default:
                timelineBlend = spine4.MixBlend.setup;
                var holdMix = timelineHoldMix[i];
                alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);
            }
            from.totalAlpha += alpha, timeline instanceof spine4.RotateTimeline ? this.applyRotateTimeline(timeline, Skeleton2, animationTime, alpha, timelineBlend, timelinesRotation, i << 1, firstFrame) : timeline instanceof spine4.AttachmentTimeline ? this.applyAttachmentTimeline(timeline, Skeleton2, animationTime, timelineBlend, attachments) : (spine4.Utils.webkit602BugfixHelper(alpha, blend), drawOrder && timeline instanceof spine4.DrawOrderTimeline && timelineBlend == spine4.MixBlend.setup && (direction = spine4.MixDirection.mixIn), timeline.apply(skeleton, animationLast, animationTime, events, alpha, timelineBlend, direction));
          }
        }
        return to.mixDuration > 0 && this.queueEvents(from, animationTime), this.events.length = 0, from.nextAnimationLast = animationTime, from.nextTrackLast = from.trackTime, mix;
      }, AnimationState2.prototype.applyAttachmentTimeline = function(timeline, Skeleton2, time, blend, attachments) {
        var slot = Skeleton2.slots[timeline.slotIndex];
        if (slot.bone.active) {
          var frames = timeline.frames, frameIndex;
          if (time < frames[0]) blend != spine4.MixBlend.setup && blend != spine4.MixBlend.first || this.setAttachment(skeleton, slot, slot.data.attachmentName, attachments);
          else frameIndex = time >= frames[frames.length - 1] ? frames.length - 1 : spine4.Animation.binarySearch(frames, time) - 1, this.setAttachment(skeleton, slot, timeline.attachmentNames[frameIndex], attachments);
          slot.attachmentState <= this.unkeyedState && (slot.attachmentState = this.unkeyedState + AnimationState2.SETUP);
        }
      }, AnimationState2.prototype.setAttachment = function(skeleton2, slot, attachmentName, attachments) {
        slot.setAttachment(null == attachmentName ? null : Skeleton.getAttachment(slot.data.index, attachmentName)), attachments && (slot.attachmentState = this.unkeyedState + AnimationState2.CURRENT);
      }, AnimationState2.prototype.applyRotateTimeline = function(timeline, Skeleton2, time, alpha, blend, timelinesRotation, i, firstFrame) {
        if (firstFrame && (timelinesRotation[i] = 0), 1 != alpha) {
          var rotateTimeline = timeline, frames = rotateTimeline.frames, bone = Skeleton2.bones[rotateTimeline.boneIndex];
          if (bone.active) {
            var r1 = 0, r2 = 0;
            if (time < frames[0]) switch (blend) {
              case spine4.MixBlend.setup:
                bone.rotation = bone.data.rotation;
              default:
                return;
              case spine4.MixBlend.first:
                r1 = bone.rotation, r2 = bone.data.rotation;
            }
            else if (r1 = blend == spine4.MixBlend.setup ? bone.data.rotation : bone.rotation, time >= frames[frames.length - spine4.RotateTimeline.ENTRIES]) r2 = bone.data.rotation + frames[frames.length + spine4.RotateTimeline.PREV_ROTATION];
            else {
              var frame = spine4.Animation.binarySearch(frames, time, spine4.RotateTimeline.ENTRIES), prevRotation = frames[frame + spine4.RotateTimeline.PREV_ROTATION], frameTime = frames[frame], percent = rotateTimeline.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + spine4.RotateTimeline.PREV_TIME] - frameTime));
              r2 = frames[frame + spine4.RotateTimeline.ROTATION] - prevRotation, r2 = prevRotation + (r2 -= 360 * (16384 - (16384.499999999996 - r2 / 360 | 0))) * percent + bone.data.rotation, r2 -= 360 * (16384 - (16384.499999999996 - r2 / 360 | 0));
            }
            var total = 0, diff = r2 - r1;
            if (0 == (diff -= 360 * (16384 - (16384.499999999996 - diff / 360 | 0)))) total = timelinesRotation[i];
            else {
              var lastTotal = 0, lastDiff = 0;
              firstFrame ? (lastTotal = 0, lastDiff = diff) : (lastTotal = timelinesRotation[i], lastDiff = timelinesRotation[i + 1]);
              var current = diff > 0, dir = lastTotal >= 0;
              spine4.MathUtils.signum(lastDiff) != spine4.MathUtils.signum(diff) && Math.abs(lastDiff) <= 90 && (Math.abs(lastTotal) > 180 && (lastTotal += 360 * spine4.MathUtils.signum(lastTotal)), dir = current), total = diff + lastTotal - lastTotal % 360, dir != current && (total += 360 * spine4.MathUtils.signum(lastTotal)), timelinesRotation[i] = total;
            }
            timelinesRotation[i + 1] = diff, r1 += total * alpha, bone.rotation = r1 - 360 * (16384 - (16384.499999999996 - r1 / 360 | 0));
          }
        } else timeline.apply(skeleton, 0, time, null, 1, blend, spine4.MixDirection.mixIn);
      }, AnimationState2.prototype.queueEvents = function(entry, animationTime) {
        for (var animationStart = entry.animationStart, animationEnd = entry.animationEnd, duration = animationEnd - animationStart, trackLastWrapped = entry.trackLast % duration, events = this.events, i = 0, n = events.length; i < n; i++) {
          var event_1 = events[i];
          if (event_1.time < trackLastWrapped) break;
          event_1.time > animationEnd || this.queue.event(entry, event_1);
        }
        for ((entry.loop ? 0 == duration || trackLastWrapped > entry.trackTime % duration : animationTime >= animationEnd && entry.animationLast < animationEnd) && this.queue.complete(entry); i < n; i++) {
          events[i].time < animationStart || this.queue.event(entry, events[i]);
        }
      }, AnimationState2.prototype.clearTracks = function() {
        var oldDrainDisabled = this.queue.drainDisabled;
        this.queue.drainDisabled = true;
        for (var i = 0, n = this.tracks.length; i < n; i++) this.clearTrack(i);
        this.tracks.length = 0, this.queue.drainDisabled = oldDrainDisabled, this.queue.drain();
      }, AnimationState2.prototype.clearTrack = function(trackIndex) {
        if (!(trackIndex >= this.tracks.length)) {
          var current = this.tracks[trackIndex];
          if (null != current) {
            this.queue.end(current), this.disposeNext(current);
            for (var entry = current; ; ) {
              var from = entry.mixingFrom;
              if (null == from) break;
              this.queue.end(from), entry.mixingFrom = null, entry.mixingTo = null, entry = from;
            }
            this.tracks[current.trackIndex] = null, this.queue.drain();
          }
        }
      }, AnimationState2.prototype.setCurrent = function(index, current, interrupt) {
        var from = this.expandToIndex(index);
        this.tracks[index] = current, null != from && (interrupt && this.queue.interrupt(from), current.mixingFrom = from, from.mixingTo = current, current.mixTime = 0, null != from.mixingFrom && from.mixDuration > 0 && (current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration)), from.timelinesRotation.length = 0), this.queue.start(current);
      }, AnimationState2.prototype.setAnimation = function(trackIndex, animationName, loop) {
        var animation = this.data.skeletonData.findAnimation(animationName);
        if (null == animation) throw new Error("Animation not found: " + animationName);
        return this.setAnimationWith(trackIndex, animation, loop);
      }, AnimationState2.prototype.setAnimationWith = function(trackIndex, animation, loop) {
        if (null == animation) throw new Error("animation cannot be null.");
        var interrupt = true, current = this.expandToIndex(trackIndex);
        null != current && (-1 == current.nextTrackLast ? (this.tracks[trackIndex] = current.mixingFrom, this.queue.interrupt(current), this.queue.end(current), this.disposeNext(current), current = current.mixingFrom, interrupt = false) : this.disposeNext(current));
        var entry = this.trackEntry(trackIndex, animation, loop, current);
        return this.setCurrent(trackIndex, entry, interrupt), this.queue.drain(), entry;
      }, AnimationState2.prototype.addAnimation = function(trackIndex, animationName, loop, delay) {
        var animation = this.data.skeletonData.findAnimation(animationName);
        if (null == animation) throw new Error("Animation not found: " + animationName);
        return this.addAnimationWith(trackIndex, animation, loop, delay);
      }, AnimationState2.prototype.addAnimationWith = function(trackIndex, animation, loop, delay) {
        if (null == animation) throw new Error("animation cannot be null.");
        var last = this.expandToIndex(trackIndex);
        if (null != last) for (; null != last.next; ) last = last.next;
        var entry = this.trackEntry(trackIndex, animation, loop, last);
        if (null == last) this.setCurrent(trackIndex, entry, true), this.queue.drain();
        else if (last.next = entry, delay <= 0) {
          var duration = last.animationEnd - last.animationStart;
          0 != duration ? (last.loop ? delay += duration * (1 + (last.trackTime / duration | 0)) : delay += Math.max(duration, last.trackTime), delay -= this.data.getMix(last.animation, animation)) : delay = last.trackTime;
        }
        return entry.delay = delay, entry;
      }, AnimationState2.prototype.setEmptyAnimation = function(trackIndex, mixDuration) {
        var entry = this.setAnimationWith(trackIndex, AnimationState2.emptyAnimation, false);
        return entry.mixDuration = mixDuration, entry.trackEnd = mixDuration, entry;
      }, AnimationState2.prototype.addEmptyAnimation = function(trackIndex, mixDuration, delay) {
        delay <= 0 && (delay -= mixDuration);
        var entry = this.addAnimationWith(trackIndex, AnimationState2.emptyAnimation, false, delay);
        return entry.mixDuration = mixDuration, entry.trackEnd = mixDuration, entry;
      }, AnimationState2.prototype.setEmptyAnimations = function(mixDuration) {
        var oldDrainDisabled = this.queue.drainDisabled;
        this.queue.drainDisabled = true;
        for (var i = 0, n = this.tracks.length; i < n; i++) {
          var current = this.tracks[i];
          null != current && this.setEmptyAnimation(current.trackIndex, mixDuration);
        }
        this.queue.drainDisabled = oldDrainDisabled, this.queue.drain();
      }, AnimationState2.prototype.expandToIndex = function(index) {
        return index < this.tracks.length ? this.tracks[index] : (spine4.Utils.ensureArrayCapacity(this.tracks, index + 1, null), this.tracks.length = index + 1, null);
      }, AnimationState2.prototype.trackEntry = function(trackIndex, animation, loop, last) {
        var entry = this.trackEntryPool.obtain();
        return entry.trackIndex = trackIndex, entry.animation = animation, entry.loop = loop, entry.holdPrevious = false, entry.eventThreshold = 0, entry.attachmentThreshold = 0, entry.drawOrderThreshold = 0, entry.animationStart = 0, entry.animationEnd = animation.duration, entry.animationLast = -1, entry.nextAnimationLast = -1, entry.delay = 0, entry.trackTime = 0, entry.trackLast = -1, entry.nextTrackLast = -1, entry.trackEnd = Number.MAX_VALUE, entry.timeScale = 1, entry.alpha = 1, entry.interruptAlpha = 1, entry.mixTime = 0, entry.mixDuration = null == last ? 0 : this.data.getMix(last.animation, animation), entry.mixBlend = spine4.MixBlend.replace, entry;
      }, AnimationState2.prototype.disposeNext = function(entry) {
        for (var next = entry.next; null != next; ) this.queue.dispose(next), next = next.next;
        entry.next = null;
      }, AnimationState2.prototype._animationsChanged = function() {
        this.animationsChanged = false, this.propertyIDs.clear();
        for (var i = 0, n = this.tracks.length; i < n; i++) {
          var entry = this.tracks[i];
          if (null != entry) {
            for (; null != entry.mixingFrom; ) entry = entry.mixingFrom;
            do {
              null != entry.mixingFrom && entry.mixBlend == spine4.MixBlend.add || this.computeHold(entry), entry = entry.mixingTo;
            } while (null != entry);
          }
        }
      }, AnimationState2.prototype.computeHold = function(entry) {
        var to = entry.mixingTo, timelines = entry.animation.timelines, timelinesCount = entry.animation.timelines.length, timelineMode = spine4.Utils.setArraySize(entry.timelineMode, timelinesCount);
        entry.timelineHoldMix.length = 0;
        var timelineDipMix = spine4.Utils.setArraySize(entry.timelineHoldMix, timelinesCount), propertyIDs = this.propertyIDs;
        if (null != to && to.holdPrevious) for (var i = 0; i < timelinesCount; i++) timelineMode[i] = propertyIDs.add(timelines[i].getPropertyId()) ? AnimationState2.HOLD_FIRST : AnimationState2.HOLD_SUBSEQUENT;
        else outer: for (var i = 0; i < timelinesCount; i++) {
          var timeline = timelines[i], id = timeline.getPropertyId();
          if (propertyIDs.add(id)) if (null == to || timeline instanceof spine4.AttachmentTimeline || timeline instanceof spine4.DrawOrderTimeline || timeline instanceof spine4.EventTimeline || !to.animation.hasTimeline(id)) timelineMode[i] = AnimationState2.FIRST;
          else {
            for (var next = to.mixingTo; null != next; next = next.mixingTo) if (!next.animation.hasTimeline(id)) {
              if (entry.mixDuration > 0) {
                timelineMode[i] = AnimationState2.HOLD_MIX, timelineDipMix[i] = next;
                continue outer;
              }
              break;
            }
            timelineMode[i] = AnimationState2.HOLD_FIRST;
          }
          else timelineMode[i] = AnimationState2.SUBSEQUENT;
        }
      }, AnimationState2.prototype.getCurrent = function(trackIndex) {
        return trackIndex >= this.tracks.length ? null : this.tracks[trackIndex];
      }, AnimationState2.prototype.addListener = function(listener) {
        if (null == listener) throw new Error("listener cannot be null.");
        this.listeners.push(listener);
      }, AnimationState2.prototype.removeListener = function(listener) {
        var index = this.listeners.indexOf(listener);
        index >= 0 && this.listeners.splice(index, 1);
      }, AnimationState2.prototype.clearListeners = function() {
        this.listeners.length = 0;
      }, AnimationState2.prototype.clearListenerNotifications = function() {
        this.queue.clear();
      }, AnimationState2.emptyAnimation = new spine4.Animation("<empty>", [], 0), AnimationState2.SUBSEQUENT = 0, AnimationState2.FIRST = 1, AnimationState2.HOLD_SUBSEQUENT = 2, AnimationState2.HOLD_FIRST = 3, AnimationState2.HOLD_MIX = 4, AnimationState2.SETUP = 1, AnimationState2.CURRENT = 2, AnimationState2;
    })();
    spine4.AnimationState = AnimationState;
    var TrackEntry = (function() {
      function TrackEntry2() {
        this.mixBlend = spine4.MixBlend.replace, this.timelineMode = new Array(), this.timelineHoldMix = new Array(), this.timelinesRotation = new Array();
      }
      return TrackEntry2.prototype.reset = function() {
        this.next = null, this.mixingFrom = null, this.mixingTo = null, this.animation = null, this.listener = null, this.timelineMode.length = 0, this.timelineHoldMix.length = 0, this.timelinesRotation.length = 0;
      }, TrackEntry2.prototype.getAnimationTime = function() {
        if (this.loop) {
          var duration = this.animationEnd - this.animationStart;
          return 0 == duration ? this.animationStart : this.trackTime % duration + this.animationStart;
        }
        return Math.min(this.trackTime + this.animationStart, this.animationEnd);
      }, TrackEntry2.prototype.setAnimationLast = function(animationLast) {
        this.animationLast = animationLast, this.nextAnimationLast = animationLast;
      }, TrackEntry2.prototype.isComplete = function() {
        return this.trackTime >= this.animationEnd - this.animationStart;
      }, TrackEntry2.prototype.resetRotationDirections = function() {
        this.timelinesRotation.length = 0;
      }, TrackEntry2;
    })();
    spine4.TrackEntry = TrackEntry;
    var EventQueue = (function() {
      function EventQueue2(animState) {
        this.objects = [], this.drainDisabled = false, this.animState = animState;
      }
      return EventQueue2.prototype.start = function(entry) {
        this.objects.push(EventType.start), this.objects.push(entry), this.animState.animationsChanged = true;
      }, EventQueue2.prototype.interrupt = function(entry) {
        this.objects.push(EventType.interrupt), this.objects.push(entry);
      }, EventQueue2.prototype.end = function(entry) {
        this.objects.push(EventType.end), this.objects.push(entry), this.animState.animationsChanged = true;
      }, EventQueue2.prototype.dispose = function(entry) {
        this.objects.push(EventType.dispose), this.objects.push(entry);
      }, EventQueue2.prototype.complete = function(entry) {
        this.objects.push(EventType.complete), this.objects.push(entry);
      }, EventQueue2.prototype.event = function(entry, event) {
        this.objects.push(EventType.event), this.objects.push(entry), this.objects.push(event);
      }, EventQueue2.prototype.drain = function() {
        if (!this.drainDisabled) {
          this.drainDisabled = true;
          for (var objects = this.objects, listeners = this.animState.listeners, i = 0; i < objects.length; i += 2) {
            var type = objects[i], entry = objects[i + 1];
            switch (type) {
              case EventType.start:
                null != entry.listener && entry.listener.start && entry.listener.start(entry);
                for (var ii = 0; ii < listeners.length; ii++) listeners[ii].start && listeners[ii].start(entry);
                break;
              case EventType.interrupt:
                null != entry.listener && entry.listener.interrupt && entry.listener.interrupt(entry);
                for (var ii = 0; ii < listeners.length; ii++) listeners[ii].interrupt && listeners[ii].interrupt(entry);
                break;
              case EventType.end:
                null != entry.listener && entry.listener.end && entry.listener.end(entry);
                for (var ii = 0; ii < listeners.length; ii++) listeners[ii].end && listeners[ii].end(entry);
              case EventType.dispose:
                null != entry.listener && entry.listener.dispose && entry.listener.dispose(entry);
                for (var ii = 0; ii < listeners.length; ii++) listeners[ii].dispose && listeners[ii].dispose(entry);
                this.animState.trackEntryPool.free(entry);
                break;
              case EventType.complete:
                null != entry.listener && entry.listener.complete && entry.listener.complete(entry);
                for (var ii = 0; ii < listeners.length; ii++) listeners[ii].complete && listeners[ii].complete(entry);
                break;
              case EventType.event:
                var event_3 = objects[2 + i++];
                null != entry.listener && entry.listener.event && entry.listener.event(entry, event_3);
                for (var ii = 0; ii < listeners.length; ii++) listeners[ii].event && listeners[ii].event(entry, event_3);
            }
          }
          this.clear(), this.drainDisabled = false;
        }
      }, EventQueue2.prototype.clear = function() {
        this.objects.length = 0;
      }, EventQueue2;
    })(), EventType;
    spine4.EventQueue = EventQueue, (function(EventType2) {
      EventType2[EventType2.start = 0] = "start", EventType2[EventType2.interrupt = 1] = "interrupt", EventType2[EventType2.end = 2] = "end", EventType2[EventType2.dispose = 3] = "dispose", EventType2[EventType2.complete = 4] = "complete", EventType2[EventType2.event = 5] = "event";
    })(EventType = spine4.EventType || (spine4.EventType = {}));
    var AnimationStateAdapter = (function() {
      function AnimationStateAdapter2() {
      }
      return AnimationStateAdapter2.prototype.start = function(entry) {
      }, AnimationStateAdapter2.prototype.interrupt = function(entry) {
      }, AnimationStateAdapter2.prototype.end = function(entry) {
      }, AnimationStateAdapter2.prototype.dispose = function(entry) {
      }, AnimationStateAdapter2.prototype.complete = function(entry) {
      }, AnimationStateAdapter2.prototype.event = function(entry, event) {
      }, AnimationStateAdapter2;
    })();
    spine4.AnimationStateAdapter = AnimationStateAdapter;
  })(spine || (spine = {})), (function(spine4) {
    var AnimationStateData = (function() {
      function AnimationStateData2(skeletonData2) {
        if (this.animationToMixTime = {}, this.defaultMix = 0, null == skeletonData2) throw new Error("skeletonData cannot be null.");
        this.skeletonData = SkeletonData;
      }
      return AnimationStateData2.prototype.setMix = function(fromName, toName, duration) {
        var from = this.skeletonData.findAnimation(fromName);
        if (null == from) throw new Error("Animation not found: " + fromName);
        var to = this.skeletonData.findAnimation(toName);
        if (null == to) throw new Error("Animation not found: " + toName);
        this.setMixWith(from, to, duration);
      }, AnimationStateData2.prototype.setMixWith = function(from, to, duration) {
        if (null == from) throw new Error("from cannot be null.");
        if (null == to) throw new Error("to cannot be null.");
        var key = from.name + "." + to.name;
        this.animationToMixTime[key] = duration;
      }, AnimationStateData2.prototype.getMix = function(from, to) {
        var key = from.name + "." + to.name, value = this.animationToMixTime[key];
        return void 0 === value ? this.defaultMix : value;
      }, AnimationStateData2;
    })();
    spine4.AnimationStateData = AnimationStateData;
  })(spine || (spine = {})), (function(spine4) {
    var AssetManager = (function() {
      function AssetManager2(textureLoader, pathPrefix) {
        void 0 === pathPrefix && (pathPrefix = ""), this.assets = {}, this.errors = {}, this.toLoad = 0, this.loaded = 0, this.rawDataUris = {}, this.textureLoader = textureLoader, this.pathPrefix = pathPrefix;
      }
      return AssetManager2.prototype.downloadText = function(url, success, error) {
        var request = new XMLHttpRequest();
        request.overrideMimeType("text/html"), this.rawDataUris[url] && (url = this.rawDataUris[url]), request.open("GET", url, true), request.onload = function() {
          200 == request.status ? success(request.responseText) : error(request.status, request.responseText);
        }, request.onerror = function() {
          error(request.status, request.responseText);
        }, request.send();
      }, AssetManager2.prototype.downloadBinary = function(url, success, error) {
        var request = new XMLHttpRequest();
        this.rawDataUris[url] && (url = this.rawDataUris[url]), request.open("GET", url, true), request.responseType = "arraybuffer", request.onload = function() {
          200 == request.status ? success(new Uint8Array(request.response)) : error(request.status, request.responseText);
        }, request.onerror = function() {
          error(request.status, request.responseText);
        }, request.send();
      }, AssetManager2.prototype.setRawDataURI = function(path, data) {
        this.rawDataUris[this.pathPrefix + path] = data;
      }, AssetManager2.prototype.loadBinary = function(path, success, error) {
        var _this = this;
        void 0 === success && (success = null), void 0 === error && (error = null), path = this.pathPrefix + path, this.toLoad++, this.downloadBinary(path, (function(data) {
          _this.assets[path] = data, success && success(path, data), _this.toLoad--, _this.loaded++;
        }), (function(state, responseText) {
          _this.errors[path] = "Couldn't load binary " + path + ": status " + status + ", " + responseText, error && error(path, "Couldn't load binary " + path + ": status " + status + ", " + responseText), _this.toLoad--, _this.loaded++;
        }));
      }, AssetManager2.prototype.loadText = function(path, success, error) {
        var _this = this;
        void 0 === success && (success = null), void 0 === error && (error = null), path = this.pathPrefix + path, this.toLoad++, this.downloadText(path, (function(data) {
          _this.assets[path] = data, success && success(path, data), _this.toLoad--, _this.loaded++;
        }), (function(state, responseText) {
          _this.errors[path] = "Couldn't load text " + path + ": status " + status + ", " + responseText, error && error(path, "Couldn't load text " + path + ": status " + status + ", " + responseText), _this.toLoad--, _this.loaded++;
        }));
      }, AssetManager2.prototype.loadTexture = function(path, success, error) {
        var _this = this;
        void 0 === success && (success = null), void 0 === error && (error = null);
        var storagePath = path = this.pathPrefix + path;
        this.toLoad++;
        var img = new Image();
        img.crossOrigin = "anonymous", img.onload = function(ev) {
          var texture = _this.textureLoader(img);
          _this.assets[storagePath] = texture, _this.toLoad--, _this.loaded++, success && success(path, img);
        }, img.onerror = function(ev) {
          _this.errors[path] = "Couldn't load image " + path, _this.toLoad--, _this.loaded++, error && error(path, "Couldn't load image " + path);
        }, this.rawDataUris[path] && (path = this.rawDataUris[path]), img.src = path;
      }, AssetManager2.prototype.loadTextureAtlas = function(path, success, error) {
        var _this = this;
        void 0 === success && (success = null), void 0 === error && (error = null);
        var parent = path.lastIndexOf("/") >= 0 ? path.substring(0, path.lastIndexOf("/")) : "";
        path = this.pathPrefix + path, this.toLoad++, this.downloadText(path, (function(atlasData) {
          var pagesLoaded = { count: 0 }, atlasPages = new Array();
          try {
            var atlas = new spine4.TextureAtlas(atlasData, (function(path2) {
              atlasPages.push("" == parent ? path2 : parent + "/" + path2);
              var image = document.createElement("img");
              return image.width = 16, image.height = 16, new spine4.FakeTexture(image);
            }));
          } catch (e) {
            var ex = e;
            return _this.errors[path] = "Couldn't load texture atlas " + path + ": " + ex.message, error && error(path, "Couldn't load texture atlas " + path + ": " + ex.message), _this.toLoad--, void _this.loaded++;
          }
          for (var _loop_1 = function(atlasPage2) {
            var pageLoadError = false;
            _this.loadTexture(atlasPage2, (function(imagePath, image) {
              if (pagesLoaded.count++, pagesLoaded.count == atlasPages.length) if (pageLoadError) _this.errors[path] = "Couldn't load texture atlas page " + imagePath + "} of atlas " + path, error && error(path, "Couldn't load texture atlas page " + imagePath + " of atlas " + path), _this.toLoad--, _this.loaded++;
              else try {
                var atlas2 = new spine4.TextureAtlas(atlasData, (function(path2) {
                  return _this.get("" == parent ? path2 : parent + "/" + path2);
                }));
                _this.assets[path] = atlas2, success && success(path, atlas2), _this.toLoad--, _this.loaded++;
              } catch (e) {
                var ex2 = e;
                _this.errors[path] = "Couldn't load texture atlas " + path + ": " + ex2.message, error && error(path, "Couldn't load texture atlas " + path + ": " + ex2.message), _this.toLoad--, _this.loaded++;
              }
            }), (function(imagePath, errorMessage) {
              pageLoadError = true, pagesLoaded.count++, pagesLoaded.count == atlasPages.length && (_this.errors[path] = "Couldn't load texture atlas page " + imagePath + "} of atlas " + path, error && error(path, "Couldn't load texture atlas page " + imagePath + " of atlas " + path), _this.toLoad--, _this.loaded++);
            }));
          }, _i = 0, atlasPages_1 = atlasPages; _i < atlasPages_1.length; _i++) {
            _loop_1(atlasPages_1[_i]);
          }
        }), (function(state, responseText) {
          _this.errors[path] = "Couldn't load texture atlas " + path + ": status " + status + ", " + responseText, error && error(path, "Couldn't load texture atlas " + path + ": status " + status + ", " + responseText), _this.toLoad--, _this.loaded++;
        }));
      }, AssetManager2.prototype.get = function(path) {
        return path = this.pathPrefix + path, this.assets[path];
      }, AssetManager2.prototype.remove = function(path) {
        path = this.pathPrefix + path;
        var asset = this.assets[path];
        asset.dispose && asset.dispose(), this.assets[path] = null;
      }, AssetManager2.prototype.removeAll = function() {
        for (var key in this.assets) {
          var asset = this.assets[key];
          asset.dispose && asset.dispose();
        }
        this.assets = {};
      }, AssetManager2.prototype.isLoadingComplete = function() {
        return 0 == this.toLoad;
      }, AssetManager2.prototype.getToLoad = function() {
        return this.toLoad;
      }, AssetManager2.prototype.getLoaded = function() {
        return this.loaded;
      }, AssetManager2.prototype.dispose = function() {
        this.removeAll();
      }, AssetManager2.prototype.hasErrors = function() {
        return Object.keys(this.errors).length > 0;
      }, AssetManager2.prototype.getErrors = function() {
        return this.errors;
      }, AssetManager2;
    })();
    spine4.AssetManager = AssetManager;
  })(spine || (spine = {})), (function(spine4) {
    var AtlasAttachmentLoader = (function() {
      function AtlasAttachmentLoader2(atlas) {
        this.atlas = atlas;
      }
      return AtlasAttachmentLoader2.prototype.newRegionAttachment = function(skin, name, path) {
        var region = this.atlas.findRegion(path);
        if (null == region) throw new Error("Region not found in atlas: " + path + " (region attachment: " + name + ")");
        region.renderObject = region;
        var attachment = new spine4.RegionAttachment(name);
        return attachment.setRegion(region), attachment;
      }, AtlasAttachmentLoader2.prototype.newMeshAttachment = function(skin, name, path) {
        var region = this.atlas.findRegion(path);
        if (null == region) throw new Error("Region not found in atlas: " + path + " (mesh attachment: " + name + ")");
        region.renderObject = region;
        var attachment = new spine4.MeshAttachment(name);
        return attachment.region = region, attachment;
      }, AtlasAttachmentLoader2.prototype.newBoundingBoxAttachment = function(skin, name) {
        return new spine4.BoundingBoxAttachment(name);
      }, AtlasAttachmentLoader2.prototype.newPathAttachment = function(skin, name) {
        return new spine4.PathAttachment(name);
      }, AtlasAttachmentLoader2.prototype.newPointAttachment = function(skin, name) {
        return new spine4.PointAttachment(name);
      }, AtlasAttachmentLoader2.prototype.newClippingAttachment = function(skin, name) {
        return new spine4.ClippingAttachment(name);
      }, AtlasAttachmentLoader2;
    })();
    spine4.AtlasAttachmentLoader = AtlasAttachmentLoader;
  })(spine || (spine = {})), (function(spine4) {
    !(function(BlendMode2) {
      BlendMode2[BlendMode2.Normal = 0] = "Normal", BlendMode2[BlendMode2.Additive = 1] = "Additive", BlendMode2[BlendMode2.Multiply = 2] = "Multiply", BlendMode2[BlendMode2.Screen = 3] = "Screen";
    })(spine4.BlendMode || (spine4.BlendMode = {}));
  })(spine || (spine = {})), (function(spine4) {
    var Bone = (function() {
      function Bone2(data, Skeleton2, parent) {
        if (this.children = new Array(), this.x = 0, this.y = 0, this.rotation = 0, this.scaleX = 0, this.scaleY = 0, this.shearX = 0, this.shearY = 0, this.ax = 0, this.ay = 0, this.arotation = 0, this.ascaleX = 0, this.ascaleY = 0, this.ashearX = 0, this.ashearY = 0, this.appliedValid = false, this.a = 0, this.b = 0, this.c = 0, this.d = 0, this.worldY = 0, this.worldX = 0, this.sorted = false, this.active = false, null == data) throw new Error("data cannot be null.");
        if (null == skeleton) throw new Error("skeleton cannot be null.");
        this.data = data, this.skeleton = Skeleton2, this.parent = parent, this.setToSetupPose();
      }
      return Bone2.prototype.isActive = function() {
        return this.active;
      }, Bone2.prototype.update = function() {
        this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
      }, Bone2.prototype.updateWorldTransform = function() {
        this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
      }, Bone2.prototype.updateWorldTransformWith = function(x, y, rotation, scaleX, scaleY, shearX, shearY) {
        this.ax = x, this.ay = y, this.arotation = rotation, this.ascaleX = scaleX, this.ascaleY = scaleY, this.ashearX = shearX, this.ashearY = shearY, this.appliedValid = true;
        var parent = this.parent;
        if (null == parent) {
          var Skeleton2 = this.skeleton, rotationY = rotation + 90 + shearY, sx = Skeleton2.scaleX, sy = Skeleton2.scaleY;
          return this.a = spine4.MathUtils.cosDeg(rotation + shearX) * scaleX * sx, this.b = spine4.MathUtils.cosDeg(rotationY) * scaleY * sx, this.c = spine4.MathUtils.sinDeg(rotation + shearX) * scaleX * sy, this.d = spine4.MathUtils.sinDeg(rotationY) * scaleY * sy, this.worldX = x * sx + Skeleton2.x, void (this.worldY = y * sy + Skeleton2.y);
        }
        var pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;
        switch (this.worldX = pa * x + pb * y + parent.worldX, this.worldY = pc * x + pd * y + parent.worldY, this.data.transformMode) {
          case spine4.TransformMode.Normal:
            var rotationY = rotation + 90 + shearY, la = spine4.MathUtils.cosDeg(rotation + shearX) * scaleX, lb = spine4.MathUtils.cosDeg(rotationY) * scaleY, lc = spine4.MathUtils.sinDeg(rotation + shearX) * scaleX, ld = spine4.MathUtils.sinDeg(rotationY) * scaleY;
            return this.a = pa * la + pb * lc, this.b = pa * lb + pb * ld, this.c = pc * la + pd * lc, void (this.d = pc * lb + pd * ld);
          case spine4.TransformMode.OnlyTranslation:
            var rotationY = rotation + 90 + shearY;
            this.a = spine4.MathUtils.cosDeg(rotation + shearX) * scaleX, this.b = spine4.MathUtils.cosDeg(rotationY) * scaleY, this.c = spine4.MathUtils.sinDeg(rotation + shearX) * scaleX, this.d = spine4.MathUtils.sinDeg(rotationY) * scaleY;
            break;
          case spine4.TransformMode.NoRotationOrReflection:
            var s, prx = 0;
            (s = pa * pa + pc * pc) > 1e-4 ? (s = Math.abs(pa * pd - pb * pc) / s, pa /= this.skeleton.scaleX, pb = (pc /= this.skeleton.scaleY) * s, pd = pa * s, prx = Math.atan2(pc, pa) * spine4.MathUtils.radDeg) : (pa = 0, pc = 0, prx = 90 - Math.atan2(pd, pb) * spine4.MathUtils.radDeg);
            var rx = rotation + shearX - prx, ry = rotation + shearY - prx + 90, la = spine4.MathUtils.cosDeg(rx) * scaleX, lb = spine4.MathUtils.cosDeg(ry) * scaleY, lc = spine4.MathUtils.sinDeg(rx) * scaleX, ld = spine4.MathUtils.sinDeg(ry) * scaleY;
            this.a = pa * la - pb * lc, this.b = pa * lb - pb * ld, this.c = pc * la + pd * lc, this.d = pc * lb + pd * ld;
            break;
          case spine4.TransformMode.NoScale:
          case spine4.TransformMode.NoScaleOrReflection:
            var cos = spine4.MathUtils.cosDeg(rotation), sin = spine4.MathUtils.sinDeg(rotation), za = (pa * cos + pb * sin) / this.skeleton.scaleX, zc = (pc * cos + pd * sin) / this.skeleton.scaleY, s;
            (s = Math.sqrt(za * za + zc * zc)) > 1e-5 && (s = 1 / s), za *= s, zc *= s, s = Math.sqrt(za * za + zc * zc), this.data.transformMode == spine4.TransformMode.NoScale && pa * pd - pb * pc < 0 != (this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0) && (s = -s);
            var r = Math.PI / 2 + Math.atan2(zc, za), zb = Math.cos(r) * s, zd = Math.sin(r) * s, la = spine4.MathUtils.cosDeg(shearX) * scaleX, lb = spine4.MathUtils.cosDeg(90 + shearY) * scaleY, lc = spine4.MathUtils.sinDeg(shearX) * scaleX, ld = spine4.MathUtils.sinDeg(90 + shearY) * scaleY;
            this.a = za * la + zb * lc, this.b = za * lb + zb * ld, this.c = zc * la + zd * lc, this.d = zc * lb + zd * ld;
        }
        this.a *= this.skeleton.scaleX, this.b *= this.skeleton.scaleX, this.c *= this.skeleton.scaleY, this.d *= this.skeleton.scaleY;
      }, Bone2.prototype.setToSetupPose = function() {
        var data = this.data;
        this.x = data.x, this.y = data.y, this.rotation = data.rotation, this.scaleX = data.scaleX, this.scaleY = data.scaleY, this.shearX = data.shearX, this.shearY = data.shearY;
      }, Bone2.prototype.getWorldRotationX = function() {
        return Math.atan2(this.c, this.a) * spine4.MathUtils.radDeg;
      }, Bone2.prototype.getWorldRotationY = function() {
        return Math.atan2(this.d, this.b) * spine4.MathUtils.radDeg;
      }, Bone2.prototype.getWorldScaleX = function() {
        return Math.sqrt(this.a * this.a + this.c * this.c);
      }, Bone2.prototype.getWorldScaleY = function() {
        return Math.sqrt(this.b * this.b + this.d * this.d);
      }, Bone2.prototype.updateAppliedTransform = function() {
        this.appliedValid = true;
        var parent = this.parent;
        if (null == parent) return this.ax = this.worldX, this.ay = this.worldY, this.arotation = Math.atan2(this.c, this.a) * spine4.MathUtils.radDeg, this.ascaleX = Math.sqrt(this.a * this.a + this.c * this.c), this.ascaleY = Math.sqrt(this.b * this.b + this.d * this.d), this.ashearX = 0, void (this.ashearY = Math.atan2(this.a * this.b + this.c * this.d, this.a * this.d - this.b * this.c) * spine4.MathUtils.radDeg);
        var pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d, pid = 1 / (pa * pd - pb * pc), dx = this.worldX - parent.worldX, dy = this.worldY - parent.worldY;
        this.ax = dx * pd * pid - dy * pb * pid, this.ay = dy * pa * pid - dx * pc * pid;
        var ia = pid * pd, id = pid * pa, ib = pid * pb, ic = pid * pc, ra = ia * this.a - ib * this.c, rb = ia * this.b - ib * this.d, rc = id * this.c - ic * this.a, rd = id * this.d - ic * this.b;
        if (this.ashearX = 0, this.ascaleX = Math.sqrt(ra * ra + rc * rc), this.ascaleX > 1e-4) {
          var det = ra * rd - rb * rc;
          this.ascaleY = det / this.ascaleX, this.ashearY = Math.atan2(ra * rb + rc * rd, det) * spine4.MathUtils.radDeg, this.arotation = Math.atan2(rc, ra) * spine4.MathUtils.radDeg;
        } else this.ascaleX = 0, this.ascaleY = Math.sqrt(rb * rb + rd * rd), this.ashearY = 0, this.arotation = 90 - Math.atan2(rd, rb) * spine4.MathUtils.radDeg;
      }, Bone2.prototype.worldToLocal = function(world) {
        var a = this.a, b = this.b, c = this.c, d = this.d, invDet = 1 / (a * d - b * c), x = world.x - this.worldX, y = world.y - this.worldY;
        return world.x = x * d * invDet - y * b * invDet, world.y = y * a * invDet - x * c * invDet, world;
      }, Bone2.prototype.localToWorld = function(local) {
        var x = local.x, y = local.y;
        return local.x = x * this.a + y * this.b + this.worldX, local.y = x * this.c + y * this.d + this.worldY, local;
      }, Bone2.prototype.worldToLocalRotation = function(worldRotation) {
        var sin = spine4.MathUtils.sinDeg(worldRotation), cos = spine4.MathUtils.cosDeg(worldRotation);
        return Math.atan2(this.a * sin - this.c * cos, this.d * cos - this.b * sin) * spine4.MathUtils.radDeg + this.rotation - this.shearX;
      }, Bone2.prototype.localToWorldRotation = function(localRotation) {
        localRotation -= this.rotation - this.shearX;
        var sin = spine4.MathUtils.sinDeg(localRotation), cos = spine4.MathUtils.cosDeg(localRotation);
        return Math.atan2(cos * this.c + sin * this.d, cos * this.a + sin * this.b) * spine4.MathUtils.radDeg;
      }, Bone2.prototype.rotateWorld = function(degrees) {
        var a = this.a, b = this.b, c = this.c, d = this.d, cos = spine4.MathUtils.cosDeg(degrees), sin = spine4.MathUtils.sinDeg(degrees);
        this.a = cos * a - sin * c, this.b = cos * b - sin * d, this.c = sin * a + cos * c, this.d = sin * b + cos * d, this.appliedValid = false;
      }, Bone2;
    })();
    spine4.Bone = Bone;
  })(spine || (spine = {})), (function(spine4) {
    var BoneData = /* @__PURE__ */ (function() {
      function BoneData2(index, name, parent) {
        if (this.x = 0, this.y = 0, this.rotation = 0, this.scaleX = 1, this.scaleY = 1, this.shearX = 0, this.shearY = 0, this.transformMode = TransformMode.Normal, this.skinRequired = false, this.color = new spine4.Color(), index < 0) throw new Error("index must be >= 0.");
        if (null == name) throw new Error("name cannot be null.");
        this.index = index, this.name = name, this.parent = parent;
      }
      return BoneData2;
    })(), TransformMode;
    spine4.BoneData = BoneData, (function(TransformMode2) {
      TransformMode2[TransformMode2.Normal = 0] = "Normal", TransformMode2[TransformMode2.OnlyTranslation = 1] = "OnlyTranslation", TransformMode2[TransformMode2.NoRotationOrReflection = 2] = "NoRotationOrReflection", TransformMode2[TransformMode2.NoScale = 3] = "NoScale", TransformMode2[TransformMode2.NoScaleOrReflection = 4] = "NoScaleOrReflection";
    })(TransformMode = spine4.TransformMode || (spine4.TransformMode = {}));
  })(spine || (spine = {})), (function(spine4) {
    var ConstraintData = /* @__PURE__ */ (function() {
      function ConstraintData2(name, order, skinRequired) {
        this.name = name, this.order = order, this.skinRequired = skinRequired;
      }
      return ConstraintData2;
    })();
    spine4.ConstraintData = ConstraintData;
  })(spine || (spine = {})), (function(spine4) {
    var Event = /* @__PURE__ */ (function() {
      function Event2(time, data) {
        if (null == data) throw new Error("data cannot be null.");
        this.time = time, this.data = data;
      }
      return Event2;
    })();
    spine4.Event = Event;
  })(spine || (spine = {})), (function(spine4) {
    var EventData = /* @__PURE__ */ (function() {
      function EventData2(name) {
        this.name = name;
      }
      return EventData2;
    })();
    spine4.EventData = EventData;
  })(spine || (spine = {})), (function(spine4) {
    var IkConstraint = (function() {
      function IkConstraint2(data, Skeleton2) {
        if (this.bendDirection = 0, this.compress = false, this.stretch = false, this.mix = 1, this.softness = 0, this.active = false, null == data) throw new Error("data cannot be null.");
        if (null == skeleton) throw new Error("skeleton cannot be null.");
        this.data = data, this.mix = data.mix, this.softness = data.softness, this.bendDirection = data.bendDirection, this.compress = data.compress, this.stretch = data.stretch, this.bones = new Array();
        for (var i = 0; i < data.bones.length; i++) this.bones.push(skeleton.findBone(data.bones[i].name));
        this.target = Skeleton2.findBone(data.target.name);
      }
      return IkConstraint2.prototype.isActive = function() {
        return this.active;
      }, IkConstraint2.prototype.apply = function() {
        this.update();
      }, IkConstraint2.prototype.update = function() {
        var target = this.target, bones = this.bones;
        switch (bones.length) {
          case 1:
            this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);
            break;
          case 2:
            this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.softness, this.mix);
        }
      }, IkConstraint2.prototype.apply1 = function(bone, targetX, targetY, compress, stretch, uniform, alpha) {
        bone.appliedValid || bone.updateAppliedTransform();
        var p = bone.parent, pa = p.a, pb = p.b, pc = p.c, pd = p.d, rotationIK = -bone.ashearX - bone.arotation, tx = 0, ty = 0;
        switch (bone.data.transformMode) {
          case spine4.TransformMode.OnlyTranslation:
            tx = targetX - bone.worldX, ty = targetY - bone.worldY;
            break;
          case spine4.TransformMode.NoRotationOrReflection:
            var s = Math.abs(pa * pd - pb * pc) / (pa * pa + pc * pc), sa = pa / bone.skeleton.scaleX, sc = pc / bone.skeleton.scaleY;
            pb = -sc * s * bone.skeleton.scaleX, pd = sa * s * bone.skeleton.scaleY, rotationIK += Math.atan2(sc, sa) * spine4.MathUtils.radDeg;
          default:
            var x = targetX - p.worldX, y = targetY - p.worldY, d = pa * pd - pb * pc;
            tx = (x * pd - y * pb) / d - bone.ax, ty = (y * pa - x * pc) / d - bone.ay;
        }
        rotationIK += Math.atan2(ty, tx) * spine4.MathUtils.radDeg, bone.ascaleX < 0 && (rotationIK += 180), rotationIK > 180 ? rotationIK -= 360 : rotationIK < -180 && (rotationIK += 360);
        var sx = bone.ascaleX, sy = bone.ascaleY;
        if (compress || stretch) {
          switch (bone.data.transformMode) {
            case spine4.TransformMode.NoScale:
            case spine4.TransformMode.NoScaleOrReflection:
              tx = targetX - bone.worldX, ty = targetY - bone.worldY;
          }
          var b = bone.data.length * sx, dd = Math.sqrt(tx * tx + ty * ty), s;
          if (compress && dd < b || stretch && dd > b && b > 1e-4) sx *= s = (dd / b - 1) * alpha + 1, uniform && (sy *= s);
        }
        bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);
      }, IkConstraint2.prototype.apply2 = function(parent, child, targetX, targetY, bendDir, stretch, softness, alpha) {
        if (0 != alpha) {
          parent.appliedValid || parent.updateAppliedTransform(), child.appliedValid || child.updateAppliedTransform();
          var px = parent.ax, py = parent.ay, psx = parent.ascaleX, sx = psx, psy = parent.ascaleY, csx = child.ascaleX, os1 = 0, os2 = 0, s2 = 0;
          psx < 0 ? (psx = -psx, os1 = 180, s2 = -1) : (os1 = 0, s2 = 1), psy < 0 && (psy = -psy, s2 = -s2), csx < 0 ? (csx = -csx, os2 = 180) : os2 = 0;
          var cx = child.ax, cy = 0, cwx = 0, cwy = 0, a = parent.a, b = parent.b, c = parent.c, d = parent.d, u = Math.abs(psx - psy) <= 1e-4;
          u ? (cwx = a * cx + b * (cy = child.ay) + parent.worldX, cwy = c * cx + d * cy + parent.worldY) : (cy = 0, cwx = a * cx + parent.worldX, cwy = c * cx + parent.worldY);
          var pp = parent.parent;
          a = pp.a, b = pp.b, c = pp.c;
          var id = 1 / (a * (d = pp.d) - b * c), x = cwx - pp.worldX, y = cwy - pp.worldY, dx = (x * d - y * b) * id - px, dy = (y * a - x * c) * id - py, l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1, a2;
          if (l1 < 1e-4) return this.apply1(parent, targetX, targetY, false, stretch, false, alpha), void child.updateWorldTransformWith(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
          var tx = ((x = targetX - pp.worldX) * d - (y = targetY - pp.worldY) * b) * id - px, ty = (y * a - x * c) * id - py, dd = tx * tx + ty * ty;
          if (0 != softness) {
            softness *= psx * (csx + 1) / 2;
            var td = Math.sqrt(dd), sd = td - l1 - l2 * psx + softness;
            if (sd > 0) {
              var p = Math.min(1, sd / (2 * softness)) - 1;
              dd = (tx -= (p = (sd - softness * (1 - p * p)) / td) * tx) * tx + (ty -= p * ty) * ty;
            }
          }
          outer: if (u) {
            var cos = (dd - l1 * l1 - (l2 *= psx) * l2) / (2 * l1 * l2);
            cos < -1 ? cos = -1 : cos > 1 && (cos = 1, stretch && (sx *= (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1)), a2 = Math.acos(cos) * bendDir, a = l1 + l2 * cos, b = l2 * Math.sin(a2), a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);
          } else {
            var aa = (a = psx * l2) * a, bb = (b = psy * l2) * b, ta = Math.atan2(ty, tx), c1 = -2 * bb * l1, c2 = bb - aa;
            if ((d = c1 * c1 - 4 * c2 * (c = bb * l1 * l1 + aa * dd - aa * bb)) >= 0) {
              var q = Math.sqrt(d);
              c1 < 0 && (q = -q);
              var r0 = (q = -(c1 + q) / 2) / c2, r1 = c / q, r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;
              if (r * r <= dd) {
                y = Math.sqrt(dd - r * r) * bendDir, a1 = ta - Math.atan2(y, r), a2 = Math.atan2(y / psy, (r - l1) / psx);
                break outer;
              }
            }
            var minAngle = spine4.MathUtils.PI, minX = l1 - a, minDist = minX * minX, minY = 0, maxAngle = 0, maxX = l1 + a, maxDist = maxX * maxX, maxY = 0;
            (c = -a * l1 / (aa - bb)) >= -1 && c <= 1 && (c = Math.acos(c), (d = (x = a * Math.cos(c) + l1) * x + (y = b * Math.sin(c)) * y) < minDist && (minAngle = c, minDist = d, minX = x, minY = y), d > maxDist && (maxAngle = c, maxDist = d, maxX = x, maxY = y)), dd <= (minDist + maxDist) / 2 ? (a1 = ta - Math.atan2(minY * bendDir, minX), a2 = minAngle * bendDir) : (a1 = ta - Math.atan2(maxY * bendDir, maxX), a2 = maxAngle * bendDir);
          }
          var os = Math.atan2(cy, cx) * s2, rotation = parent.arotation;
          (a1 = (a1 - os) * spine4.MathUtils.radDeg + os1 - rotation) > 180 ? a1 -= 360 : a1 < -180 && (a1 += 360), parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, parent.ascaleY, 0, 0), rotation = child.arotation, (a2 = ((a2 + os) * spine4.MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation) > 180 ? a2 -= 360 : a2 < -180 && (a2 += 360), child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
        } else child.updateWorldTransform();
      }, IkConstraint2;
    })();
    spine4.IkConstraint = IkConstraint;
  })(spine || (spine = {})), (function(spine4) {
    var IkConstraintData = (function(_super) {
      function IkConstraintData2(name) {
        var _this = _super.call(this, name, 0, false) || this;
        return _this.bones = new Array(), _this.bendDirection = 1, _this.compress = false, _this.stretch = false, _this.uniform = false, _this.mix = 1, _this.softness = 0, _this;
      }
      return __extends(IkConstraintData2, _super), IkConstraintData2;
    })(spine4.ConstraintData);
    spine4.IkConstraintData = IkConstraintData;
  })(spine || (spine = {})), (function(spine4) {
    var PathConstraint = (function() {
      function PathConstraint2(data, Skeleton2) {
        if (this.position = 0, this.spacing = 0, this.rotateMix = 0, this.translateMix = 0, this.spaces = new Array(), this.positions = new Array(), this.world = new Array(), this.curves = new Array(), this.lengths = new Array(), this.segments = new Array(), this.active = false, null == data) throw new Error("data cannot be null.");
        if (null == skeleton) throw new Error("skeleton cannot be null.");
        this.data = data, this.bones = new Array();
        for (var i = 0, n = data.bones.length; i < n; i++) this.bones.push(skeleton.findBone(data.bones[i].name));
        this.target = Skeleton2.findSlot(data.target.name), this.position = data.position, this.spacing = data.spacing, this.rotateMix = data.rotateMix, this.translateMix = data.translateMix;
      }
      return PathConstraint2.prototype.isActive = function() {
        return this.active;
      }, PathConstraint2.prototype.apply = function() {
        this.update();
      }, PathConstraint2.prototype.update = function() {
        var attachment = this.target.getAttachment();
        if (attachment instanceof spine4.PathAttachment) {
          var rotateMix = this.rotateMix, translateMix = this.translateMix, rotate = rotateMix > 0;
          if (translateMix > 0 || rotate) {
            var data = this.data, percentSpacing = data.spacingMode == spine4.SpacingMode.Percent, rotateMode = data.rotateMode, tangents = rotateMode == spine4.RotateMode.Tangent, scale = rotateMode == spine4.RotateMode.ChainScale, boneCount = this.bones.length, spacesCount = tangents ? boneCount : boneCount + 1, bones = this.bones, spaces = spine4.Utils.setArraySize(this.spaces, spacesCount), lengths = null, spacing = this.spacing;
            if (scale || !percentSpacing) {
              scale && (lengths = spine4.Utils.setArraySize(this.lengths, boneCount));
              for (var lengthSpacing = data.spacingMode == spine4.SpacingMode.Length, i = 0, n = spacesCount - 1; i < n; ) {
                var bone, setupLength = (bone = bones[i]).data.length;
                if (setupLength < PathConstraint2.epsilon) scale && (lengths[i] = 0), spaces[++i] = 0;
                else if (percentSpacing) {
                  if (scale) {
                    var x = setupLength * bone.a, y = setupLength * bone.c, length_1 = Math.sqrt(x * x + y * y);
                    lengths[i] = length_1;
                  }
                  spaces[++i] = spacing;
                } else {
                  var x = setupLength * bone.a, y = setupLength * bone.c, length_2 = Math.sqrt(x * x + y * y);
                  scale && (lengths[i] = length_2), spaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length_2 / setupLength;
                }
              }
            } else for (var i = 1; i < spacesCount; i++) spaces[i] = spacing;
            var positions = this.computeWorldPositions(attachment, spacesCount, tangents, data.positionMode == spine4.PositionMode.Percent, percentSpacing), boneX = positions[0], boneY = positions[1], offsetRotation = data.offsetRotation, tip = false, p;
            if (0 == offsetRotation) tip = rotateMode == spine4.RotateMode.Chain;
            else tip = false, offsetRotation *= (p = this.target.bone).a * p.d - p.b * p.c > 0 ? spine4.MathUtils.degRad : -spine4.MathUtils.degRad;
            for (var i = 0, p = 3; i < boneCount; i++, p += 3) {
              var bone;
              (bone = bones[i]).worldX += (boneX - bone.worldX) * translateMix, bone.worldY += (boneY - bone.worldY) * translateMix;
              var x, y, dx = (x = positions[p]) - boneX, dy = (y = positions[p + 1]) - boneY;
              if (scale) {
                var length_3 = lengths[i];
                if (0 != length_3) {
                  var s = (Math.sqrt(dx * dx + dy * dy) / length_3 - 1) * rotateMix + 1;
                  bone.a *= s, bone.c *= s;
                }
              }
              if (boneX = x, boneY = y, rotate) {
                var a = bone.a, b = bone.b, c = bone.c, d = bone.d, r = 0, cos = 0, sin = 0;
                if (r = tangents ? positions[p - 1] : 0 == spaces[i + 1] ? positions[p + 2] : Math.atan2(dy, dx), r -= Math.atan2(c, a), tip) {
                  cos = Math.cos(r), sin = Math.sin(r);
                  var length_4 = bone.data.length;
                  boneX += (length_4 * (cos * a - sin * c) - dx) * rotateMix, boneY += (length_4 * (sin * a + cos * c) - dy) * rotateMix;
                } else r += offsetRotation;
                r > spine4.MathUtils.PI ? r -= spine4.MathUtils.PI2 : r < -spine4.MathUtils.PI && (r += spine4.MathUtils.PI2), r *= rotateMix, cos = Math.cos(r), sin = Math.sin(r), bone.a = cos * a - sin * c, bone.b = cos * b - sin * d, bone.c = sin * a + cos * c, bone.d = sin * b + cos * d;
              }
              bone.appliedValid = false;
            }
          }
        }
      }, PathConstraint2.prototype.computeWorldPositions = function(path, spacesCount, tangents, percentPosition, percentSpacing) {
        var target = this.target, position = this.position, spaces = this.spaces, out = spine4.Utils.setArraySize(this.positions, 3 * spacesCount + 2), world = null, closed2 = path.closed, verticesLength = path.worldVerticesLength, curveCount = verticesLength / 6, prevCurve = PathConstraint2.NONE;
        if (!path.constantSpeed) {
          var lengths = path.lengths, pathLength_1 = lengths[curveCount -= closed2 ? 1 : 2];
          if (percentPosition && (position *= pathLength_1), percentSpacing) for (var i = 1; i < spacesCount; i++) spaces[i] *= pathLength_1;
          world = spine4.Utils.setArraySize(this.world, 8);
          for (var i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {
            var space, p = position += space = spaces[i];
            if (closed2) (p %= pathLength_1) < 0 && (p += pathLength_1), curve = 0;
            else {
              if (p < 0) {
                prevCurve != PathConstraint2.BEFORE && (prevCurve = PathConstraint2.BEFORE, path.computeWorldVertices(target, 2, 4, world, 0, 2)), this.addBeforePosition(p, world, 0, out, o);
                continue;
              }
              if (p > pathLength_1) {
                prevCurve != PathConstraint2.AFTER && (prevCurve = PathConstraint2.AFTER, path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2)), this.addAfterPosition(p - pathLength_1, world, 0, out, o);
                continue;
              }
            }
            for (; ; curve++) {
              var length_5 = lengths[curve];
              if (!(p > length_5)) {
                var prev;
                if (0 == curve) p /= length_5;
                else p = (p - (prev = lengths[curve - 1])) / (length_5 - prev);
                break;
              }
            }
            curve != prevCurve && (prevCurve = curve, closed2 && curve == curveCount ? (path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2), path.computeWorldVertices(target, 0, 4, world, 4, 2)) : path.computeWorldVertices(target, 6 * curve + 2, 8, world, 0, 2)), this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || i > 0 && 0 == space);
          }
          return out;
        }
        closed2 ? (verticesLength += 2, world = spine4.Utils.setArraySize(this.world, verticesLength), path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2), path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2), world[verticesLength - 2] = world[0], world[verticesLength - 1] = world[1]) : (curveCount--, verticesLength -= 4, world = spine4.Utils.setArraySize(this.world, verticesLength), path.computeWorldVertices(target, 2, verticesLength, world, 0, 2));
        for (var curves = spine4.Utils.setArraySize(this.curves, curveCount), pathLength = 0, x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0, tmpx = 0, tmpy = 0, dddfx = 0, dddfy = 0, ddfx = 0, ddfy = 0, dfx = 0, dfy = 0, i = 0, w = 2; i < curveCount; i++, w += 6) cx1 = world[w], cy1 = world[w + 1], cx2 = world[w + 2], cy2 = world[w + 3], ddfx = 2 * (tmpx = 0.1875 * (x1 - 2 * cx1 + cx2)) + (dddfx = 0.09375 * (3 * (cx1 - cx2) - x1 + (x2 = world[w + 4]))), ddfy = 2 * (tmpy = 0.1875 * (y1 - 2 * cy1 + cy2)) + (dddfy = 0.09375 * (3 * (cy1 - cy2) - y1 + (y2 = world[w + 5]))), dfx = 0.75 * (cx1 - x1) + tmpx + 0.16666667 * dddfx, dfy = 0.75 * (cy1 - y1) + tmpy + 0.16666667 * dddfy, pathLength += Math.sqrt(dfx * dfx + dfy * dfy), dfx += ddfx, dfy += ddfy, ddfx += dddfx, ddfy += dddfy, pathLength += Math.sqrt(dfx * dfx + dfy * dfy), dfx += ddfx, dfy += ddfy, pathLength += Math.sqrt(dfx * dfx + dfy * dfy), dfx += ddfx + dddfx, dfy += ddfy + dddfy, pathLength += Math.sqrt(dfx * dfx + dfy * dfy), curves[i] = pathLength, x1 = x2, y1 = y2;
        if (position *= percentPosition ? pathLength : pathLength / path.lengths[curveCount - 1], percentSpacing) for (var i = 1; i < spacesCount; i++) spaces[i] *= pathLength;
        for (var segments = this.segments, curveLength = 0, i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {
          var space, p = position += space = spaces[i];
          if (closed2) (p %= pathLength) < 0 && (p += pathLength), curve = 0;
          else {
            if (p < 0) {
              this.addBeforePosition(p, world, 0, out, o);
              continue;
            }
            if (p > pathLength) {
              this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);
              continue;
            }
          }
          for (; ; curve++) {
            var length_6 = curves[curve];
            if (!(p > length_6)) {
              var prev;
              if (0 == curve) p /= length_6;
              else p = (p - (prev = curves[curve - 1])) / (length_6 - prev);
              break;
            }
          }
          if (curve != prevCurve) {
            prevCurve = curve;
            var ii = 6 * curve;
            for (x1 = world[ii], y1 = world[ii + 1], cx1 = world[ii + 2], cy1 = world[ii + 3], cx2 = world[ii + 4], cy2 = world[ii + 5], ddfx = 2 * (tmpx = 0.03 * (x1 - 2 * cx1 + cx2)) + (dddfx = 6e-3 * (3 * (cx1 - cx2) - x1 + (x2 = world[ii + 6]))), ddfy = 2 * (tmpy = 0.03 * (y1 - 2 * cy1 + cy2)) + (dddfy = 6e-3 * (3 * (cy1 - cy2) - y1 + (y2 = world[ii + 7]))), dfx = 0.3 * (cx1 - x1) + tmpx + 0.16666667 * dddfx, dfy = 0.3 * (cy1 - y1) + tmpy + 0.16666667 * dddfy, curveLength = Math.sqrt(dfx * dfx + dfy * dfy), segments[0] = curveLength, ii = 1; ii < 8; ii++) dfx += ddfx, dfy += ddfy, ddfx += dddfx, ddfy += dddfy, curveLength += Math.sqrt(dfx * dfx + dfy * dfy), segments[ii] = curveLength;
            dfx += ddfx, dfy += ddfy, curveLength += Math.sqrt(dfx * dfx + dfy * dfy), segments[8] = curveLength, dfx += ddfx + dddfx, dfy += ddfy + dddfy, curveLength += Math.sqrt(dfx * dfx + dfy * dfy), segments[9] = curveLength, segment = 0;
          }
          for (p *= curveLength; ; segment++) {
            var length_7 = segments[segment];
            if (!(p > length_7)) {
              var prev;
              if (0 == segment) p /= length_7;
              else p = segment + (p - (prev = segments[segment - 1])) / (length_7 - prev);
              break;
            }
          }
          this.addCurvePosition(0.1 * p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || i > 0 && 0 == space);
        }
        return out;
      }, PathConstraint2.prototype.addBeforePosition = function(p, temp, i, out, o) {
        var x1 = temp[i], y1 = temp[i + 1], dx = temp[i + 2] - x1, dy = temp[i + 3] - y1, r = Math.atan2(dy, dx);
        out[o] = x1 + p * Math.cos(r), out[o + 1] = y1 + p * Math.sin(r), out[o + 2] = r;
      }, PathConstraint2.prototype.addAfterPosition = function(p, temp, i, out, o) {
        var x1 = temp[i + 2], y1 = temp[i + 3], dx = x1 - temp[i], dy = y1 - temp[i + 1], r = Math.atan2(dy, dx);
        out[o] = x1 + p * Math.cos(r), out[o + 1] = y1 + p * Math.sin(r), out[o + 2] = r;
      }, PathConstraint2.prototype.addCurvePosition = function(p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {
        if (0 == p || isNaN(p)) return out[o] = x1, out[o + 1] = y1, void (out[o + 2] = Math.atan2(cy1 - y1, cx1 - x1));
        var tt = p * p, ttt = tt * p, u = 1 - p, uu = u * u, uuu = uu * u, ut = u * p, ut3 = 3 * ut, uut3 = u * ut3, utt3 = ut3 * p, x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;
        out[o] = x, out[o + 1] = y, tangents && (out[o + 2] = p < 1e-3 ? Math.atan2(cy1 - y1, cx1 - x1) : Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt)));
      }, PathConstraint2.NONE = -1, PathConstraint2.BEFORE = -2, PathConstraint2.AFTER = -3, PathConstraint2.epsilon = 1e-5, PathConstraint2;
    })();
    spine4.PathConstraint = PathConstraint;
  })(spine || (spine = {})), (function(spine4) {
    var PathConstraintData = (function(_super) {
      function PathConstraintData2(name) {
        var _this = _super.call(this, name, 0, false) || this;
        return _this.bones = new Array(), _this;
      }
      return __extends(PathConstraintData2, _super), PathConstraintData2;
    })(spine4.ConstraintData);
    spine4.PathConstraintData = PathConstraintData, (function(PositionMode2) {
      PositionMode2[PositionMode2.Fixed = 0] = "Fixed", PositionMode2[PositionMode2.Percent = 1] = "Percent";
    })(spine4.PositionMode || (spine4.PositionMode = {})), (function(SpacingMode2) {
      SpacingMode2[SpacingMode2.Length = 0] = "Length", SpacingMode2[SpacingMode2.Fixed = 1] = "Fixed", SpacingMode2[SpacingMode2.Percent = 2] = "Percent";
    })(spine4.SpacingMode || (spine4.SpacingMode = {})), (function(RotateMode2) {
      RotateMode2[RotateMode2.Tangent = 0] = "Tangent", RotateMode2[RotateMode2.Chain = 1] = "Chain", RotateMode2[RotateMode2.ChainScale = 2] = "ChainScale";
    })(spine4.RotateMode || (spine4.RotateMode = {}));
  })(spine || (spine = {})), (function(spine4) {
    var Assets = (function() {
      function Assets2(clientId) {
        this.toLoad = new Array(), this.assets = {}, this.clientId = clientId;
      }
      return Assets2.prototype.loaded = function() {
        var i = 0;
        for (var v in this.assets) i++;
        return i;
      }, Assets2;
    })(), SharedAssetManager = (function() {
      function SharedAssetManager2(pathPrefix) {
        void 0 === pathPrefix && (pathPrefix = ""), this.clientAssets = {}, this.queuedAssets = {}, this.rawAssets = {}, this.errors = {}, this.pathPrefix = pathPrefix;
      }
      return SharedAssetManager2.prototype.queueAsset = function(clientId, textureLoader, path) {
        var clientAssets = this.clientAssets[clientId];
        return null == clientAssets && (clientAssets = new Assets(clientId), this.clientAssets[clientId] = clientAssets), null !== textureLoader && (clientAssets.textureLoader = textureLoader), clientAssets.toLoad.push(path), this.queuedAssets[path] !== path && (this.queuedAssets[path] = path, true);
      }, SharedAssetManager2.prototype.loadText = function(clientId, path) {
        var _this = this;
        if (path = this.pathPrefix + path, this.queueAsset(clientId, null, path)) {
          var request = new XMLHttpRequest();
          request.overrideMimeType("text/html"), request.onreadystatechange = function() {
            request.readyState == XMLHttpRequest.DONE && (request.status >= 200 && request.status < 300 ? _this.rawAssets[path] = request.responseText : _this.errors[path] = "Couldn't load text " + path + ": status " + request.status + ", " + request.responseText);
          }, request.open("GET", path, true), request.send();
        }
      }, SharedAssetManager2.prototype.loadJson = function(clientId, path) {
        var _this = this;
        if (path = this.pathPrefix + path, this.queueAsset(clientId, null, path)) {
          var request = new XMLHttpRequest();
          request.overrideMimeType("text/html"), request.onreadystatechange = function() {
            request.readyState == XMLHttpRequest.DONE && (request.status >= 200 && request.status < 300 ? _this.rawAssets[path] = JSON.parse(request.responseText) : _this.errors[path] = "Couldn't load text " + path + ": status " + request.status + ", " + request.responseText);
          }, request.open("GET", path, true), request.send();
        }
      }, SharedAssetManager2.prototype.loadTexture = function(clientId, textureLoader, path) {
        var _this = this;
        if (path = this.pathPrefix + path, this.queueAsset(clientId, textureLoader, path)) if (!!("undefined" == typeof window || "undefined" == typeof navigator || !window.document) && "undefined" != typeof importScripts) {
          fetch(path, { mode: "cors" }).then((function(response) {
            return response.ok || (_this.errors[path] = "Couldn't load image " + path), response.blob();
          })).then((function(blob) {
            return createImageBitmap(blob, { premultiplyAlpha: "none", colorSpaceConversion: "none" });
          })).then((function(bitmap) {
            _this.rawAssets[path] = bitmap;
          }));
        } else {
          var img_1 = new Image();
          img_1.crossOrigin = "anonymous", img_1.onload = function(ev) {
            _this.rawAssets[path] = img_1;
          }, img_1.onerror = function(ev) {
            _this.errors[path] = "Couldn't load image " + path;
          }, img_1.src = path;
        }
      }, SharedAssetManager2.prototype.get = function(clientId, path) {
        path = this.pathPrefix + path;
        var clientAssets = this.clientAssets[clientId];
        return null == clientAssets || clientAssets.assets[path];
      }, SharedAssetManager2.prototype.updateClientAssets = function(clientAssets) {
        for (var isBrowser, isWebWorker = !!("undefined" == typeof window || "undefined" == typeof navigator || !window.document) && "undefined" != typeof importScripts, i = 0; i < clientAssets.toLoad.length; i++) {
          var path = clientAssets.toLoad[i], asset = clientAssets.assets[path];
          if (null == asset) {
            var rawAsset = this.rawAssets[path];
            if (null == rawAsset) continue;
            isWebWorker ? rawAsset instanceof ImageBitmap ? clientAssets.assets[path] = clientAssets.textureLoader(rawAsset) : clientAssets.assets[path] = rawAsset : rawAsset instanceof HTMLImageElement ? clientAssets.assets[path] = clientAssets.textureLoader(rawAsset) : clientAssets.assets[path] = rawAsset;
          }
        }
      }, SharedAssetManager2.prototype.isLoadingComplete = function(clientId) {
        var clientAssets = this.clientAssets[clientId];
        return null == clientAssets || (this.updateClientAssets(clientAssets), clientAssets.toLoad.length == clientAssets.loaded());
      }, SharedAssetManager2.prototype.dispose = function() {
      }, SharedAssetManager2.prototype.hasErrors = function() {
        return Object.keys(this.errors).length > 0;
      }, SharedAssetManager2.prototype.getErrors = function() {
        return this.errors;
      }, SharedAssetManager2;
    })();
    spine4.SharedAssetManager = SharedAssetManager;
  })(spine || (spine = {})), (function(spine4) {
    var Skeleton2 = (function() {
      function Skeleton3(data) {
        if (this._updateCache = new Array(), this.updateCacheReset = new Array(), this.time = 0, this.scaleX = 1, this.scaleY = 1, this.x = 0, this.y = 0, null == data) throw new Error("data cannot be null.");
        this.data = data, this.bones = new Array();
        for (var i = 0; i < data.bones.length; i++) {
          var boneData = data.bones[i], bone = void 0;
          if (null == boneData.parent) bone = new spine4.Bone(boneData, this, null);
          else {
            var parent_1 = this.bones[boneData.parent.index];
            bone = new spine4.Bone(boneData, this, parent_1), parent_1.children.push(bone);
          }
          this.bones.push(bone);
        }
        this.slots = new Array(), this.drawOrder = new Array();
        for (var i = 0; i < data.slots.length; i++) {
          var slotData = data.slots[i], bone = this.bones[slotData.boneData.index], slot = new spine4.Slot(slotData, bone);
          this.slots.push(slot), this.drawOrder.push(slot);
        }
        this.ikConstraints = new Array();
        for (var i = 0; i < data.ikConstraints.length; i++) {
          var ikConstraintData = data.ikConstraints[i];
          this.ikConstraints.push(new spine4.IkConstraint(ikConstraintData, this));
        }
        this.transformConstraints = new Array();
        for (var i = 0; i < data.transformConstraints.length; i++) {
          var transformConstraintData = data.transformConstraints[i];
          this.transformConstraints.push(new spine4.TransformConstraint(transformConstraintData, this));
        }
        this.pathConstraints = new Array();
        for (var i = 0; i < data.pathConstraints.length; i++) {
          var pathConstraintData = data.pathConstraints[i];
          this.pathConstraints.push(new spine4.PathConstraint(pathConstraintData, this));
        }
        this.color = new spine4.Color(1, 1, 1, 1), this.updateCache();
      }
      return Skeleton3.prototype.updateCache = function() {
        this._updateCache.length = 0, this.updateCacheReset.length = 0;
        for (var bones = this.bones, i = 0, n = bones.length; i < n; i++) {
          var bone;
          (bone = bones[i]).sorted = bone.data.skinRequired, bone.active = !bone.sorted;
        }
        if (null != this.skin) for (var skinBones = this.skin.bones, i = 0, n = this.skin.bones.length; i < n; i++) {
          var bone = this.bones[skinBones[i].index];
          do {
            bone.sorted = false, bone.active = true, bone = bone.parent;
          } while (null != bone);
        }
        var ikConstraints = this.ikConstraints, transformConstraints = this.transformConstraints, pathConstraints = this.pathConstraints, ikCount = ikConstraints.length, transformCount = transformConstraints.length, pathCount = pathConstraints.length, constraintCount = ikCount + transformCount + pathCount;
        outer: for (var i = 0; i < constraintCount; i++) {
          for (var ii = 0; ii < ikCount; ii++) {
            var constraint;
            if ((constraint = ikConstraints[ii]).data.order == i) {
              this.sortIkConstraint(constraint);
              continue outer;
            }
          }
          for (var ii = 0; ii < transformCount; ii++) {
            var constraint;
            if ((constraint = transformConstraints[ii]).data.order == i) {
              this.sortTransformConstraint(constraint);
              continue outer;
            }
          }
          for (var ii = 0; ii < pathCount; ii++) {
            var constraint;
            if ((constraint = pathConstraints[ii]).data.order == i) {
              this.sortPathConstraint(constraint);
              continue outer;
            }
          }
        }
        for (var i = 0, n = bones.length; i < n; i++) this.sortBone(bones[i]);
      }, Skeleton3.prototype.sortIkConstraint = function(constraint) {
        if (constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || null != this.skin && spine4.Utils.contains(this.skin.constraints, constraint.data, true)), constraint.active) {
          var target = constraint.target;
          this.sortBone(target);
          var constrained = constraint.bones, parent = constrained[0];
          if (this.sortBone(parent), constrained.length > 1) {
            var child = constrained[constrained.length - 1];
            this._updateCache.indexOf(child) > -1 || this.updateCacheReset.push(child);
          }
          this._updateCache.push(constraint), this.sortReset(parent.children), constrained[constrained.length - 1].sorted = true;
        }
      }, Skeleton3.prototype.sortPathConstraint = function(constraint) {
        if (constraint.active = constraint.target.bone.isActive() && (!constraint.data.skinRequired || null != this.skin && spine4.Utils.contains(this.skin.constraints, constraint.data, true)), constraint.active) {
          var slot = constraint.target, slotIndex = slot.data.index, slotBone = slot.bone;
          null != this.skin && this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone), null != this.data.defaultSkin && this.data.defaultSkin != this.skin && this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);
          for (var i = 0, n = this.data.skins.length; i < n; i++) this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);
          var attachment = slot.getAttachment();
          attachment instanceof spine4.PathAttachment && this.sortPathConstraintAttachmentWith(attachment, slotBone);
          for (var constrained = constraint.bones, boneCount = constrained.length, i = 0; i < boneCount; i++) this.sortBone(constrained[i]);
          this._updateCache.push(constraint);
          for (var i = 0; i < boneCount; i++) this.sortReset(constrained[i].children);
          for (var i = 0; i < boneCount; i++) constrained[i].sorted = true;
        }
      }, Skeleton3.prototype.sortTransformConstraint = function(constraint) {
        if (constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || null != this.skin && spine4.Utils.contains(this.skin.constraints, constraint.data, true)), constraint.active) {
          this.sortBone(constraint.target);
          var constrained = constraint.bones, boneCount = constrained.length;
          if (constraint.data.local) for (var i = 0; i < boneCount; i++) {
            var child = constrained[i];
            this.sortBone(child.parent), this._updateCache.indexOf(child) > -1 || this.updateCacheReset.push(child);
          }
          else for (var i = 0; i < boneCount; i++) this.sortBone(constrained[i]);
          this._updateCache.push(constraint);
          for (var ii = 0; ii < boneCount; ii++) this.sortReset(constrained[ii].children);
          for (var ii = 0; ii < boneCount; ii++) constrained[ii].sorted = true;
        }
      }, Skeleton3.prototype.sortPathConstraintAttachment = function(skin, slotIndex, slotBone) {
        var attachments = skin.attachments[slotIndex];
        if (attachments) for (var key in attachments) this.sortPathConstraintAttachmentWith(attachments[key], slotBone);
      }, Skeleton3.prototype.sortPathConstraintAttachmentWith = function(attachment, slotBone) {
        if (attachment instanceof spine4.PathAttachment) {
          var pathBones = attachment.bones;
          if (null == pathBones) this.sortBone(slotBone);
          else for (var bones = this.bones, i = 0; i < pathBones.length; ) for (var boneCount = pathBones[i++], n = i + boneCount; i < n; i++) {
            var boneIndex = pathBones[i];
            this.sortBone(bones[boneIndex]);
          }
        }
      }, Skeleton3.prototype.sortBone = function(bone) {
        if (!bone.sorted) {
          var parent = bone.parent;
          null != parent && this.sortBone(parent), bone.sorted = true, this._updateCache.push(bone);
        }
      }, Skeleton3.prototype.sortReset = function(bones) {
        for (var i = 0, n = bones.length; i < n; i++) {
          var bone = bones[i];
          bone.active && (bone.sorted && this.sortReset(bone.children), bone.sorted = false);
        }
      }, Skeleton3.prototype.updateWorldTransform = function() {
        for (var updateCacheReset = this.updateCacheReset, i = 0, n = updateCacheReset.length; i < n; i++) {
          var bone = updateCacheReset[i];
          bone.ax = bone.x, bone.ay = bone.y, bone.arotation = bone.rotation, bone.ascaleX = bone.scaleX, bone.ascaleY = bone.scaleY, bone.ashearX = bone.shearX, bone.ashearY = bone.shearY, bone.appliedValid = true;
        }
        for (var updateCache = this._updateCache, i = 0, n = updateCache.length; i < n; i++) updateCache[i].update();
      }, Skeleton3.prototype.setToSetupPose = function() {
        this.setBonesToSetupPose(), this.setSlotsToSetupPose();
      }, Skeleton3.prototype.setBonesToSetupPose = function() {
        for (var bones = this.bones, i = 0, n = bones.length; i < n; i++) bones[i].setToSetupPose();
        for (var ikConstraints = this.ikConstraints, i = 0, n = ikConstraints.length; i < n; i++) {
          var constraint;
          (constraint = ikConstraints[i]).mix = constraint.data.mix, constraint.softness = constraint.data.softness, constraint.bendDirection = constraint.data.bendDirection, constraint.compress = constraint.data.compress, constraint.stretch = constraint.data.stretch;
        }
        for (var transformConstraints = this.transformConstraints, i = 0, n = transformConstraints.length; i < n; i++) {
          var constraint, data = (constraint = transformConstraints[i]).data;
          constraint.rotateMix = data.rotateMix, constraint.translateMix = data.translateMix, constraint.scaleMix = data.scaleMix, constraint.shearMix = data.shearMix;
        }
        for (var pathConstraints = this.pathConstraints, i = 0, n = pathConstraints.length; i < n; i++) {
          var constraint, data = (constraint = pathConstraints[i]).data;
          constraint.position = data.position, constraint.spacing = data.spacing, constraint.rotateMix = data.rotateMix, constraint.translateMix = data.translateMix;
        }
      }, Skeleton3.prototype.setSlotsToSetupPose = function() {
        var slots = this.slots;
        spine4.Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);
        for (var i = 0, n = slots.length; i < n; i++) slots[i].setToSetupPose();
      }, Skeleton3.prototype.getRootBone = function() {
        return 0 == this.bones.length ? null : this.bones[0];
      }, Skeleton3.prototype.findBone = function(boneName) {
        if (null == boneName) throw new Error("boneName cannot be null.");
        for (var bones = this.bones, i = 0, n = bones.length; i < n; i++) {
          var bone = bones[i];
          if (bone.data.name == boneName) return bone;
        }
        return null;
      }, Skeleton3.prototype.findBoneIndex = function(boneName) {
        if (null == boneName) throw new Error("boneName cannot be null.");
        for (var bones = this.bones, i = 0, n = bones.length; i < n; i++) if (bones[i].data.name == boneName) return i;
        return -1;
      }, Skeleton3.prototype.findSlot = function(slotName) {
        if (null == slotName) throw new Error("slotName cannot be null.");
        for (var slots = this.slots, i = 0, n = slots.length; i < n; i++) {
          var slot = slots[i];
          if (slot.data.name == slotName) return slot;
        }
        return null;
      }, Skeleton3.prototype.findSlotIndex = function(slotName) {
        if (null == slotName) throw new Error("slotName cannot be null.");
        for (var slots = this.slots, i = 0, n = slots.length; i < n; i++) if (slots[i].data.name == slotName) return i;
        return -1;
      }, Skeleton3.prototype.setSkinByName = function(skinName) {
        var skin = this.data.findSkin(skinName);
        if (null == skin) throw new Error("Skin not found: " + skinName);
        this.setSkin(skin);
      }, Skeleton3.prototype.setSkin = function(newSkin) {
        if (newSkin != this.skin) {
          if (null != newSkin) if (null != this.skin) newSkin.attachAll(this, this.skin);
          else for (var slots = this.slots, i = 0, n = slots.length; i < n; i++) {
            var slot = slots[i], name_1 = slot.data.attachmentName;
            if (null != name_1) {
              var attachment = newSkin.getAttachment(i, name_1);
              null != attachment && slot.setAttachment(attachment);
            }
          }
          this.skin = newSkin, this.updateCache();
        }
      }, Skeleton3.prototype.getAttachmentByName = function(slotName, attachmentName) {
        return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);
      }, Skeleton3.prototype.getAttachment = function(slotIndex, attachmentName) {
        if (null == attachmentName) throw new Error("attachmentName cannot be null.");
        if (null != this.skin) {
          var attachment = this.skin.getAttachment(slotIndex, attachmentName);
          if (null != attachment) return attachment;
        }
        return null != this.data.defaultSkin ? this.data.defaultSkin.getAttachment(slotIndex, attachmentName) : null;
      }, Skeleton3.prototype.setAttachment = function(slotName, attachmentName) {
        if (null == slotName) throw new Error("slotName cannot be null.");
        for (var slots = this.slots, i = 0, n = slots.length; i < n; i++) {
          var slot = slots[i];
          if (slot.data.name == slotName) {
            var attachment = null;
            if (null != attachmentName && null == (attachment = this.getAttachment(i, attachmentName))) throw new Error("Attachment not found: " + attachmentName + ", for slot: " + slotName);
            return void slot.setAttachment(attachment);
          }
        }
        throw new Error("Slot not found: " + slotName);
      }, Skeleton3.prototype.findIkConstraint = function(constraintName) {
        if (null == constraintName) throw new Error("constraintName cannot be null.");
        for (var ikConstraints = this.ikConstraints, i = 0, n = ikConstraints.length; i < n; i++) {
          var ikConstraint = ikConstraints[i];
          if (ikConstraint.data.name == constraintName) return ikConstraint;
        }
        return null;
      }, Skeleton3.prototype.findTransformConstraint = function(constraintName) {
        if (null == constraintName) throw new Error("constraintName cannot be null.");
        for (var transformConstraints = this.transformConstraints, i = 0, n = transformConstraints.length; i < n; i++) {
          var constraint = transformConstraints[i];
          if (constraint.data.name == constraintName) return constraint;
        }
        return null;
      }, Skeleton3.prototype.findPathConstraint = function(constraintName) {
        if (null == constraintName) throw new Error("constraintName cannot be null.");
        for (var pathConstraints = this.pathConstraints, i = 0, n = pathConstraints.length; i < n; i++) {
          var constraint = pathConstraints[i];
          if (constraint.data.name == constraintName) return constraint;
        }
        return null;
      }, Skeleton3.prototype.getBounds = function(offset, size, temp) {
        if (void 0 === temp && (temp = new Array(2)), null == offset) throw new Error("offset cannot be null.");
        if (null == size) throw new Error("size cannot be null.");
        for (var drawOrder = this.drawOrder, minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY, i = 0, n = drawOrder.length; i < n; i++) {
          var slot = drawOrder[i];
          if (slot.bone.active) {
            var verticesLength = 0, vertices = null, attachment = slot.getAttachment();
            if (attachment instanceof spine4.RegionAttachment) verticesLength = 8, vertices = spine4.Utils.setArraySize(temp, verticesLength, 0), attachment.computeWorldVertices(slot.bone, vertices, 0, 2);
            else if (attachment instanceof spine4.MeshAttachment) {
              var mesh = attachment;
              verticesLength = mesh.worldVerticesLength, vertices = spine4.Utils.setArraySize(temp, verticesLength, 0), mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);
            }
            if (null != vertices) for (var ii = 0, nn = vertices.length; ii < nn; ii += 2) {
              var x = vertices[ii], y = vertices[ii + 1];
              minX = Math.min(minX, x), minY = Math.min(minY, y), maxX = Math.max(maxX, x), maxY = Math.max(maxY, y);
            }
          }
        }
        offset.set(minX, minY), size.set(maxX - minX, maxY - minY);
      }, Skeleton3.prototype.update = function(delta) {
        this.time += delta;
      }, Skeleton3;
    })();
    spine4.Skeleton = Skeleton2;
  })(spine || (spine = {})), (function(spine4) {
    var SkeletonBinary = (function() {
      function SkeletonBinary2(attachmentLoader) {
        this.scale = 1, this.linkedMeshes = new Array(), this.attachmentLoader = attachmentLoader;
      }
      return SkeletonBinary2.prototype.readSkeletonData = function(binary) {
        var scale = this.scale, SkeletonData2 = new SkeletonData2();
        skeletonData.name = "";
        var input = new BinaryInput(binary);
        skeletonData.hash = input.readString(), skeletonData.version = input.readString(), skeletonData.x = input.readFloat(), skeletonData.y = input.readFloat(), skeletonData.width = input.readFloat(), skeletonData.height = input.readFloat();
        var nonessential = input.readBoolean();
        nonessential && (skeletonData.fps = input.readFloat(), skeletonData.imagesPath = input.readString(), skeletonData.audioPath = input.readString());
        var n = 0;
        n = input.readInt(true);
        for (var i = 0; i < n; i++) input.strings.push(input.readString());
        n = input.readInt(true);
        for (var i = 0; i < n; i++) {
          var name_2 = input.readString(), parent_2 = 0 == i ? null : SkeletonData2.bones[input.readInt(true)], data;
          (data = new spine4.BoneData(i, name_2, parent_2)).rotation = input.readFloat(), data.x = input.readFloat() * scale, data.y = input.readFloat() * scale, data.scaleX = input.readFloat(), data.scaleY = input.readFloat(), data.shearX = input.readFloat(), data.shearY = input.readFloat(), data.length = input.readFloat() * scale, data.transformMode = SkeletonBinary2.TransformModeValues[input.readInt(true)], data.skinRequired = input.readBoolean(), nonessential && spine4.Color.rgba8888ToColor(data.color, input.readInt32()), skeletonData.bones.push(data);
        }
        n = input.readInt(true);
        for (var i = 0; i < n; i++) {
          var slotName = input.readString(), boneData = SkeletonData2.bones[input.readInt(true)], data = new spine4.SlotData(i, slotName, boneData);
          spine4.Color.rgba8888ToColor(data.color, input.readInt32());
          var darkColor = input.readInt32();
          -1 != darkColor && spine4.Color.rgb888ToColor(data.darkColor = new spine4.Color(), darkColor), data.attachmentName = input.readStringRef(), data.blendMode = SkeletonBinary2.BlendModeValues[input.readInt(true)], skeletonData.slots.push(data);
        }
        n = input.readInt(true);
        for (var i = 0, nn = void 0; i < n; i++) {
          var data;
          (data = new spine4.IkConstraintData(input.readString())).order = input.readInt(true), data.skinRequired = input.readBoolean(), nn = input.readInt(true);
          for (var ii = 0; ii < nn; ii++) data.bones.push(skeletonData.bones[input.readInt(true)]);
          data.target = SkeletonData2.bones[input.readInt(true)], data.mix = input.readFloat(), data.softness = input.readFloat() * scale, data.bendDirection = input.readByte(), data.compress = input.readBoolean(), data.stretch = input.readBoolean(), data.uniform = input.readBoolean(), skeletonData.ikConstraints.push(data);
        }
        n = input.readInt(true);
        for (var i = 0, nn = void 0; i < n; i++) {
          var data;
          (data = new spine4.TransformConstraintData(input.readString())).order = input.readInt(true), data.skinRequired = input.readBoolean(), nn = input.readInt(true);
          for (var ii = 0; ii < nn; ii++) data.bones.push(skeletonData.bones[input.readInt(true)]);
          data.target = SkeletonData2.bones[input.readInt(true)], data.local = input.readBoolean(), data.relative = input.readBoolean(), data.offsetRotation = input.readFloat(), data.offsetX = input.readFloat() * scale, data.offsetY = input.readFloat() * scale, data.offsetScaleX = input.readFloat(), data.offsetScaleY = input.readFloat(), data.offsetShearY = input.readFloat(), data.rotateMix = input.readFloat(), data.translateMix = input.readFloat(), data.scaleMix = input.readFloat(), data.shearMix = input.readFloat(), skeletonData.transformConstraints.push(data);
        }
        n = input.readInt(true);
        for (var i = 0, nn = void 0; i < n; i++) {
          var data;
          (data = new spine4.PathConstraintData(input.readString())).order = input.readInt(true), data.skinRequired = input.readBoolean(), nn = input.readInt(true);
          for (var ii = 0; ii < nn; ii++) data.bones.push(skeletonData.bones[input.readInt(true)]);
          data.target = SkeletonData2.slots[input.readInt(true)], data.positionMode = SkeletonBinary2.PositionModeValues[input.readInt(true)], data.spacingMode = SkeletonBinary2.SpacingModeValues[input.readInt(true)], data.rotateMode = SkeletonBinary2.RotateModeValues[input.readInt(true)], data.offsetRotation = input.readFloat(), data.position = input.readFloat(), data.positionMode == spine4.PositionMode.Fixed && (data.position *= scale), data.spacing = input.readFloat(), data.spacingMode != spine4.SpacingMode.Length && data.spacingMode != spine4.SpacingMode.Fixed || (data.spacing *= scale), data.rotateMix = input.readFloat(), data.translateMix = input.readFloat(), skeletonData.pathConstraints.push(data);
        }
        var defaultSkin = this.readSkin(input, SkeletonData2, true, nonessential);
        null != defaultSkin && (skeletonData.defaultSkin = defaultSkin, skeletonData.skins.push(defaultSkin));
        var i = SkeletonData2.skins.length;
        for (spine4.Utils.setArraySize(skeletonData.skins, n = i + input.readInt(true)); i < n; i++) skeletonData.skins[i] = this.readSkin(input, SkeletonData2, false, nonessential);
        n = this.linkedMeshes.length;
        for (var i = 0; i < n; i++) {
          var linkedMesh = this.linkedMeshes[i], skin = null == linkedMesh.skin ? SkeletonData2.defaultSkin : SkeletonData2.findSkin(linkedMesh.skin);
          if (null == skin) throw new Error("Skin not found: " + linkedMesh.skin);
          var parent_3 = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
          if (null == parent_3) throw new Error("Parent mesh not found: " + linkedMesh.parent);
          linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? parent_3 : linkedMesh.mesh, linkedMesh.mesh.setParentMesh(parent_3), linkedMesh.mesh.updateUVs();
        }
        this.linkedMeshes.length = 0, n = input.readInt(true);
        for (var i = 0; i < n; i++) {
          var data;
          (data = new spine4.EventData(input.readStringRef())).intValue = input.readInt(false), data.floatValue = input.readFloat(), data.stringValue = input.readString(), data.audioPath = input.readString(), null != data.audioPath && (data.volume = input.readFloat(), data.balance = input.readFloat()), skeletonData.events.push(data);
        }
        n = input.readInt(true);
        for (var i = 0; i < n; i++) skeletonData.animations.push(this.readAnimation(input, input.readString(), SkeletonData2));
        return SkeletonData2;
      }, SkeletonBinary2.prototype.readSkin = function(input, SkeletonData2, defaultSkin, nonessential) {
        var skin = null, slotCount = 0;
        if (defaultSkin) {
          if (0 == (slotCount = input.readInt(true))) return null;
          skin = new spine4.Skin("default");
        } else {
          (skin = new spine4.Skin(input.readStringRef())).bones.length = input.readInt(true);
          for (var i = 0, n = skin.bones.length; i < n; i++) skin.bones[i] = SkeletonData2.bones[input.readInt(true)];
          for (var i = 0, n = input.readInt(true); i < n; i++) skin.constraints.push(skeletonData.ikConstraints[input.readInt(true)]);
          for (var i = 0, n = input.readInt(true); i < n; i++) skin.constraints.push(skeletonData.transformConstraints[input.readInt(true)]);
          for (var i = 0, n = input.readInt(true); i < n; i++) skin.constraints.push(skeletonData.pathConstraints[input.readInt(true)]);
          slotCount = input.readInt(true);
        }
        for (var i = 0; i < slotCount; i++) for (var slotIndex = input.readInt(true), ii = 0, nn = input.readInt(true); ii < nn; ii++) {
          var name_3 = input.readStringRef(), attachment = this.readAttachment(input, SkeletonData2, skin, slotIndex, name_3, nonessential);
          null != attachment && skin.setAttachment(slotIndex, name_3, attachment);
        }
        return skin;
      }, SkeletonBinary2.prototype.readAttachment = function(input, SkeletonData2, skin, slotIndex, attachmentName, nonessential) {
        var scale = this.scale, name = input.readStringRef();
        null == name && (name = attachmentName);
        var typeIndex = input.readByte();
        switch (SkeletonBinary2.AttachmentTypeValues[typeIndex]) {
          case spine4.AttachmentType.Region:
            var path = input.readStringRef(), rotation = input.readFloat(), x = input.readFloat(), y = input.readFloat(), scaleX = input.readFloat(), scaleY = input.readFloat(), width = input.readFloat(), height = input.readFloat(), color = input.readInt32();
            null == path && (path = name);
            var region = this.attachmentLoader.newRegionAttachment(skin, name, path);
            return null == region ? null : (region.path = path, region.x = x * scale, region.y = y * scale, region.scaleX = scaleX, region.scaleY = scaleY, region.rotation = rotation, region.width = width * scale, region.height = height * scale, spine4.Color.rgba8888ToColor(region.color, color), region.updateOffset(), region);
          case spine4.AttachmentType.BoundingBox:
            var vertexCount = input.readInt(true), vertices = this.readVertices(input, vertexCount), color = nonessential ? input.readInt32() : 0, box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
            return null == box ? null : (box.worldVerticesLength = vertexCount << 1, box.vertices = vertices.vertices, box.bones = vertices.bones, nonessential && spine4.Color.rgba8888ToColor(box.color, color), box);
          case spine4.AttachmentType.Mesh:
            var path = input.readStringRef(), color = input.readInt32(), vertexCount = input.readInt(true), uvs = this.readFloatArray(input, vertexCount << 1, 1), triangles = this.readShortArray(input), vertices = this.readVertices(input, vertexCount), hullLength = input.readInt(true), edges = null, width = 0, height = 0, mesh;
            return nonessential && (edges = this.readShortArray(input), width = input.readFloat(), height = input.readFloat()), null == path && (path = name), null == (mesh = this.attachmentLoader.newMeshAttachment(skin, name, path)) ? null : (mesh.path = path, spine4.Color.rgba8888ToColor(mesh.color, color), mesh.bones = vertices.bones, mesh.vertices = vertices.vertices, mesh.worldVerticesLength = vertexCount << 1, mesh.triangles = triangles, mesh.regionUVs = uvs, mesh.updateUVs(), mesh.hullLength = hullLength << 1, nonessential && (mesh.edges = edges, mesh.width = width * scale, mesh.height = height * scale), mesh);
          case spine4.AttachmentType.LinkedMesh:
            var path = input.readStringRef(), color = input.readInt32(), skinName = input.readStringRef(), parent_4 = input.readStringRef(), inheritDeform = input.readBoolean(), width = 0, height = 0, mesh;
            return nonessential && (width = input.readFloat(), height = input.readFloat()), null == path && (path = name), null == (mesh = this.attachmentLoader.newMeshAttachment(skin, name, path)) ? null : (mesh.path = path, spine4.Color.rgba8888ToColor(mesh.color, color), nonessential && (mesh.width = width * scale, mesh.height = height * scale), this.linkedMeshes.push(new LinkedMesh(mesh, skinName, slotIndex, parent_4, inheritDeform)), mesh);
          case spine4.AttachmentType.Path:
            for (var closed_1 = input.readBoolean(), constantSpeed = input.readBoolean(), vertexCount = input.readInt(true), vertices = this.readVertices(input, vertexCount), lengths = spine4.Utils.newArray(vertexCount / 3, 0), i = 0, n = lengths.length; i < n; i++) lengths[i] = input.readFloat() * scale;
            var color = nonessential ? input.readInt32() : 0, path;
            return null == (path = this.attachmentLoader.newPathAttachment(skin, name)) ? null : (path.closed = closed_1, path.constantSpeed = constantSpeed, path.worldVerticesLength = vertexCount << 1, path.vertices = vertices.vertices, path.bones = vertices.bones, path.lengths = lengths, nonessential && spine4.Color.rgba8888ToColor(path.color, color), path);
          case spine4.AttachmentType.Point:
            var rotation = input.readFloat(), x = input.readFloat(), y = input.readFloat(), color = nonessential ? input.readInt32() : 0, point = this.attachmentLoader.newPointAttachment(skin, name);
            return null == point ? null : (point.x = x * scale, point.y = y * scale, point.rotation = rotation, nonessential && spine4.Color.rgba8888ToColor(point.color, color), point);
          case spine4.AttachmentType.Clipping:
            var endSlotIndex = input.readInt(true), vertexCount = input.readInt(true), vertices = this.readVertices(input, vertexCount), color = nonessential ? input.readInt32() : 0, clip = this.attachmentLoader.newClippingAttachment(skin, name);
            return null == clip ? null : (clip.endSlot = SkeletonData2.slots[endSlotIndex], clip.worldVerticesLength = vertexCount << 1, clip.vertices = vertices.vertices, clip.bones = vertices.bones, nonessential && spine4.Color.rgba8888ToColor(clip.color, color), clip);
        }
        return null;
      }, SkeletonBinary2.prototype.readVertices = function(input, vertexCount) {
        var verticesLength = vertexCount << 1, vertices = new Vertices(), scale = this.scale;
        if (!input.readBoolean()) return vertices.vertices = this.readFloatArray(input, verticesLength, scale), vertices;
        for (var weights = new Array(), bonesArray = new Array(), i = 0; i < vertexCount; i++) {
          var boneCount = input.readInt(true);
          bonesArray.push(boneCount);
          for (var ii = 0; ii < boneCount; ii++) bonesArray.push(input.readInt(true)), weights.push(input.readFloat() * scale), weights.push(input.readFloat() * scale), weights.push(input.readFloat());
        }
        return vertices.vertices = spine4.Utils.toFloatArray(weights), vertices.bones = bonesArray, vertices;
      }, SkeletonBinary2.prototype.readFloatArray = function(input, n, scale) {
        var array = new Array(n);
        if (1 == scale) for (var i = 0; i < n; i++) array[i] = input.readFloat();
        else for (var i = 0; i < n; i++) array[i] = input.readFloat() * scale;
        return array;
      }, SkeletonBinary2.prototype.readShortArray = function(input) {
        for (var n = input.readInt(true), array = new Array(n), i = 0; i < n; i++) array[i] = input.readShort();
        return array;
      }, SkeletonBinary2.prototype.readAnimation = function(input, name, SkeletonData2) {
        for (var timelines = new Array(), scale = this.scale, duration = 0, tempColor1 = new spine4.Color(), tempColor2 = new spine4.Color(), i = 0, n = input.readInt(true); i < n; i++) for (var slotIndex = input.readInt(true), ii = 0, nn = input.readInt(true); ii < nn; ii++) {
          var timelineType = input.readByte(), frameCount = input.readInt(true);
          switch (timelineType) {
            case SkeletonBinary2.SLOT_ATTACHMENT:
              var timeline;
              (timeline = new spine4.AttachmentTimeline(frameCount)).slotIndex = slotIndex;
              for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) timeline.setFrame(frameIndex, input.readFloat(), input.readStringRef());
              timelines.push(timeline), duration = Math.max(duration, timeline.frames[frameCount - 1]);
              break;
            case SkeletonBinary2.SLOT_COLOR:
              var timeline;
              (timeline = new spine4.ColorTimeline(frameCount)).slotIndex = slotIndex;
              for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {
                var time = input.readFloat();
                spine4.Color.rgba8888ToColor(tempColor1, input.readInt32()), timeline.setFrame(frameIndex, time, tempColor1.r, tempColor1.g, tempColor1.b, tempColor1.a), frameIndex < frameCount - 1 && this.readCurve(input, frameIndex, timeline);
              }
              timelines.push(timeline), duration = Math.max(duration, timeline.frames[(frameCount - 1) * spine4.ColorTimeline.ENTRIES]);
              break;
            case SkeletonBinary2.SLOT_TWO_COLOR:
              var timeline;
              (timeline = new spine4.TwoColorTimeline(frameCount)).slotIndex = slotIndex;
              for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {
                var time = input.readFloat();
                spine4.Color.rgba8888ToColor(tempColor1, input.readInt32()), spine4.Color.rgb888ToColor(tempColor2, input.readInt32()), timeline.setFrame(frameIndex, time, tempColor1.r, tempColor1.g, tempColor1.b, tempColor1.a, tempColor2.r, tempColor2.g, tempColor2.b), frameIndex < frameCount - 1 && this.readCurve(input, frameIndex, timeline);
              }
              timelines.push(timeline), duration = Math.max(duration, timeline.frames[(frameCount - 1) * spine4.TwoColorTimeline.ENTRIES]);
          }
        }
        for (var i = 0, n = input.readInt(true); i < n; i++) for (var boneIndex = input.readInt(true), ii = 0, nn = input.readInt(true); ii < nn; ii++) {
          var timelineType = input.readByte(), frameCount = input.readInt(true);
          switch (timelineType) {
            case SkeletonBinary2.BONE_ROTATE:
              var timeline;
              (timeline = new spine4.RotateTimeline(frameCount)).boneIndex = boneIndex;
              for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) timeline.setFrame(frameIndex, input.readFloat(), input.readFloat()), frameIndex < frameCount - 1 && this.readCurve(input, frameIndex, timeline);
              timelines.push(timeline), duration = Math.max(duration, timeline.frames[(frameCount - 1) * spine4.RotateTimeline.ENTRIES]);
              break;
            case SkeletonBinary2.BONE_TRANSLATE:
            case SkeletonBinary2.BONE_SCALE:
            case SkeletonBinary2.BONE_SHEAR:
              var timeline = void 0, timelineScale = 1;
              timelineType == SkeletonBinary2.BONE_SCALE ? timeline = new spine4.ScaleTimeline(frameCount) : timelineType == SkeletonBinary2.BONE_SHEAR ? timeline = new spine4.ShearTimeline(frameCount) : (timeline = new spine4.TranslateTimeline(frameCount), timelineScale = scale), timeline.boneIndex = boneIndex;
              for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) timeline.setFrame(frameIndex, input.readFloat(), input.readFloat() * timelineScale, input.readFloat() * timelineScale), frameIndex < frameCount - 1 && this.readCurve(input, frameIndex, timeline);
              timelines.push(timeline), duration = Math.max(duration, timeline.frames[(frameCount - 1) * spine4.TranslateTimeline.ENTRIES]);
          }
        }
        for (var i = 0, n = input.readInt(true); i < n; i++) {
          var index = input.readInt(true), frameCount = input.readInt(true), timeline;
          (timeline = new spine4.IkConstraintTimeline(frameCount)).ikConstraintIndex = index;
          for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat() * scale, input.readByte(), input.readBoolean(), input.readBoolean()), frameIndex < frameCount - 1 && this.readCurve(input, frameIndex, timeline);
          timelines.push(timeline), duration = Math.max(duration, timeline.frames[(frameCount - 1) * spine4.IkConstraintTimeline.ENTRIES]);
        }
        for (var i = 0, n = input.readInt(true); i < n; i++) {
          var index = input.readInt(true), frameCount = input.readInt(true), timeline;
          (timeline = new spine4.TransformConstraintTimeline(frameCount)).transformConstraintIndex = index;
          for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat()), frameIndex < frameCount - 1 && this.readCurve(input, frameIndex, timeline);
          timelines.push(timeline), duration = Math.max(duration, timeline.frames[(frameCount - 1) * spine4.TransformConstraintTimeline.ENTRIES]);
        }
        for (var i = 0, n = input.readInt(true); i < n; i++) for (var index = input.readInt(true), data = SkeletonData2.pathConstraints[index], ii = 0, nn = input.readInt(true); ii < nn; ii++) {
          var timelineType = input.readByte(), frameCount = input.readInt(true);
          switch (timelineType) {
            case SkeletonBinary2.PATH_POSITION:
            case SkeletonBinary2.PATH_SPACING:
              var timeline = void 0, timelineScale = 1;
              timelineType == SkeletonBinary2.PATH_SPACING ? (timeline = new spine4.PathConstraintSpacingTimeline(frameCount), data.spacingMode != spine4.SpacingMode.Length && data.spacingMode != spine4.SpacingMode.Fixed || (timelineScale = scale)) : (timeline = new spine4.PathConstraintPositionTimeline(frameCount), data.positionMode == spine4.PositionMode.Fixed && (timelineScale = scale)), timeline.pathConstraintIndex = index;
              for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) timeline.setFrame(frameIndex, input.readFloat(), input.readFloat() * timelineScale), frameIndex < frameCount - 1 && this.readCurve(input, frameIndex, timeline);
              timelines.push(timeline), duration = Math.max(duration, timeline.frames[(frameCount - 1) * spine4.PathConstraintPositionTimeline.ENTRIES]);
              break;
            case SkeletonBinary2.PATH_MIX:
              var timeline;
              (timeline = new spine4.PathConstraintMixTimeline(frameCount)).pathConstraintIndex = index;
              for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat()), frameIndex < frameCount - 1 && this.readCurve(input, frameIndex, timeline);
              timelines.push(timeline), duration = Math.max(duration, timeline.frames[(frameCount - 1) * spine4.PathConstraintMixTimeline.ENTRIES]);
          }
        }
        for (var i = 0, n = input.readInt(true); i < n; i++) for (var skin = SkeletonData2.skins[input.readInt(true)], ii = 0, nn = input.readInt(true); ii < nn; ii++) for (var slotIndex = input.readInt(true), iii = 0, nnn = input.readInt(true); iii < nnn; iii++) {
          var attachment = skin.getAttachment(slotIndex, input.readStringRef()), weighted = null != attachment.bones, vertices = attachment.vertices, deformLength = weighted ? vertices.length / 3 * 2 : vertices.length, frameCount = input.readInt(true), timeline;
          (timeline = new spine4.DeformTimeline(frameCount)).slotIndex = slotIndex, timeline.attachment = attachment;
          for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {
            var time = input.readFloat(), deform = void 0, end = input.readInt(true);
            if (0 == end) deform = weighted ? spine4.Utils.newFloatArray(deformLength) : vertices;
            else {
              deform = spine4.Utils.newFloatArray(deformLength);
              var start = input.readInt(true);
              if (end += start, 1 == scale) for (var v = start; v < end; v++) deform[v] = input.readFloat();
              else for (var v = start; v < end; v++) deform[v] = input.readFloat() * scale;
              if (!weighted) for (var v = 0, vn = deform.length; v < vn; v++) deform[v] += vertices[v];
            }
            timeline.setFrame(frameIndex, time, deform), frameIndex < frameCount - 1 && this.readCurve(input, frameIndex, timeline);
          }
          timelines.push(timeline), duration = Math.max(duration, timeline.frames[frameCount - 1]);
        }
        var drawOrderCount = input.readInt(true);
        if (drawOrderCount > 0) {
          for (var timeline = new spine4.DrawOrderTimeline(drawOrderCount), slotCount = SkeletonData2.slots.length, i = 0; i < drawOrderCount; i++) {
            for (var time = input.readFloat(), offsetCount = input.readInt(true), drawOrder = spine4.Utils.newArray(slotCount, 0), ii = slotCount - 1; ii >= 0; ii--) drawOrder[ii] = -1;
            for (var unchanged = spine4.Utils.newArray(slotCount - offsetCount, 0), originalIndex = 0, unchangedIndex = 0, ii = 0; ii < offsetCount; ii++) {
              for (var slotIndex = input.readInt(true); originalIndex != slotIndex; ) unchanged[unchangedIndex++] = originalIndex++;
              drawOrder[originalIndex + input.readInt(true)] = originalIndex++;
            }
            for (; originalIndex < slotCount; ) unchanged[unchangedIndex++] = originalIndex++;
            for (var ii = slotCount - 1; ii >= 0; ii--) -1 == drawOrder[ii] && (drawOrder[ii] = unchanged[--unchangedIndex]);
            timeline.setFrame(i, time, drawOrder);
          }
          timelines.push(timeline), duration = Math.max(duration, timeline.frames[drawOrderCount - 1]);
        }
        var eventCount = input.readInt(true);
        if (eventCount > 0) {
          for (var timeline = new spine4.EventTimeline(eventCount), i = 0; i < eventCount; i++) {
            var time = input.readFloat(), eventData = SkeletonData2.events[input.readInt(true)], event_4 = new spine4.Event(time, eventData);
            event_4.intValue = input.readInt(false), event_4.floatValue = input.readFloat(), event_4.stringValue = input.readBoolean() ? input.readString() : eventData.stringValue, null != event_4.data.audioPath && (event_4.volume = input.readFloat(), event_4.balance = input.readFloat()), timeline.setFrame(i, event_4);
          }
          timelines.push(timeline), duration = Math.max(duration, timeline.frames[eventCount - 1]);
        }
        return new spine4.Animation(name, timelines, duration);
      }, SkeletonBinary2.prototype.readCurve = function(input, frameIndex, timeline) {
        switch (input.readByte()) {
          case SkeletonBinary2.CURVE_STEPPED:
            timeline.setStepped(frameIndex);
            break;
          case SkeletonBinary2.CURVE_BEZIER:
            this.setCurve(timeline, frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat());
        }
      }, SkeletonBinary2.prototype.setCurve = function(timeline, frameIndex, cx1, cy1, cx2, cy2) {
        timeline.setCurve(frameIndex, cx1, cy1, cx2, cy2);
      }, SkeletonBinary2.AttachmentTypeValues = [0, 1, 2, 3, 4, 5, 6], SkeletonBinary2.TransformModeValues = [spine4.TransformMode.Normal, spine4.TransformMode.OnlyTranslation, spine4.TransformMode.NoRotationOrReflection, spine4.TransformMode.NoScale, spine4.TransformMode.NoScaleOrReflection], SkeletonBinary2.PositionModeValues = [spine4.PositionMode.Fixed, spine4.PositionMode.Percent], SkeletonBinary2.SpacingModeValues = [spine4.SpacingMode.Length, spine4.SpacingMode.Fixed, spine4.SpacingMode.Percent], SkeletonBinary2.RotateModeValues = [spine4.RotateMode.Tangent, spine4.RotateMode.Chain, spine4.RotateMode.ChainScale], SkeletonBinary2.BlendModeValues = [spine4.BlendMode.Normal, spine4.BlendMode.Additive, spine4.BlendMode.Multiply, spine4.BlendMode.Screen], SkeletonBinary2.BONE_ROTATE = 0, SkeletonBinary2.BONE_TRANSLATE = 1, SkeletonBinary2.BONE_SCALE = 2, SkeletonBinary2.BONE_SHEAR = 3, SkeletonBinary2.SLOT_ATTACHMENT = 0, SkeletonBinary2.SLOT_COLOR = 1, SkeletonBinary2.SLOT_TWO_COLOR = 2, SkeletonBinary2.PATH_POSITION = 0, SkeletonBinary2.PATH_SPACING = 1, SkeletonBinary2.PATH_MIX = 2, SkeletonBinary2.CURVE_LINEAR = 0, SkeletonBinary2.CURVE_STEPPED = 1, SkeletonBinary2.CURVE_BEZIER = 2, SkeletonBinary2;
    })();
    spine4.SkeletonBinary = SkeletonBinary;
    var BinaryInput = (function() {
      function BinaryInput2(data, strings, index, buffer) {
        void 0 === strings && (strings = new Array()), void 0 === index && (index = 0), void 0 === buffer && (buffer = new DataView(data.buffer)), this.strings = strings, this.index = index, this.buffer = buffer;
      }
      return BinaryInput2.prototype.readByte = function() {
        return this.buffer.getInt8(this.index++);
      }, BinaryInput2.prototype.readShort = function() {
        var value = this.buffer.getInt16(this.index);
        return this.index += 2, value;
      }, BinaryInput2.prototype.readInt32 = function() {
        var value = this.buffer.getInt32(this.index);
        return this.index += 4, value;
      }, BinaryInput2.prototype.readInt = function(optimizePositive) {
        var b = this.readByte(), result = 127 & b;
        return 0 != (128 & b) && (result |= (127 & (b = this.readByte())) << 7, 0 != (128 & b) && (result |= (127 & (b = this.readByte())) << 14, 0 != (128 & b) && (result |= (127 & (b = this.readByte())) << 21, 0 != (128 & b) && (result |= (127 & (b = this.readByte())) << 28)))), optimizePositive ? result : result >>> 1 ^ -(1 & result);
      }, BinaryInput2.prototype.readStringRef = function() {
        var index = this.readInt(true);
        return 0 == index ? null : this.strings[index - 1];
      }, BinaryInput2.prototype.readString = function() {
        var byteCount = this.readInt(true);
        switch (byteCount) {
          case 0:
            return null;
          case 1:
            return "";
        }
        byteCount--;
        for (var chars = "", charCount = 0, i = 0; i < byteCount; ) {
          var b = this.readByte();
          switch (b >> 4) {
            case 12:
            case 13:
              chars += String.fromCharCode((31 & b) << 6 | 63 & this.readByte()), i += 2;
              break;
            case 14:
              chars += String.fromCharCode((15 & b) << 12 | (63 & this.readByte()) << 6 | 63 & this.readByte()), i += 3;
              break;
            default:
              chars += String.fromCharCode(b), i++;
          }
        }
        return chars;
      }, BinaryInput2.prototype.readFloat = function() {
        var value = this.buffer.getFloat32(this.index);
        return this.index += 4, value;
      }, BinaryInput2.prototype.readBoolean = function() {
        return 0 != this.readByte();
      }, BinaryInput2;
    })(), LinkedMesh = /* @__PURE__ */ (function() {
      function LinkedMesh2(mesh, skin, slotIndex, parent, inheritDeform) {
        this.mesh = mesh, this.skin = skin, this.slotIndex = slotIndex, this.parent = parent, this.inheritDeform = inheritDeform;
      }
      return LinkedMesh2;
    })(), Vertices = /* @__PURE__ */ (function() {
      function Vertices2(bones, vertices) {
        void 0 === bones && (bones = null), void 0 === vertices && (vertices = null), this.bones = bones, this.vertices = vertices;
      }
      return Vertices2;
    })();
  })(spine || (spine = {})), (function(spine4) {
    var SkeletonBounds = (function() {
      function SkeletonBounds2() {
        this.minX = 0, this.minY = 0, this.maxX = 0, this.maxY = 0, this.boundingBoxes = new Array(), this.polygons = new Array(), this.polygonPool = new spine4.Pool((function() {
          return spine4.Utils.newFloatArray(16);
        }));
      }
      return SkeletonBounds2.prototype.update = function(skeleton2, updateAabb) {
        if (null == skeleton2) throw new Error("skeleton cannot be null.");
        var boundingBoxes = this.boundingBoxes, polygons = this.polygons, polygonPool = this.polygonPool, slots = Skeleton.slots, slotCount = slots.length;
        boundingBoxes.length = 0, polygonPool.freeAll(polygons), polygons.length = 0;
        for (var i = 0; i < slotCount; i++) {
          var slot = slots[i];
          if (slot.bone.active) {
            var attachment = slot.getAttachment();
            if (attachment instanceof spine4.BoundingBoxAttachment) {
              var boundingBox = attachment;
              boundingBoxes.push(boundingBox);
              var polygon = polygonPool.obtain();
              polygon.length != boundingBox.worldVerticesLength && (polygon = spine4.Utils.newFloatArray(boundingBox.worldVerticesLength)), polygons.push(polygon), boundingBox.computeWorldVertices(slot, 0, boundingBox.worldVerticesLength, polygon, 0, 2);
            }
          }
        }
        updateAabb ? this.aabbCompute() : (this.minX = Number.POSITIVE_INFINITY, this.minY = Number.POSITIVE_INFINITY, this.maxX = Number.NEGATIVE_INFINITY, this.maxY = Number.NEGATIVE_INFINITY);
      }, SkeletonBounds2.prototype.aabbCompute = function() {
        for (var minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY, polygons = this.polygons, i = 0, n = polygons.length; i < n; i++) for (var polygon = polygons[i], vertices = polygon, ii = 0, nn = polygon.length; ii < nn; ii += 2) {
          var x = vertices[ii], y = vertices[ii + 1];
          minX = Math.min(minX, x), minY = Math.min(minY, y), maxX = Math.max(maxX, x), maxY = Math.max(maxY, y);
        }
        this.minX = minX, this.minY = minY, this.maxX = maxX, this.maxY = maxY;
      }, SkeletonBounds2.prototype.aabbContainsPoint = function(x, y) {
        return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;
      }, SkeletonBounds2.prototype.aabbIntersectsSegment = function(x1, y1, x2, y2) {
        var minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;
        if (x1 <= minX && x2 <= minX || y1 <= minY && y2 <= minY || x1 >= maxX && x2 >= maxX || y1 >= maxY && y2 >= maxY) return false;
        var m = (y2 - y1) / (x2 - x1), y = m * (minX - x1) + y1;
        if (y > minY && y < maxY) return true;
        if ((y = m * (maxX - x1) + y1) > minY && y < maxY) return true;
        var x = (minY - y1) / m + x1;
        return x > minX && x < maxX || (x = (maxY - y1) / m + x1) > minX && x < maxX;
      }, SkeletonBounds2.prototype.aabbIntersectsSkeleton = function(bounds) {
        return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;
      }, SkeletonBounds2.prototype.containsPoint = function(x, y) {
        for (var polygons = this.polygons, i = 0, n = polygons.length; i < n; i++) if (this.containsPointPolygon(polygons[i], x, y)) return this.boundingBoxes[i];
        return null;
      }, SkeletonBounds2.prototype.containsPointPolygon = function(polygon, x, y) {
        for (var vertices = polygon, nn = polygon.length, prevIndex = nn - 2, inside = false, ii = 0; ii < nn; ii += 2) {
          var vertexY = vertices[ii + 1], prevY = vertices[prevIndex + 1];
          if (vertexY < y && prevY >= y || prevY < y && vertexY >= y) {
            var vertexX = vertices[ii];
            vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x && (inside = !inside);
          }
          prevIndex = ii;
        }
        return inside;
      }, SkeletonBounds2.prototype.intersectsSegment = function(x1, y1, x2, y2) {
        for (var polygons = this.polygons, i = 0, n = polygons.length; i < n; i++) if (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2)) return this.boundingBoxes[i];
        return null;
      }, SkeletonBounds2.prototype.intersectsSegmentPolygon = function(polygon, x1, y1, x2, y2) {
        for (var vertices = polygon, nn = polygon.length, width12 = x1 - x2, height12 = y1 - y2, det1 = x1 * y2 - y1 * x2, x3 = vertices[nn - 2], y3 = vertices[nn - 1], ii = 0; ii < nn; ii += 2) {
          var x4 = vertices[ii], y4 = vertices[ii + 1], det2 = x3 * y4 - y3 * x4, width34 = x3 - x4, height34 = y3 - y4, det3 = width12 * height34 - height12 * width34, x = (det1 * width34 - width12 * det2) / det3;
          if ((x >= x3 && x <= x4 || x >= x4 && x <= x3) && (x >= x1 && x <= x2 || x >= x2 && x <= x1)) {
            var y = (det1 * height34 - height12 * det2) / det3;
            if ((y >= y3 && y <= y4 || y >= y4 && y <= y3) && (y >= y1 && y <= y2 || y >= y2 && y <= y1)) return true;
          }
          x3 = x4, y3 = y4;
        }
        return false;
      }, SkeletonBounds2.prototype.getPolygon = function(boundingBox) {
        if (null == boundingBox) throw new Error("boundingBox cannot be null.");
        var index = this.boundingBoxes.indexOf(boundingBox);
        return -1 == index ? null : this.polygons[index];
      }, SkeletonBounds2.prototype.getWidth = function() {
        return this.maxX - this.minX;
      }, SkeletonBounds2.prototype.getHeight = function() {
        return this.maxY - this.minY;
      }, SkeletonBounds2;
    })();
    spine4.SkeletonBounds = SkeletonBounds;
  })(spine || (spine = {})), (function(spine4) {
    var SkeletonClipping = (function() {
      function SkeletonClipping2() {
        this.triangulator = new spine4.Triangulator(), this.clippingPolygon = new Array(), this.clipOutput = new Array(), this.clippedVertices = new Array(), this.clippedTriangles = new Array(), this.scratch = new Array();
      }
      return SkeletonClipping2.prototype.clipStart = function(slot, clip) {
        if (null != this.clipAttachment) return 0;
        this.clipAttachment = clip;
        var n = clip.worldVerticesLength, vertices = spine4.Utils.setArraySize(this.clippingPolygon, n);
        clip.computeWorldVertices(slot, 0, n, vertices, 0, 2);
        var clippingPolygon = this.clippingPolygon;
        SkeletonClipping2.makeClockwise(clippingPolygon);
        for (var clippingPolygons = this.clippingPolygons = this.triangulator.decompose(clippingPolygon, this.triangulator.triangulate(clippingPolygon)), i = 0, n_2 = clippingPolygons.length; i < n_2; i++) {
          var polygon = clippingPolygons[i];
          SkeletonClipping2.makeClockwise(polygon), polygon.push(polygon[0]), polygon.push(polygon[1]);
        }
        return clippingPolygons.length;
      }, SkeletonClipping2.prototype.clipEndWithSlot = function(slot) {
        null != this.clipAttachment && this.clipAttachment.endSlot == slot.data && this.clipEnd();
      }, SkeletonClipping2.prototype.clipEnd = function() {
        null != this.clipAttachment && (this.clipAttachment = null, this.clippingPolygons = null, this.clippedVertices.length = 0, this.clippedTriangles.length = 0, this.clippingPolygon.length = 0);
      }, SkeletonClipping2.prototype.isClipping = function() {
        return null != this.clipAttachment;
      }, SkeletonClipping2.prototype.clipTriangles = function(vertices, verticesLength, triangles, trianglesLength, uvs, light, dark, twoColor) {
        var clipOutput = this.clipOutput, clippedVertices = this.clippedVertices, clippedTriangles = this.clippedTriangles, polygons = this.clippingPolygons, polygonsCount = this.clippingPolygons.length, vertexSize = twoColor ? 12 : 8, index = 0;
        clippedVertices.length = 0, clippedTriangles.length = 0;
        outer: for (var i = 0; i < trianglesLength; i += 3) for (var vertexOffset = triangles[i] << 1, x1 = vertices[vertexOffset], y1 = vertices[vertexOffset + 1], u1 = uvs[vertexOffset], v1 = uvs[vertexOffset + 1], x2 = vertices[vertexOffset = triangles[i + 1] << 1], y2 = vertices[vertexOffset + 1], u2 = uvs[vertexOffset], v2 = uvs[vertexOffset + 1], x3 = vertices[vertexOffset = triangles[i + 2] << 1], y3 = vertices[vertexOffset + 1], u3 = uvs[vertexOffset], v3 = uvs[vertexOffset + 1], p = 0; p < polygonsCount; p++) {
          var s = clippedVertices.length;
          if (!this.clip(x1, y1, x2, y2, x3, y3, polygons[p], clipOutput)) {
            var clippedVerticesItems, clippedTrianglesItems;
            (clippedVerticesItems = spine4.Utils.setArraySize(clippedVertices, s + 3 * vertexSize))[s] = x1, clippedVerticesItems[s + 1] = y1, clippedVerticesItems[s + 2] = light.r, clippedVerticesItems[s + 3] = light.g, clippedVerticesItems[s + 4] = light.b, clippedVerticesItems[s + 5] = light.a, twoColor ? (clippedVerticesItems[s + 6] = u1, clippedVerticesItems[s + 7] = v1, clippedVerticesItems[s + 8] = dark.r, clippedVerticesItems[s + 9] = dark.g, clippedVerticesItems[s + 10] = dark.b, clippedVerticesItems[s + 11] = dark.a, clippedVerticesItems[s + 12] = x2, clippedVerticesItems[s + 13] = y2, clippedVerticesItems[s + 14] = light.r, clippedVerticesItems[s + 15] = light.g, clippedVerticesItems[s + 16] = light.b, clippedVerticesItems[s + 17] = light.a, clippedVerticesItems[s + 18] = u2, clippedVerticesItems[s + 19] = v2, clippedVerticesItems[s + 20] = dark.r, clippedVerticesItems[s + 21] = dark.g, clippedVerticesItems[s + 22] = dark.b, clippedVerticesItems[s + 23] = dark.a, clippedVerticesItems[s + 24] = x3, clippedVerticesItems[s + 25] = y3, clippedVerticesItems[s + 26] = light.r, clippedVerticesItems[s + 27] = light.g, clippedVerticesItems[s + 28] = light.b, clippedVerticesItems[s + 29] = light.a, clippedVerticesItems[s + 30] = u3, clippedVerticesItems[s + 31] = v3, clippedVerticesItems[s + 32] = dark.r, clippedVerticesItems[s + 33] = dark.g, clippedVerticesItems[s + 34] = dark.b, clippedVerticesItems[s + 35] = dark.a) : (clippedVerticesItems[s + 6] = u1, clippedVerticesItems[s + 7] = v1, clippedVerticesItems[s + 8] = x2, clippedVerticesItems[s + 9] = y2, clippedVerticesItems[s + 10] = light.r, clippedVerticesItems[s + 11] = light.g, clippedVerticesItems[s + 12] = light.b, clippedVerticesItems[s + 13] = light.a, clippedVerticesItems[s + 14] = u2, clippedVerticesItems[s + 15] = v2, clippedVerticesItems[s + 16] = x3, clippedVerticesItems[s + 17] = y3, clippedVerticesItems[s + 18] = light.r, clippedVerticesItems[s + 19] = light.g, clippedVerticesItems[s + 20] = light.b, clippedVerticesItems[s + 21] = light.a, clippedVerticesItems[s + 22] = u3, clippedVerticesItems[s + 23] = v3), s = clippedTriangles.length, (clippedTrianglesItems = spine4.Utils.setArraySize(clippedTriangles, s + 3))[s] = index, clippedTrianglesItems[s + 1] = index + 1, clippedTrianglesItems[s + 2] = index + 2, index += 3;
            continue outer;
          }
          var clipOutputLength = clipOutput.length;
          if (0 != clipOutputLength) {
            for (var d0 = y2 - y3, d1 = x3 - x2, d2 = x1 - x3, d4 = y3 - y1, d = 1 / (d0 * d2 + d1 * (y1 - y3)), clipOutputCount = clipOutputLength >> 1, clipOutputItems = this.clipOutput, clippedVerticesItems = spine4.Utils.setArraySize(clippedVertices, s + clipOutputCount * vertexSize), ii = 0; ii < clipOutputLength; ii += 2) {
              var x = clipOutputItems[ii], y = clipOutputItems[ii + 1];
              clippedVerticesItems[s] = x, clippedVerticesItems[s + 1] = y, clippedVerticesItems[s + 2] = light.r, clippedVerticesItems[s + 3] = light.g, clippedVerticesItems[s + 4] = light.b, clippedVerticesItems[s + 5] = light.a;
              var c0 = x - x3, c1 = y - y3, a = (d0 * c0 + d1 * c1) * d, b = (d4 * c0 + d2 * c1) * d, c = 1 - a - b;
              clippedVerticesItems[s + 6] = u1 * a + u2 * b + u3 * c, clippedVerticesItems[s + 7] = v1 * a + v2 * b + v3 * c, twoColor && (clippedVerticesItems[s + 8] = dark.r, clippedVerticesItems[s + 9] = dark.g, clippedVerticesItems[s + 10] = dark.b, clippedVerticesItems[s + 11] = dark.a), s += vertexSize;
            }
            s = clippedTriangles.length;
            var clippedTrianglesItems = spine4.Utils.setArraySize(clippedTriangles, s + 3 * (clipOutputCount - 2));
            clipOutputCount--;
            for (var ii = 1; ii < clipOutputCount; ii++) clippedTrianglesItems[s] = index, clippedTrianglesItems[s + 1] = index + ii, clippedTrianglesItems[s + 2] = index + ii + 1, s += 3;
            index += clipOutputCount + 1;
          }
        }
      }, SkeletonClipping2.prototype.clip = function(x1, y1, x2, y2, x3, y3, clippingArea, output) {
        var originalOutput = output, clipped = false, input = null;
        clippingArea.length % 4 >= 2 ? (input = output, output = this.scratch) : input = this.scratch, input.length = 0, input.push(x1), input.push(y1), input.push(x2), input.push(y2), input.push(x3), input.push(y3), input.push(x1), input.push(y1), output.length = 0;
        for (var clippingVertices = clippingArea, clippingVerticesLast = clippingArea.length - 4, i = 0; ; i += 2) {
          for (var edgeX = clippingVertices[i], edgeY = clippingVertices[i + 1], edgeX2 = clippingVertices[i + 2], edgeY2 = clippingVertices[i + 3], deltaX = edgeX - edgeX2, deltaY = edgeY - edgeY2, inputVertices = input, inputVerticesLength = input.length - 2, outputStart = output.length, ii = 0; ii < inputVerticesLength; ii += 2) {
            var inputX = inputVertices[ii], inputY = inputVertices[ii + 1], inputX2 = inputVertices[ii + 2], inputY2 = inputVertices[ii + 3], side2 = deltaX * (inputY2 - edgeY2) - deltaY * (inputX2 - edgeX2) > 0;
            if (deltaX * (inputY - edgeY2) - deltaY * (inputX - edgeX2) > 0) {
              if (side2) {
                output.push(inputX2), output.push(inputY2);
                continue;
              }
              var c0, c2, s = (c0 = inputY2 - inputY) * (edgeX2 - edgeX) - (c2 = inputX2 - inputX) * (edgeY2 - edgeY);
              if (Math.abs(s) > 1e-6) {
                var ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / s;
                output.push(edgeX + (edgeX2 - edgeX) * ua), output.push(edgeY + (edgeY2 - edgeY) * ua);
              } else output.push(edgeX), output.push(edgeY);
            } else if (side2) {
              var c0, c2, s = (c0 = inputY2 - inputY) * (edgeX2 - edgeX) - (c2 = inputX2 - inputX) * (edgeY2 - edgeY);
              if (Math.abs(s) > 1e-6) {
                var ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / s;
                output.push(edgeX + (edgeX2 - edgeX) * ua), output.push(edgeY + (edgeY2 - edgeY) * ua);
              } else output.push(edgeX), output.push(edgeY);
              output.push(inputX2), output.push(inputY2);
            }
            clipped = true;
          }
          if (outputStart == output.length) return originalOutput.length = 0, true;
          if (output.push(output[0]), output.push(output[1]), i == clippingVerticesLast) break;
          var temp = output;
          (output = input).length = 0, input = temp;
        }
        if (originalOutput != output) {
          originalOutput.length = 0;
          for (var i = 0, n = output.length - 2; i < n; i++) originalOutput[i] = output[i];
        } else originalOutput.length = originalOutput.length - 2;
        return clipped;
      }, SkeletonClipping2.makeClockwise = function(polygon) {
        for (var vertices = polygon, verticeslength = polygon.length, area = vertices[verticeslength - 2] * vertices[1] - vertices[0] * vertices[verticeslength - 1], p1x = 0, p1y = 0, p2x = 0, p2y = 0, i = 0, n = verticeslength - 3; i < n; i += 2) p1x = vertices[i], p1y = vertices[i + 1], p2x = vertices[i + 2], area += p1x * (p2y = vertices[i + 3]) - p2x * p1y;
        if (!(area < 0)) for (var i = 0, lastX = verticeslength - 2, n = verticeslength >> 1; i < n; i += 2) {
          var x = vertices[i], y = vertices[i + 1], other = lastX - i;
          vertices[i] = vertices[other], vertices[i + 1] = vertices[other + 1], vertices[other] = x, vertices[other + 1] = y;
        }
      }, SkeletonClipping2;
    })();
    spine4.SkeletonClipping = SkeletonClipping;
  })(spine || (spine = {})), (function(spine4) {
    var SkeletonData2 = (function() {
      function SkeletonData3() {
        this.bones = new Array(), this.slots = new Array(), this.skins = new Array(), this.events = new Array(), this.animations = new Array(), this.ikConstraints = new Array(), this.transformConstraints = new Array(), this.pathConstraints = new Array(), this.fps = 0;
      }
      return SkeletonData3.prototype.findBone = function(boneName) {
        if (null == boneName) throw new Error("boneName cannot be null.");
        for (var bones = this.bones, i = 0, n = bones.length; i < n; i++) {
          var bone = bones[i];
          if (bone.name == boneName) return bone;
        }
        return null;
      }, SkeletonData3.prototype.findBoneIndex = function(boneName) {
        if (null == boneName) throw new Error("boneName cannot be null.");
        for (var bones = this.bones, i = 0, n = bones.length; i < n; i++) if (bones[i].name == boneName) return i;
        return -1;
      }, SkeletonData3.prototype.findSlot = function(slotName) {
        if (null == slotName) throw new Error("slotName cannot be null.");
        for (var slots = this.slots, i = 0, n = slots.length; i < n; i++) {
          var slot = slots[i];
          if (slot.name == slotName) return slot;
        }
        return null;
      }, SkeletonData3.prototype.findSlotIndex = function(slotName) {
        if (null == slotName) throw new Error("slotName cannot be null.");
        for (var slots = this.slots, i = 0, n = slots.length; i < n; i++) if (slots[i].name == slotName) return i;
        return -1;
      }, SkeletonData3.prototype.findSkin = function(skinName) {
        if (null == skinName) throw new Error("skinName cannot be null.");
        for (var skins = this.skins, i = 0, n = skins.length; i < n; i++) {
          var skin = skins[i];
          if (skin.name == skinName) return skin;
        }
        return null;
      }, SkeletonData3.prototype.findEvent = function(eventDataName) {
        if (null == eventDataName) throw new Error("eventDataName cannot be null.");
        for (var events = this.events, i = 0, n = events.length; i < n; i++) {
          var event_5 = events[i];
          if (event_5.name == eventDataName) return event_5;
        }
        return null;
      }, SkeletonData3.prototype.findAnimation = function(animationName) {
        if (null == animationName) throw new Error("animationName cannot be null.");
        for (var animations = this.animations, i = 0, n = animations.length; i < n; i++) {
          var animation = animations[i];
          if (animation.name == animationName) return animation;
        }
        return null;
      }, SkeletonData3.prototype.findIkConstraint = function(constraintName) {
        if (null == constraintName) throw new Error("constraintName cannot be null.");
        for (var ikConstraints = this.ikConstraints, i = 0, n = ikConstraints.length; i < n; i++) {
          var constraint = ikConstraints[i];
          if (constraint.name == constraintName) return constraint;
        }
        return null;
      }, SkeletonData3.prototype.findTransformConstraint = function(constraintName) {
        if (null == constraintName) throw new Error("constraintName cannot be null.");
        for (var transformConstraints = this.transformConstraints, i = 0, n = transformConstraints.length; i < n; i++) {
          var constraint = transformConstraints[i];
          if (constraint.name == constraintName) return constraint;
        }
        return null;
      }, SkeletonData3.prototype.findPathConstraint = function(constraintName) {
        if (null == constraintName) throw new Error("constraintName cannot be null.");
        for (var pathConstraints = this.pathConstraints, i = 0, n = pathConstraints.length; i < n; i++) {
          var constraint = pathConstraints[i];
          if (constraint.name == constraintName) return constraint;
        }
        return null;
      }, SkeletonData3.prototype.findPathConstraintIndex = function(pathConstraintName) {
        if (null == pathConstraintName) throw new Error("pathConstraintName cannot be null.");
        for (var pathConstraints = this.pathConstraints, i = 0, n = pathConstraints.length; i < n; i++) if (pathConstraints[i].name == pathConstraintName) return i;
        return -1;
      }, SkeletonData3;
    })();
    spine4.SkeletonData = SkeletonData2;
  })(spine || (spine = {})), (function(spine4) {
    var SkeletonJson = (function() {
      function SkeletonJson2(attachmentLoader) {
        this.scale = 1, this.linkedMeshes = new Array(), this.attachmentLoader = attachmentLoader;
      }
      return SkeletonJson2.prototype.readSkeletonData = function(json) {
        var scale = this.scale, skeletonData2 = new spine4.SkeletonData(), root = "string" == typeof json ? JSON.parse(json) : json, SkeletonMap = root.skeleton;
        if (null != SkeletonMap && (skeletonData2.hash = SkeletonMap.hash, skeletonData2.version = SkeletonMap.spine, skeletonData2.x = SkeletonMap.x, skeletonData2.y = SkeletonMap.y, skeletonData2.width = SkeletonMap.width, skeletonData2.height = SkeletonMap.height, skeletonData2.fps = SkeletonMap.fps, skeletonData2.imagesPath = SkeletonMap.images), root.bones) for (var i = 0; i < root.bones.length; i++) {
          var boneMap = root.bones[i], parent_5 = null, parentName = this.getValue(boneMap, "parent", null), data;
          if (null != parentName && null == (parent_5 = skeletonData2.findBone(parentName))) throw new Error("Parent bone not found: " + parentName);
          (data = new spine4.BoneData(skeletonData2.bones.length, boneMap.name, parent_5)).length = this.getValue(boneMap, "length", 0) * scale, data.x = this.getValue(boneMap, "x", 0) * scale, data.y = this.getValue(boneMap, "y", 0) * scale, data.rotation = this.getValue(boneMap, "rotation", 0), data.scaleX = this.getValue(boneMap, "scaleX", 1), data.scaleY = this.getValue(boneMap, "scaleY", 1), data.shearX = this.getValue(boneMap, "shearX", 0), data.shearY = this.getValue(boneMap, "shearY", 0), data.transformMode = SkeletonJson2.transformModeFromString(this.getValue(boneMap, "transform", "normal")), data.skinRequired = this.getValue(boneMap, "skin", false), skeletonData2.bones.push(data);
        }
        if (root.slots) for (var i = 0; i < root.slots.length; i++) {
          var slotMap, slotName = (slotMap = root.slots[i]).name, boneName = slotMap.bone, boneData = skeletonData2.findBone(boneName);
          if (null == boneData) throw new Error("Slot bone not found: " + boneName);
          var data = new spine4.SlotData(skeletonData2.slots.length, slotName, boneData), color = this.getValue(slotMap, "color", null);
          null != color && data.color.setFromString(color);
          var dark = this.getValue(slotMap, "dark", null);
          null != dark && (data.darkColor = new spine4.Color(1, 1, 1, 1), data.darkColor.setFromString(dark)), data.attachmentName = this.getValue(slotMap, "attachment", null), data.blendMode = SkeletonJson2.blendModeFromString(this.getValue(slotMap, "blend", "normal")), skeletonData2.slots.push(data);
        }
        if (root.ik) for (var i = 0; i < root.ik.length; i++) {
          var constraintMap = root.ik[i], data;
          (data = new spine4.IkConstraintData(constraintMap.name)).order = this.getValue(constraintMap, "order", 0), data.skinRequired = this.getValue(constraintMap, "skin", false);
          for (var j = 0; j < constraintMap.bones.length; j++) {
            var boneName = constraintMap.bones[j], bone;
            if (null == (bone = SkeletonData.findBone(boneName))) throw new Error("IK bone not found: " + boneName);
            data.bones.push(bone);
          }
          var targetName = constraintMap.target;
          if (data.target = SkeletonData.findBone(targetName), null == data.target) throw new Error("IK target bone not found: " + targetName);
          data.mix = this.getValue(constraintMap, "mix", 1), data.softness = this.getValue(constraintMap, "softness", 0) * scale, data.bendDirection = this.getValue(constraintMap, "bendPositive", true) ? 1 : -1, data.compress = this.getValue(constraintMap, "compress", false), data.stretch = this.getValue(constraintMap, "stretch", false), data.uniform = this.getValue(constraintMap, "uniform", false), skeletonData2.ikConstraints.push(data);
        }
        if (root.transform) for (var i = 0; i < root.transform.length; i++) {
          var constraintMap = root.transform[i], data;
          (data = new spine4.TransformConstraintData(constraintMap.name)).order = this.getValue(constraintMap, "order", 0), data.skinRequired = this.getValue(constraintMap, "skin", false);
          for (var j = 0; j < constraintMap.bones.length; j++) {
            var boneName = constraintMap.bones[j], bone;
            if (null == (bone = SkeletonData.findBone(boneName))) throw new Error("Transform constraint bone not found: " + boneName);
            data.bones.push(bone);
          }
          var targetName = constraintMap.target;
          if (data.target = SkeletonData.findBone(targetName), null == data.target) throw new Error("Transform constraint target bone not found: " + targetName);
          data.local = this.getValue(constraintMap, "local", false), data.relative = this.getValue(constraintMap, "relative", false), data.offsetRotation = this.getValue(constraintMap, "rotation", 0), data.offsetX = this.getValue(constraintMap, "x", 0) * scale, data.offsetY = this.getValue(constraintMap, "y", 0) * scale, data.offsetScaleX = this.getValue(constraintMap, "scaleX", 0), data.offsetScaleY = this.getValue(constraintMap, "scaleY", 0), data.offsetShearY = this.getValue(constraintMap, "shearY", 0), data.rotateMix = this.getValue(constraintMap, "rotateMix", 1), data.translateMix = this.getValue(constraintMap, "translateMix", 1), data.scaleMix = this.getValue(constraintMap, "scaleMix", 1), data.shearMix = this.getValue(constraintMap, "shearMix", 1), skeletonData2.transformConstraints.push(data);
        }
        if (root.path) for (var i = 0; i < root.path.length; i++) {
          var constraintMap = root.path[i], data;
          (data = new spine4.PathConstraintData(constraintMap.name)).order = this.getValue(constraintMap, "order", 0), data.skinRequired = this.getValue(constraintMap, "skin", false);
          for (var j = 0; j < constraintMap.bones.length; j++) {
            var boneName = constraintMap.bones[j], bone;
            if (null == (bone = SkeletonData.findBone(boneName))) throw new Error("Transform constraint bone not found: " + boneName);
            data.bones.push(bone);
          }
          var targetName = constraintMap.target;
          if (data.target = SkeletonData.findSlot(targetName), null == data.target) throw new Error("Path target slot not found: " + targetName);
          data.positionMode = SkeletonJson2.positionModeFromString(this.getValue(constraintMap, "positionMode", "percent")), data.spacingMode = SkeletonJson2.spacingModeFromString(this.getValue(constraintMap, "spacingMode", "length")), data.rotateMode = SkeletonJson2.rotateModeFromString(this.getValue(constraintMap, "rotateMode", "tangent")), data.offsetRotation = this.getValue(constraintMap, "rotation", 0), data.position = this.getValue(constraintMap, "position", 0), data.positionMode == spine4.PositionMode.Fixed && (data.position *= scale), data.spacing = this.getValue(constraintMap, "spacing", 0), data.spacingMode != spine4.SpacingMode.Length && data.spacingMode != spine4.SpacingMode.Fixed || (data.spacing *= scale), data.rotateMix = this.getValue(constraintMap, "rotateMix", 1), data.translateMix = this.getValue(constraintMap, "translateMix", 1), skeletonData2.pathConstraints.push(data);
        }
        if (root.skins) for (var i = 0; i < root.skins.length; i++) {
          var skinMap = root.skins[i], skin = new spine4.Skin(skinMap.name);
          if (skinMap.bones) for (var ii = 0; ii < skinMap.bones.length; ii++) {
            var bone;
            if (null == (bone = SkeletonData.findBone(skinMap.bones[ii]))) throw new Error("Skin bone not found: " + skinMap.bones[i]);
            skin.bones.push(bone);
          }
          if (skinMap.ik) for (var ii = 0; ii < skinMap.ik.length; ii++) {
            var constraint;
            if (null == (constraint = SkeletonData.findIkConstraint(skinMap.ik[ii]))) throw new Error("Skin IK constraint not found: " + skinMap.ik[i]);
            skin.constraints.push(constraint);
          }
          if (skinMap.transform) for (var ii = 0; ii < skinMap.transform.length; ii++) {
            var constraint;
            if (null == (constraint = SkeletonData.findTransformConstraint(skinMap.transform[ii]))) throw new Error("Skin transform constraint not found: " + skinMap.transform[i]);
            skin.constraints.push(constraint);
          }
          if (skinMap.path) for (var ii = 0; ii < skinMap.path.length; ii++) {
            var constraint;
            if (null == (constraint = SkeletonData.findPathConstraint(skinMap.path[ii]))) throw new Error("Skin path constraint not found: " + skinMap.path[i]);
            skin.constraints.push(constraint);
          }
          for (var slotName in skinMap.attachments) {
            var slot = SkeletonData.findSlot(slotName);
            if (null == slot) throw new Error("Slot not found: " + slotName);
            var slotMap = skinMap.attachments[slotName];
            for (var entryName in slotMap) {
              var attachment = this.readAttachment(slotMap[entryName], skin, slot.index, entryName, SkeletonData);
              null != attachment && skin.setAttachment(slot.index, entryName, attachment);
            }
          }
          skeletonData2.skins.push(skin), "default" == skin.name && (skeletonData2.defaultSkin = skin);
        }
        for (var i = 0, n = this.linkedMeshes.length; i < n; i++) {
          var linkedMesh = this.linkedMeshes[i], skin;
          if (null == (skin = null == linkedMesh.skin ? SkeletonData.defaultSkin : SkeletonData.findSkin(linkedMesh.skin))) throw new Error("Skin not found: " + linkedMesh.skin);
          var parent_6 = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
          if (null == parent_6) throw new Error("Parent mesh not found: " + linkedMesh.parent);
          linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? parent_6 : linkedMesh.mesh, linkedMesh.mesh.setParentMesh(parent_6), linkedMesh.mesh.updateUVs();
        }
        if (this.linkedMeshes.length = 0, root.events) for (var eventName in root.events) {
          var eventMap = root.events[eventName], data;
          (data = new spine4.EventData(eventName)).intValue = this.getValue(eventMap, "int", 0), data.floatValue = this.getValue(eventMap, "float", 0), data.stringValue = this.getValue(eventMap, "string", ""), data.audioPath = this.getValue(eventMap, "audio", null), null != data.audioPath && (data.volume = this.getValue(eventMap, "volume", 1), data.balance = this.getValue(eventMap, "balance", 0)), skeletonData2.events.push(data);
        }
        if (root.animations) for (var animationName in root.animations) {
          var animationMap = root.animations[animationName];
          this.readAnimation(animationMap, animationName, SkeletonData);
        }
        return SkeletonData;
      }, SkeletonJson2.prototype.readAttachment = function(map, skin, slotIndex, name, SkeletonData2) {
        var scale = this.scale;
        switch (name = this.getValue(map, "name", name), this.getValue(map, "type", "region")) {
          case "region":
            var path = this.getValue(map, "path", name), region = this.attachmentLoader.newRegionAttachment(skin, name, path), color;
            return null == region ? null : (region.path = path, region.x = this.getValue(map, "x", 0) * scale, region.y = this.getValue(map, "y", 0) * scale, region.scaleX = this.getValue(map, "scaleX", 1), region.scaleY = this.getValue(map, "scaleY", 1), region.rotation = this.getValue(map, "rotation", 0), region.width = map.width * scale, region.height = map.height * scale, null != (color = this.getValue(map, "color", null)) && region.color.setFromString(color), region.updateOffset(), region);
          case "boundingbox":
            var box = this.attachmentLoader.newBoundingBoxAttachment(skin, name), color;
            return null == box ? null : (this.readVertices(map, box, map.vertexCount << 1), null != (color = this.getValue(map, "color", null)) && box.color.setFromString(color), box);
          case "mesh":
          case "linkedmesh":
            var path = this.getValue(map, "path", name), mesh = this.attachmentLoader.newMeshAttachment(skin, name, path), color;
            if (null == mesh) return null;
            mesh.path = path, null != (color = this.getValue(map, "color", null)) && mesh.color.setFromString(color), mesh.width = this.getValue(map, "width", 0) * scale, mesh.height = this.getValue(map, "height", 0) * scale;
            var parent_7 = this.getValue(map, "parent", null);
            if (null != parent_7) return this.linkedMeshes.push(new LinkedMesh(mesh, this.getValue(map, "skin", null), slotIndex, parent_7, this.getValue(map, "deform", true))), mesh;
            var uvs = map.uvs;
            return this.readVertices(map, mesh, uvs.length), mesh.triangles = map.triangles, mesh.regionUVs = uvs, mesh.updateUVs(), mesh.edges = this.getValue(map, "edges", null), mesh.hullLength = 2 * this.getValue(map, "hull", 0), mesh;
          case "path":
            var path;
            if (null == (path = this.attachmentLoader.newPathAttachment(skin, name))) return null;
            path.closed = this.getValue(map, "closed", false), path.constantSpeed = this.getValue(map, "constantSpeed", true);
            var vertexCount = map.vertexCount, color;
            this.readVertices(map, path, vertexCount << 1);
            for (var lengths = spine4.Utils.newArray(vertexCount / 3, 0), i = 0; i < map.lengths.length; i++) lengths[i] = map.lengths[i] * scale;
            return path.lengths = lengths, null != (color = this.getValue(map, "color", null)) && path.color.setFromString(color), path;
          case "point":
            var point = this.attachmentLoader.newPointAttachment(skin, name), color;
            return null == point ? null : (point.x = this.getValue(map, "x", 0) * scale, point.y = this.getValue(map, "y", 0) * scale, point.rotation = this.getValue(map, "rotation", 0), null != (color = this.getValue(map, "color", null)) && point.color.setFromString(color), point);
          case "clipping":
            var clip = this.attachmentLoader.newClippingAttachment(skin, name);
            if (null == clip) return null;
            var end = this.getValue(map, "end", null);
            if (null != end) {
              var slot = SkeletonData2.findSlot(end);
              if (null == slot) throw new Error("Clipping end slot not found: " + end);
              clip.endSlot = slot;
            }
            var vertexCount = map.vertexCount, color;
            return this.readVertices(map, clip, vertexCount << 1), null != (color = this.getValue(map, "color", null)) && clip.color.setFromString(color), clip;
        }
        return null;
      }, SkeletonJson2.prototype.readVertices = function(map, attachment, verticesLength) {
        var scale = this.scale;
        attachment.worldVerticesLength = verticesLength;
        var vertices = map.vertices;
        if (verticesLength != vertices.length) {
          for (var weights = new Array(), bones = new Array(), i = 0, n = vertices.length; i < n; ) {
            var boneCount = vertices[i++];
            bones.push(boneCount);
            for (var nn = i + 4 * boneCount; i < nn; i += 4) bones.push(vertices[i]), weights.push(vertices[i + 1] * scale), weights.push(vertices[i + 2] * scale), weights.push(vertices[i + 3]);
          }
          attachment.bones = bones, attachment.vertices = spine4.Utils.toFloatArray(weights);
        } else {
          var scaledVertices = spine4.Utils.toFloatArray(vertices);
          if (1 != scale) for (var i = 0, n = vertices.length; i < n; i++) scaledVertices[i] *= scale;
          attachment.vertices = scaledVertices;
        }
      }, SkeletonJson2.prototype.readAnimation = function(map, name, SkeletonData2) {
        var scale = this.scale, timelines = new Array(), duration = 0;
        if (map.slots) for (var slotName in map.slots) {
          var slotMap = map.slots[slotName], slotIndex;
          if (-1 == (slotIndex = SkeletonData2.findSlotIndex(slotName))) throw new Error("Slot not found: " + slotName);
          for (var timelineName in slotMap) {
            var timelineMap = slotMap[timelineName];
            if ("attachment" == timelineName) {
              var timeline;
              (timeline = new spine4.AttachmentTimeline(timelineMap.length)).slotIndex = slotIndex;
              for (var frameIndex = 0, i = 0; i < timelineMap.length; i++) {
                var valueMap = timelineMap[i];
                timeline.setFrame(frameIndex++, this.getValue(valueMap, "time", 0), valueMap.name);
              }
              timelines.push(timeline), duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
            } else if ("color" == timelineName) {
              var timeline;
              (timeline = new spine4.ColorTimeline(timelineMap.length)).slotIndex = slotIndex;
              for (var frameIndex = 0, i = 0; i < timelineMap.length; i++) {
                var valueMap = timelineMap[i], color = new spine4.Color();
                color.setFromString(valueMap.color), timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), color.r, color.g, color.b, color.a), this.readCurve(valueMap, timeline, frameIndex), frameIndex++;
              }
              timelines.push(timeline), duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine4.ColorTimeline.ENTRIES]);
            } else {
              if ("twoColor" != timelineName) throw new Error("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");
              var timeline;
              (timeline = new spine4.TwoColorTimeline(timelineMap.length)).slotIndex = slotIndex;
              for (var frameIndex = 0, i = 0; i < timelineMap.length; i++) {
                var valueMap = timelineMap[i], light = new spine4.Color(), dark = new spine4.Color();
                light.setFromString(valueMap.light), dark.setFromString(valueMap.dark), timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b), this.readCurve(valueMap, timeline, frameIndex), frameIndex++;
              }
              timelines.push(timeline), duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine4.TwoColorTimeline.ENTRIES]);
            }
          }
        }
        if (map.bones) for (var boneName in map.bones) {
          var boneMap = map.bones[boneName], boneIndex = SkeletonData2.findBoneIndex(boneName);
          if (-1 == boneIndex) throw new Error("Bone not found: " + boneName);
          for (var timelineName in boneMap) {
            var timelineMap = boneMap[timelineName];
            if ("rotate" === timelineName) {
              var timeline;
              (timeline = new spine4.RotateTimeline(timelineMap.length)).boneIndex = boneIndex;
              for (var frameIndex = 0, i = 0; i < timelineMap.length; i++) {
                var valueMap = timelineMap[i];
                timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), this.getValue(valueMap, "angle", 0)), this.readCurve(valueMap, timeline, frameIndex), frameIndex++;
              }
              timelines.push(timeline), duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine4.RotateTimeline.ENTRIES]);
            } else {
              if ("translate" !== timelineName && "scale" !== timelineName && "shear" !== timelineName) throw new Error("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");
              var timeline = null, timelineScale = 1, defaultValue = 0;
              "scale" === timelineName ? (timeline = new spine4.ScaleTimeline(timelineMap.length), defaultValue = 1) : "shear" === timelineName ? timeline = new spine4.ShearTimeline(timelineMap.length) : (timeline = new spine4.TranslateTimeline(timelineMap.length), timelineScale = scale), timeline.boneIndex = boneIndex;
              for (var frameIndex = 0, i = 0; i < timelineMap.length; i++) {
                var valueMap = timelineMap[i], x = this.getValue(valueMap, "x", defaultValue), y = this.getValue(valueMap, "y", defaultValue);
                timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), x * timelineScale, y * timelineScale), this.readCurve(valueMap, timeline, frameIndex), frameIndex++;
              }
              timelines.push(timeline), duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine4.TranslateTimeline.ENTRIES]);
            }
          }
        }
        if (map.ik) for (var constraintName in map.ik) {
          var constraintMap = map.ik[constraintName], constraint = SkeletonData2.findIkConstraint(constraintName), timeline;
          (timeline = new spine4.IkConstraintTimeline(constraintMap.length)).ikConstraintIndex = SkeletonData2.ikConstraints.indexOf(constraint);
          for (var frameIndex = 0, i = 0; i < constraintMap.length; i++) {
            var valueMap = constraintMap[i];
            timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), this.getValue(valueMap, "mix", 1), this.getValue(valueMap, "softness", 0) * scale, this.getValue(valueMap, "bendPositive", true) ? 1 : -1, this.getValue(valueMap, "compress", false), this.getValue(valueMap, "stretch", false)), this.readCurve(valueMap, timeline, frameIndex), frameIndex++;
          }
          timelines.push(timeline), duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine4.IkConstraintTimeline.ENTRIES]);
        }
        if (map.transform) for (var constraintName in map.transform) {
          var constraintMap = map.transform[constraintName], constraint = SkeletonData2.findTransformConstraint(constraintName), timeline;
          (timeline = new spine4.TransformConstraintTimeline(constraintMap.length)).transformConstraintIndex = SkeletonData2.transformConstraints.indexOf(constraint);
          for (var frameIndex = 0, i = 0; i < constraintMap.length; i++) {
            var valueMap = constraintMap[i];
            timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), this.getValue(valueMap, "rotateMix", 1), this.getValue(valueMap, "translateMix", 1), this.getValue(valueMap, "scaleMix", 1), this.getValue(valueMap, "shearMix", 1)), this.readCurve(valueMap, timeline, frameIndex), frameIndex++;
          }
          timelines.push(timeline), duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine4.TransformConstraintTimeline.ENTRIES]);
        }
        if (map.path) for (var constraintName in map.path) {
          var constraintMap = map.path[constraintName], index = SkeletonData2.findPathConstraintIndex(constraintName);
          if (-1 == index) throw new Error("Path constraint not found: " + constraintName);
          var data = SkeletonData2.pathConstraints[index];
          for (var timelineName in constraintMap) {
            var timelineMap = constraintMap[timelineName];
            if ("position" === timelineName || "spacing" === timelineName) {
              var timeline = null, timelineScale = 1;
              "spacing" === timelineName ? (timeline = new spine4.PathConstraintSpacingTimeline(timelineMap.length), data.spacingMode != spine4.SpacingMode.Length && data.spacingMode != spine4.SpacingMode.Fixed || (timelineScale = scale)) : (timeline = new spine4.PathConstraintPositionTimeline(timelineMap.length), data.positionMode == spine4.PositionMode.Fixed && (timelineScale = scale)), timeline.pathConstraintIndex = index;
              for (var frameIndex = 0, i = 0; i < timelineMap.length; i++) {
                var valueMap = timelineMap[i];
                timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), this.getValue(valueMap, timelineName, 0) * timelineScale), this.readCurve(valueMap, timeline, frameIndex), frameIndex++;
              }
              timelines.push(timeline), duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine4.PathConstraintPositionTimeline.ENTRIES]);
            } else if ("mix" === timelineName) {
              var timeline;
              (timeline = new spine4.PathConstraintMixTimeline(timelineMap.length)).pathConstraintIndex = index;
              for (var frameIndex = 0, i = 0; i < timelineMap.length; i++) {
                var valueMap = timelineMap[i];
                timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), this.getValue(valueMap, "rotateMix", 1), this.getValue(valueMap, "translateMix", 1)), this.readCurve(valueMap, timeline, frameIndex), frameIndex++;
              }
              timelines.push(timeline), duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine4.PathConstraintMixTimeline.ENTRIES]);
            }
          }
        }
        if (map.deform) for (var deformName in map.deform) {
          var deformMap = map.deform[deformName], skin = SkeletonData2.findSkin(deformName);
          if (null == skin) throw new Error("Skin not found: " + deformName);
          for (var slotName in deformMap) {
            var slotMap = deformMap[slotName], slotIndex;
            if (-1 == (slotIndex = SkeletonData2.findSlotIndex(slotName))) throw new Error("Slot not found: " + slotMap.name);
            for (var timelineName in slotMap) {
              var timelineMap = slotMap[timelineName], attachment = skin.getAttachment(slotIndex, timelineName);
              if (null == attachment) throw new Error("Deform attachment not found: " + timelineMap.name);
              var weighted = null != attachment.bones, vertices = attachment.vertices, deformLength = weighted ? vertices.length / 3 * 2 : vertices.length, timeline;
              (timeline = new spine4.DeformTimeline(timelineMap.length)).slotIndex = slotIndex, timeline.attachment = attachment;
              for (var frameIndex = 0, j = 0; j < timelineMap.length; j++) {
                var valueMap = timelineMap[j], deform = void 0, verticesValue = this.getValue(valueMap, "vertices", null);
                if (null == verticesValue) deform = weighted ? spine4.Utils.newFloatArray(deformLength) : vertices;
                else {
                  deform = spine4.Utils.newFloatArray(deformLength);
                  var start = this.getValue(valueMap, "offset", 0);
                  if (spine4.Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length), 1 != scale) for (var i, n = (i = start) + verticesValue.length; i < n; i++) deform[i] *= scale;
                  if (!weighted) for (var i = 0; i < deformLength; i++) deform[i] += vertices[i];
                }
                timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), deform), this.readCurve(valueMap, timeline, frameIndex), frameIndex++;
              }
              timelines.push(timeline), duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
            }
          }
        }
        var drawOrderNode = map.drawOrder;
        if (null == drawOrderNode && (drawOrderNode = map.draworder), null != drawOrderNode) {
          for (var timeline = new spine4.DrawOrderTimeline(drawOrderNode.length), slotCount = SkeletonData2.slots.length, frameIndex = 0, j = 0; j < drawOrderNode.length; j++) {
            var drawOrderMap = drawOrderNode[j], drawOrder = null, offsets = this.getValue(drawOrderMap, "offsets", null);
            if (null != offsets) {
              drawOrder = spine4.Utils.newArray(slotCount, -1);
              for (var unchanged = spine4.Utils.newArray(slotCount - offsets.length, 0), originalIndex = 0, unchangedIndex = 0, i = 0; i < offsets.length; i++) {
                var offsetMap = offsets[i], slotIndex;
                if (-1 == (slotIndex = SkeletonData2.findSlotIndex(offsetMap.slot))) throw new Error("Slot not found: " + offsetMap.slot);
                for (; originalIndex != slotIndex; ) unchanged[unchangedIndex++] = originalIndex++;
                drawOrder[originalIndex + offsetMap.offset] = originalIndex++;
              }
              for (; originalIndex < slotCount; ) unchanged[unchangedIndex++] = originalIndex++;
              for (var i = slotCount - 1; i >= 0; i--) -1 == drawOrder[i] && (drawOrder[i] = unchanged[--unchangedIndex]);
            }
            timeline.setFrame(frameIndex++, this.getValue(drawOrderMap, "time", 0), drawOrder);
          }
          timelines.push(timeline), duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
        }
        if (map.events) {
          for (var timeline = new spine4.EventTimeline(map.events.length), frameIndex = 0, i = 0; i < map.events.length; i++) {
            var eventMap = map.events[i], eventData = SkeletonData2.findEvent(eventMap.name);
            if (null == eventData) throw new Error("Event not found: " + eventMap.name);
            var event_6 = new spine4.Event(spine4.Utils.toSinglePrecision(this.getValue(eventMap, "time", 0)), eventData);
            event_6.intValue = this.getValue(eventMap, "int", eventData.intValue), event_6.floatValue = this.getValue(eventMap, "float", eventData.floatValue), event_6.stringValue = this.getValue(eventMap, "string", eventData.stringValue), null != event_6.data.audioPath && (event_6.volume = this.getValue(eventMap, "volume", 1), event_6.balance = this.getValue(eventMap, "balance", 0)), timeline.setFrame(frameIndex++, event_6);
          }
          timelines.push(timeline), duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
        }
        if (isNaN(duration)) throw new Error("Error while parsing animation, duration is NaN");
        skeletonData.animations.push(new spine4.Animation(name, timelines, duration));
      }, SkeletonJson2.prototype.readCurve = function(map, timeline, frameIndex) {
        if (map.hasOwnProperty("curve")) if ("stepped" == map.curve) timeline.setStepped(frameIndex);
        else {
          var curve = map.curve;
          timeline.setCurve(frameIndex, curve, this.getValue(map, "c2", 0), this.getValue(map, "c3", 1), this.getValue(map, "c4", 1));
        }
      }, SkeletonJson2.prototype.getValue = function(map, prop, defaultValue) {
        return void 0 !== map[prop] ? map[prop] : defaultValue;
      }, SkeletonJson2.blendModeFromString = function(str) {
        if ("normal" == (str = str.toLowerCase())) return spine4.BlendMode.Normal;
        if ("additive" == str) return spine4.BlendMode.Additive;
        if ("multiply" == str) return spine4.BlendMode.Multiply;
        if ("screen" == str) return spine4.BlendMode.Screen;
        throw new Error("Unknown blend mode: " + str);
      }, SkeletonJson2.positionModeFromString = function(str) {
        if ("fixed" == (str = str.toLowerCase())) return spine4.PositionMode.Fixed;
        if ("percent" == str) return spine4.PositionMode.Percent;
        throw new Error("Unknown position mode: " + str);
      }, SkeletonJson2.spacingModeFromString = function(str) {
        if ("length" == (str = str.toLowerCase())) return spine4.SpacingMode.Length;
        if ("fixed" == str) return spine4.SpacingMode.Fixed;
        if ("percent" == str) return spine4.SpacingMode.Percent;
        throw new Error("Unknown position mode: " + str);
      }, SkeletonJson2.rotateModeFromString = function(str) {
        if ("tangent" == (str = str.toLowerCase())) return spine4.RotateMode.Tangent;
        if ("chain" == str) return spine4.RotateMode.Chain;
        if ("chainscale" == str) return spine4.RotateMode.ChainScale;
        throw new Error("Unknown rotate mode: " + str);
      }, SkeletonJson2.transformModeFromString = function(str) {
        if ("normal" == (str = str.toLowerCase())) return spine4.TransformMode.Normal;
        if ("onlytranslation" == str) return spine4.TransformMode.OnlyTranslation;
        if ("norotationorreflection" == str) return spine4.TransformMode.NoRotationOrReflection;
        if ("noscale" == str) return spine4.TransformMode.NoScale;
        if ("noscaleorreflection" == str) return spine4.TransformMode.NoScaleOrReflection;
        throw new Error("Unknown transform mode: " + str);
      }, SkeletonJson2;
    })();
    spine4.SkeletonJson = SkeletonJson;
    var LinkedMesh = /* @__PURE__ */ (function() {
      function LinkedMesh2(mesh, skin, slotIndex, parent, inheritDeform) {
        this.mesh = mesh, this.skin = skin, this.slotIndex = slotIndex, this.parent = parent, this.inheritDeform = inheritDeform;
      }
      return LinkedMesh2;
    })();
  })(spine || (spine = {})), (function(spine4) {
    var SkinEntry = /* @__PURE__ */ (function() {
      function SkinEntry2(slotIndex, name, attachment) {
        this.slotIndex = slotIndex, this.name = name, this.attachment = attachment;
      }
      return SkinEntry2;
    })();
    spine4.SkinEntry = SkinEntry;
    var Skin2 = (function() {
      function Skin3(name) {
        if (this.attachments = new Array(), this.bones = Array(), this.constraints = new Array(), null == name) throw new Error("name cannot be null.");
        this.name = name;
      }
      return Skin3.prototype.setAttachment = function(slotIndex, name, attachment) {
        if (null == attachment) throw new Error("attachment cannot be null.");
        var attachments = this.attachments;
        slotIndex >= attachments.length && (attachments.length = slotIndex + 1), attachments[slotIndex] || (attachments[slotIndex] = {}), attachments[slotIndex][name] = attachment;
      }, Skin3.prototype.addSkin = function(skin) {
        for (var i = 0; i < skin.bones.length; i++) {
          for (var bone = skin.bones[i], contained = false, j = 0; j < this.bones.length; j++) if (this.bones[j] == bone) {
            contained = true;
            break;
          }
          contained || this.bones.push(bone);
        }
        for (var i = 0; i < skin.constraints.length; i++) {
          for (var constraint = skin.constraints[i], contained = false, j = 0; j < this.constraints.length; j++) if (this.constraints[j] == constraint) {
            contained = true;
            break;
          }
          contained || this.constraints.push(constraint);
        }
        for (var attachments = skin.getAttachments(), i = 0; i < attachments.length; i++) {
          var attachment = attachments[i];
          this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
        }
      }, Skin3.prototype.copySkin = function(skin) {
        for (var i = 0; i < skin.bones.length; i++) {
          for (var bone = skin.bones[i], contained = false, j = 0; j < this.bones.length; j++) if (this.bones[j] == bone) {
            contained = true;
            break;
          }
          contained || this.bones.push(bone);
        }
        for (var i = 0; i < skin.constraints.length; i++) {
          for (var constraint = skin.constraints[i], contained = false, j = 0; j < this.constraints.length; j++) if (this.constraints[j] == constraint) {
            contained = true;
            break;
          }
          contained || this.constraints.push(constraint);
        }
        for (var attachments = skin.getAttachments(), i = 0; i < attachments.length; i++) {
          var attachment = attachments[i];
          null != attachment.attachment && (attachment.attachment instanceof spine4.MeshAttachment ? (attachment.attachment = attachment.attachment.newLinkedMesh(), this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment)) : (attachment.attachment = attachment.attachment.copy(), this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment)));
        }
      }, Skin3.prototype.getAttachment = function(slotIndex, name) {
        var dictionary = this.attachments[slotIndex];
        return dictionary ? dictionary[name] : null;
      }, Skin3.prototype.removeAttachment = function(slotIndex, name) {
        var dictionary = this.attachments[slotIndex];
        dictionary && (dictionary[name] = null);
      }, Skin3.prototype.getAttachments = function() {
        for (var entries = new Array(), i = 0; i < this.attachments.length; i++) {
          var slotAttachments = this.attachments[i];
          if (slotAttachments) for (var name_4 in slotAttachments) {
            var attachment = slotAttachments[name_4];
            attachment && entries.push(new SkinEntry(i, name_4, attachment));
          }
        }
        return entries;
      }, Skin3.prototype.getAttachmentsForSlot = function(slotIndex, attachments) {
        var slotAttachments = this.attachments[slotIndex];
        if (slotAttachments) for (var name_5 in slotAttachments) {
          var attachment = slotAttachments[name_5];
          attachment && attachments.push(new SkinEntry(slotIndex, name_5, attachment));
        }
      }, Skin3.prototype.clear = function() {
        this.attachments.length = 0, this.bones.length = 0, this.constraints.length = 0;
      }, Skin3.prototype.attachAll = function(skeleton2, oldSkin) {
        for (var slotIndex = 0, i = 0; i < Skeleton.slots.length; i++) {
          var slot = Skeleton.slots[i], slotAttachment = slot.getAttachment();
          if (slotAttachment && slotIndex < oldSkin.attachments.length) {
            var dictionary = oldSkin.attachments[slotIndex];
            for (var key in dictionary) {
              if (slotAttachment == dictionary[key]) {
                var attachment = this.getAttachment(slotIndex, key);
                null != attachment && slot.setAttachment(attachment);
                break;
              }
            }
          }
          slotIndex++;
        }
      }, Skin3;
    })();
    spine4.Skin = Skin2;
  })(spine || (spine = {})), (function(spine4) {
    var Slot = (function() {
      function Slot2(data, bone) {
        if (this.deform = new Array(), null == data) throw new Error("data cannot be null.");
        if (null == bone) throw new Error("bone cannot be null.");
        this.data = data, this.bone = bone, this.color = new spine4.Color(), this.darkColor = null == data.darkColor ? null : new spine4.Color(), this.setToSetupPose();
      }
      return Slot2.prototype.getSkeleton = function() {
        return this.bone.skeleton;
      }, Slot2.prototype.getAttachment = function() {
        return this.attachment;
      }, Slot2.prototype.setAttachment = function(attachment) {
        this.attachment != attachment && (this.attachment = attachment, this.attachmentTime = this.bone.skeleton.time, this.deform.length = 0);
      }, Slot2.prototype.setAttachmentTime = function(time) {
        this.attachmentTime = this.bone.skeleton.time - time;
      }, Slot2.prototype.getAttachmentTime = function() {
        return this.bone.skeleton.time - this.attachmentTime;
      }, Slot2.prototype.setToSetupPose = function() {
        this.color.setFromColor(this.data.color), null != this.darkColor && this.darkColor.setFromColor(this.data.darkColor), null == this.data.attachmentName ? this.attachment = null : (this.attachment = null, this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName)));
      }, Slot2;
    })();
    spine4.Slot = Slot;
  })(spine || (spine = {})), (function(spine4) {
    var SlotData = /* @__PURE__ */ (function() {
      function SlotData2(index, name, boneData) {
        if (this.color = new spine4.Color(1, 1, 1, 1), index < 0) throw new Error("index must be >= 0.");
        if (null == name) throw new Error("name cannot be null.");
        if (null == boneData) throw new Error("boneData cannot be null.");
        this.index = index, this.name = name, this.boneData = boneData;
      }
      return SlotData2;
    })();
    spine4.SlotData = SlotData;
  })(spine || (spine = {})), (function(spine4) {
    var Texture = (function() {
      function Texture2(image) {
        this._image = image;
      }
      return Texture2.prototype.getImage = function() {
        return this._image;
      }, Texture2.filterFromString = function(text) {
        switch (text.toLowerCase()) {
          case "nearest":
            return TextureFilter.Nearest;
          case "linear":
            return TextureFilter.Linear;
          case "mipmap":
            return TextureFilter.MipMap;
          case "mipmapnearestnearest":
            return TextureFilter.MipMapNearestNearest;
          case "mipmaplinearnearest":
            return TextureFilter.MipMapLinearNearest;
          case "mipmapnearestlinear":
            return TextureFilter.MipMapNearestLinear;
          case "mipmaplinearlinear":
            return TextureFilter.MipMapLinearLinear;
          default:
            throw new Error("Unknown texture filter " + text);
        }
      }, Texture2.wrapFromString = function(text) {
        switch (text.toLowerCase()) {
          case "mirroredtepeat":
            return TextureWrap.MirroredRepeat;
          case "clamptoedge":
            return TextureWrap.ClampToEdge;
          case "repeat":
            return TextureWrap.Repeat;
          default:
            throw new Error("Unknown texture wrap " + text);
        }
      }, Texture2;
    })(), TextureFilter, TextureWrap;
    spine4.Texture = Texture, (function(TextureFilter2) {
      TextureFilter2[TextureFilter2.Nearest = 9728] = "Nearest", TextureFilter2[TextureFilter2.Linear = 9729] = "Linear", TextureFilter2[TextureFilter2.MipMap = 9987] = "MipMap", TextureFilter2[TextureFilter2.MipMapNearestNearest = 9984] = "MipMapNearestNearest", TextureFilter2[TextureFilter2.MipMapLinearNearest = 9985] = "MipMapLinearNearest", TextureFilter2[TextureFilter2.MipMapNearestLinear = 9986] = "MipMapNearestLinear", TextureFilter2[TextureFilter2.MipMapLinearLinear = 9987] = "MipMapLinearLinear";
    })(TextureFilter = spine4.TextureFilter || (spine4.TextureFilter = {})), (function(TextureWrap2) {
      TextureWrap2[TextureWrap2.MirroredRepeat = 33648] = "MirroredRepeat", TextureWrap2[TextureWrap2.ClampToEdge = 33071] = "ClampToEdge", TextureWrap2[TextureWrap2.Repeat = 10497] = "Repeat";
    })(TextureWrap = spine4.TextureWrap || (spine4.TextureWrap = {}));
    var TextureRegion = /* @__PURE__ */ (function() {
      function TextureRegion2() {
        this.u = 0, this.v = 0, this.u2 = 0, this.v2 = 0, this.width = 0, this.height = 0, this.rotate = false, this.offsetX = 0, this.offsetY = 0, this.originalWidth = 0, this.originalHeight = 0;
      }
      return TextureRegion2;
    })();
    spine4.TextureRegion = TextureRegion;
    var FakeTexture = (function(_super) {
      function FakeTexture2() {
        return null !== _super && _super.apply(this, arguments) || this;
      }
      return __extends(FakeTexture2, _super), FakeTexture2.prototype.setFilters = function(minFilter, magFilter) {
      }, FakeTexture2.prototype.setWraps = function(uWrap, vWrap) {
      }, FakeTexture2.prototype.dispose = function() {
      }, FakeTexture2;
    })(Texture);
    spine4.FakeTexture = FakeTexture;
  })(spine || (spine = {})), (function(spine4) {
    var TextureAtlas = (function() {
      function TextureAtlas2(atlasText, textureLoader) {
        this.pages = new Array(), this.regions = new Array(), this.load(atlasText, textureLoader);
      }
      return TextureAtlas2.prototype.load = function(atlasText, textureLoader) {
        if (null == textureLoader) throw new Error("textureLoader cannot be null.");
        for (var reader = new TextureAtlasReader(atlasText), tuple = new Array(4), page = null; ; ) {
          var line = reader.readLine();
          if (null == line) break;
          if (0 == (line = line.trim()).length) page = null;
          else if (page) {
            var region = new TextureAtlasRegion();
            region.name = line, region.page = page;
            var rotateValue = reader.readValue();
            "true" == rotateValue.toLocaleLowerCase() ? region.degrees = 90 : "false" == rotateValue.toLocaleLowerCase() ? region.degrees = 0 : region.degrees = parseFloat(rotateValue), region.rotate = 90 == region.degrees, reader.readTuple(tuple);
            var x = parseInt(tuple[0]), y = parseInt(tuple[1]);
            reader.readTuple(tuple);
            var width = parseInt(tuple[0]), height = parseInt(tuple[1]);
            region.u = x / page.width, region.v = y / page.height, region.rotate ? (region.u2 = (x + height) / page.width, region.v2 = (y + width) / page.height) : (region.u2 = (x + width) / page.width, region.v2 = (y + height) / page.height), region.x = x, region.y = y, region.width = Math.abs(width), region.height = Math.abs(height), 4 == reader.readTuple(tuple) && 4 == reader.readTuple(tuple) && reader.readTuple(tuple), region.originalWidth = parseInt(tuple[0]), region.originalHeight = parseInt(tuple[1]), reader.readTuple(tuple), region.offsetX = parseInt(tuple[0]), region.offsetY = parseInt(tuple[1]), region.index = parseInt(reader.readValue()), region.texture = page.texture, this.regions.push(region);
          } else {
            (page = new TextureAtlasPage()).name = line, 2 == reader.readTuple(tuple) && (page.width = parseInt(tuple[0]), page.height = parseInt(tuple[1]), reader.readTuple(tuple)), reader.readTuple(tuple), page.minFilter = spine4.Texture.filterFromString(tuple[0]), page.magFilter = spine4.Texture.filterFromString(tuple[1]);
            var direction = reader.readValue();
            page.uWrap = spine4.TextureWrap.ClampToEdge, page.vWrap = spine4.TextureWrap.ClampToEdge, "x" == direction ? page.uWrap = spine4.TextureWrap.Repeat : "y" == direction ? page.vWrap = spine4.TextureWrap.Repeat : "xy" == direction && (page.uWrap = page.vWrap = spine4.TextureWrap.Repeat), page.texture = textureLoader(line), page.texture.setFilters(page.minFilter, page.magFilter), page.texture.setWraps(page.uWrap, page.vWrap), page.width = page.texture.getImage().width, page.height = page.texture.getImage().height, this.pages.push(page);
          }
        }
      }, TextureAtlas2.prototype.findRegion = function(name) {
        for (var i = 0; i < this.regions.length; i++) if (this.regions[i].name == name) return this.regions[i];
        return null;
      }, TextureAtlas2.prototype.dispose = function() {
        for (var i = 0; i < this.pages.length; i++) this.pages[i].texture.dispose();
      }, TextureAtlas2;
    })();
    spine4.TextureAtlas = TextureAtlas;
    var TextureAtlasReader = (function() {
      function TextureAtlasReader2(text) {
        this.index = 0, this.lines = text.split(/\r\n|\r|\n/);
      }
      return TextureAtlasReader2.prototype.readLine = function() {
        return this.index >= this.lines.length ? null : this.lines[this.index++];
      }, TextureAtlasReader2.prototype.readValue = function() {
        var line = this.readLine(), colon = line.indexOf(":");
        if (-1 == colon) throw new Error("Invalid line: " + line);
        return line.substring(colon + 1).trim();
      }, TextureAtlasReader2.prototype.readTuple = function(tuple) {
        var line = this.readLine(), colon = line.indexOf(":");
        if (-1 == colon) throw new Error("Invalid line: " + line);
        for (var i = 0, lastMatch = colon + 1; i < 3; i++) {
          var comma = line.indexOf(",", lastMatch);
          if (-1 == comma) break;
          tuple[i] = line.substr(lastMatch, comma - lastMatch).trim(), lastMatch = comma + 1;
        }
        return tuple[i] = line.substring(lastMatch).trim(), i + 1;
      }, TextureAtlasReader2;
    })(), TextureAtlasPage = /* @__PURE__ */ (function() {
      function TextureAtlasPage2() {
      }
      return TextureAtlasPage2;
    })();
    spine4.TextureAtlasPage = TextureAtlasPage;
    var TextureAtlasRegion = (function(_super) {
      function TextureAtlasRegion2() {
        return null !== _super && _super.apply(this, arguments) || this;
      }
      return __extends(TextureAtlasRegion2, _super), TextureAtlasRegion2;
    })(spine4.TextureRegion);
    spine4.TextureAtlasRegion = TextureAtlasRegion;
  })(spine || (spine = {})), (function(spine4) {
    var TransformConstraint = (function() {
      function TransformConstraint2(data, Skeleton2) {
        if (this.rotateMix = 0, this.translateMix = 0, this.scaleMix = 0, this.shearMix = 0, this.temp = new spine4.Vector2(), this.active = false, null == data) throw new Error("data cannot be null.");
        if (null == skeleton) throw new Error("skeleton cannot be null.");
        this.data = data, this.rotateMix = data.rotateMix, this.translateMix = data.translateMix, this.scaleMix = data.scaleMix, this.shearMix = data.shearMix, this.bones = new Array();
        for (var i = 0; i < data.bones.length; i++) this.bones.push(skeleton.findBone(data.bones[i].name));
        this.target = Skeleton2.findBone(data.target.name);
      }
      return TransformConstraint2.prototype.isActive = function() {
        return this.active;
      }, TransformConstraint2.prototype.apply = function() {
        this.update();
      }, TransformConstraint2.prototype.update = function() {
        this.data.local ? this.data.relative ? this.applyRelativeLocal() : this.applyAbsoluteLocal() : this.data.relative ? this.applyRelativeWorld() : this.applyAbsoluteWorld();
      }, TransformConstraint2.prototype.applyAbsoluteWorld = function() {
        for (var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix, target = this.target, ta = target.a, tb = target.b, tc = target.c, td = target.d, degRadReflect = ta * td - tb * tc > 0 ? spine4.MathUtils.degRad : -spine4.MathUtils.degRad, offsetRotation = this.data.offsetRotation * degRadReflect, offsetShearY = this.data.offsetShearY * degRadReflect, bones = this.bones, i = 0, n = bones.length; i < n; i++) {
          var bone = bones[i], modified = false;
          if (0 != rotateMix) {
            var a = bone.a, b = bone.b, c = bone.c, d = bone.d, r;
            (r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation) > spine4.MathUtils.PI ? r -= spine4.MathUtils.PI2 : r < -spine4.MathUtils.PI && (r += spine4.MathUtils.PI2), r *= rotateMix;
            var cos = Math.cos(r), sin = Math.sin(r);
            bone.a = cos * a - sin * c, bone.b = cos * b - sin * d, bone.c = sin * a + cos * c, bone.d = sin * b + cos * d, modified = true;
          }
          if (0 != translateMix) {
            var temp = this.temp;
            target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY)), bone.worldX += (temp.x - bone.worldX) * translateMix, bone.worldY += (temp.y - bone.worldY) * translateMix, modified = true;
          }
          if (scaleMix > 0) {
            var s = Math.sqrt(bone.a * bone.a + bone.c * bone.c), ts = Math.sqrt(ta * ta + tc * tc);
            s > 1e-5 && (s = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s), bone.a *= s, bone.c *= s, s = Math.sqrt(bone.b * bone.b + bone.d * bone.d), ts = Math.sqrt(tb * tb + td * td), s > 1e-5 && (s = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s), bone.b *= s, bone.d *= s, modified = true;
          }
          if (shearMix > 0) {
            var b = bone.b, d = bone.d, by = Math.atan2(d, b), r;
            (r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(bone.c, bone.a))) > spine4.MathUtils.PI ? r -= spine4.MathUtils.PI2 : r < -spine4.MathUtils.PI && (r += spine4.MathUtils.PI2), r = by + (r + offsetShearY) * shearMix;
            var s = Math.sqrt(b * b + d * d);
            bone.b = Math.cos(r) * s, bone.d = Math.sin(r) * s, modified = true;
          }
          modified && (bone.appliedValid = false);
        }
      }, TransformConstraint2.prototype.applyRelativeWorld = function() {
        for (var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix, target = this.target, ta = target.a, tb = target.b, tc = target.c, td = target.d, degRadReflect = ta * td - tb * tc > 0 ? spine4.MathUtils.degRad : -spine4.MathUtils.degRad, offsetRotation = this.data.offsetRotation * degRadReflect, offsetShearY = this.data.offsetShearY * degRadReflect, bones = this.bones, i = 0, n = bones.length; i < n; i++) {
          var bone = bones[i], modified = false;
          if (0 != rotateMix) {
            var a = bone.a, b = bone.b, c = bone.c, d = bone.d, r;
            (r = Math.atan2(tc, ta) + offsetRotation) > spine4.MathUtils.PI ? r -= spine4.MathUtils.PI2 : r < -spine4.MathUtils.PI && (r += spine4.MathUtils.PI2), r *= rotateMix;
            var cos = Math.cos(r), sin = Math.sin(r);
            bone.a = cos * a - sin * c, bone.b = cos * b - sin * d, bone.c = sin * a + cos * c, bone.d = sin * b + cos * d, modified = true;
          }
          if (0 != translateMix) {
            var temp = this.temp;
            target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY)), bone.worldX += temp.x * translateMix, bone.worldY += temp.y * translateMix, modified = true;
          }
          if (scaleMix > 0) {
            var s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;
            bone.a *= s, bone.c *= s, s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1, bone.b *= s, bone.d *= s, modified = true;
          }
          if (shearMix > 0) {
            var r;
            (r = Math.atan2(td, tb) - Math.atan2(tc, ta)) > spine4.MathUtils.PI ? r -= spine4.MathUtils.PI2 : r < -spine4.MathUtils.PI && (r += spine4.MathUtils.PI2);
            var b = bone.b, d = bone.d;
            r = Math.atan2(d, b) + (r - spine4.MathUtils.PI / 2 + offsetShearY) * shearMix;
            var s = Math.sqrt(b * b + d * d);
            bone.b = Math.cos(r) * s, bone.d = Math.sin(r) * s, modified = true;
          }
          modified && (bone.appliedValid = false);
        }
      }, TransformConstraint2.prototype.applyAbsoluteLocal = function() {
        var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix, target = this.target;
        target.appliedValid || target.updateAppliedTransform();
        for (var bones = this.bones, i = 0, n = bones.length; i < n; i++) {
          var bone = bones[i];
          bone.appliedValid || bone.updateAppliedTransform();
          var rotation = bone.arotation;
          if (0 != rotateMix) {
            var r = target.arotation - rotation + this.data.offsetRotation;
            rotation += (r -= 360 * (16384 - (16384.499999999996 - r / 360 | 0))) * rotateMix;
          }
          var x = bone.ax, y = bone.ay;
          0 != translateMix && (x += (target.ax - x + this.data.offsetX) * translateMix, y += (target.ay - y + this.data.offsetY) * translateMix);
          var scaleX = bone.ascaleX, scaleY = bone.ascaleY;
          0 != scaleMix && (scaleX > 1e-5 && (scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX), scaleY > 1e-5 && (scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY));
          var shearY = bone.ashearY;
          if (0 != shearMix) {
            var r = target.ashearY - shearY + this.data.offsetShearY;
            r -= 360 * (16384 - (16384.499999999996 - r / 360 | 0)), bone.shearY += r * shearMix;
          }
          bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
        }
      }, TransformConstraint2.prototype.applyRelativeLocal = function() {
        var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix, target = this.target;
        target.appliedValid || target.updateAppliedTransform();
        for (var bones = this.bones, i = 0, n = bones.length; i < n; i++) {
          var bone = bones[i];
          bone.appliedValid || bone.updateAppliedTransform();
          var rotation = bone.arotation;
          0 != rotateMix && (rotation += (target.arotation + this.data.offsetRotation) * rotateMix);
          var x = bone.ax, y = bone.ay;
          0 != translateMix && (x += (target.ax + this.data.offsetX) * translateMix, y += (target.ay + this.data.offsetY) * translateMix);
          var scaleX = bone.ascaleX, scaleY = bone.ascaleY;
          0 != scaleMix && (scaleX > 1e-5 && (scaleX *= (target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix + 1), scaleY > 1e-5 && (scaleY *= (target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix + 1));
          var shearY = bone.ashearY;
          0 != shearMix && (shearY += (target.ashearY + this.data.offsetShearY) * shearMix), bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
        }
      }, TransformConstraint2;
    })();
    spine4.TransformConstraint = TransformConstraint;
  })(spine || (spine = {})), (function(spine4) {
    var TransformConstraintData = (function(_super) {
      function TransformConstraintData2(name) {
        var _this = _super.call(this, name, 0, false) || this;
        return _this.bones = new Array(), _this.rotateMix = 0, _this.translateMix = 0, _this.scaleMix = 0, _this.shearMix = 0, _this.offsetRotation = 0, _this.offsetX = 0, _this.offsetY = 0, _this.offsetScaleX = 0, _this.offsetScaleY = 0, _this.offsetShearY = 0, _this.relative = false, _this.local = false, _this;
      }
      return __extends(TransformConstraintData2, _super), TransformConstraintData2;
    })(spine4.ConstraintData);
    spine4.TransformConstraintData = TransformConstraintData;
  })(spine || (spine = {})), (function(spine4) {
    var Triangulator = (function() {
      function Triangulator2() {
        this.convexPolygons = new Array(), this.convexPolygonsIndices = new Array(), this.indicesArray = new Array(), this.isConcaveArray = new Array(), this.triangles = new Array(), this.polygonPool = new spine4.Pool((function() {
          return new Array();
        })), this.polygonIndicesPool = new spine4.Pool((function() {
          return new Array();
        }));
      }
      return Triangulator2.prototype.triangulate = function(verticesArray) {
        var vertices = verticesArray, vertexCount = verticesArray.length >> 1, indices = this.indicesArray;
        indices.length = 0;
        for (var i = 0; i < vertexCount; i++) indices[i] = i;
        var isConcave = this.isConcaveArray;
        isConcave.length = 0;
        for (var i = 0, n = vertexCount; i < n; ++i) isConcave[i] = Triangulator2.isConcave(i, vertexCount, vertices, indices);
        var triangles = this.triangles;
        for (triangles.length = 0; vertexCount > 3; ) {
          for (var previous = vertexCount - 1, i = 0, next = 1; ; ) {
            outer: if (!isConcave[i]) {
              for (var p1 = indices[previous] << 1, p2 = indices[i] << 1, p3 = indices[next] << 1, p1x = vertices[p1], p1y = vertices[p1 + 1], p2x = vertices[p2], p2y = vertices[p2 + 1], p3x = vertices[p3], p3y = vertices[p3 + 1], ii = (next + 1) % vertexCount; ii != previous; ii = (ii + 1) % vertexCount) if (isConcave[ii]) {
                var v = indices[ii] << 1, vx = vertices[v], vy = vertices[v + 1];
                if (Triangulator2.positiveArea(p3x, p3y, p1x, p1y, vx, vy) && Triangulator2.positiveArea(p1x, p1y, p2x, p2y, vx, vy) && Triangulator2.positiveArea(p2x, p2y, p3x, p3y, vx, vy)) break outer;
              }
              break;
            }
            if (0 == next) {
              do {
                if (!isConcave[i]) break;
                i--;
              } while (i > 0);
              break;
            }
            previous = i, i = next, next = (next + 1) % vertexCount;
          }
          triangles.push(indices[(vertexCount + i - 1) % vertexCount]), triangles.push(indices[i]), triangles.push(indices[(i + 1) % vertexCount]), indices.splice(i, 1), isConcave.splice(i, 1);
          var previousIndex = (--vertexCount + i - 1) % vertexCount, nextIndex = i == vertexCount ? 0 : i;
          isConcave[previousIndex] = Triangulator2.isConcave(previousIndex, vertexCount, vertices, indices), isConcave[nextIndex] = Triangulator2.isConcave(nextIndex, vertexCount, vertices, indices);
        }
        return 3 == vertexCount && (triangles.push(indices[2]), triangles.push(indices[0]), triangles.push(indices[1])), triangles;
      }, Triangulator2.prototype.decompose = function(verticesArray, triangles) {
        var vertices = verticesArray, convexPolygons = this.convexPolygons;
        this.polygonPool.freeAll(convexPolygons), convexPolygons.length = 0;
        var convexPolygonsIndices = this.convexPolygonsIndices;
        this.polygonIndicesPool.freeAll(convexPolygonsIndices), convexPolygonsIndices.length = 0;
        var polygonIndices = this.polygonIndicesPool.obtain();
        polygonIndices.length = 0;
        var polygon = this.polygonPool.obtain();
        polygon.length = 0;
        for (var fanBaseIndex = -1, lastWinding = 0, i = 0, n = triangles.length; i < n; i += 3) {
          var t1 = triangles[i] << 1, t2 = triangles[i + 1] << 1, t3 = triangles[i + 2] << 1, x1 = vertices[t1], y1 = vertices[t1 + 1], x2 = vertices[t2], y2 = vertices[t2 + 1], x3 = vertices[t3], y3 = vertices[t3 + 1], merged = false;
          if (fanBaseIndex == t1) {
            var o = polygon.length - 4, winding1 = Triangulator2.winding(polygon[o], polygon[o + 1], polygon[o + 2], polygon[o + 3], x3, y3), winding2 = Triangulator2.winding(x3, y3, polygon[0], polygon[1], polygon[2], polygon[3]);
            winding1 == lastWinding && winding2 == lastWinding && (polygon.push(x3), polygon.push(y3), polygonIndices.push(t3), merged = true);
          }
          merged || (polygon.length > 0 ? (convexPolygons.push(polygon), convexPolygonsIndices.push(polygonIndices)) : (this.polygonPool.free(polygon), this.polygonIndicesPool.free(polygonIndices)), (polygon = this.polygonPool.obtain()).length = 0, polygon.push(x1), polygon.push(y1), polygon.push(x2), polygon.push(y2), polygon.push(x3), polygon.push(y3), (polygonIndices = this.polygonIndicesPool.obtain()).length = 0, polygonIndices.push(t1), polygonIndices.push(t2), polygonIndices.push(t3), lastWinding = Triangulator2.winding(x1, y1, x2, y2, x3, y3), fanBaseIndex = t1);
        }
        polygon.length > 0 && (convexPolygons.push(polygon), convexPolygonsIndices.push(polygonIndices));
        for (var i = 0, n = convexPolygons.length; i < n; i++) if (0 != (polygonIndices = convexPolygonsIndices[i]).length) {
          for (var firstIndex = polygonIndices[0], lastIndex = polygonIndices[polygonIndices.length - 1], o, prevPrevX = (polygon = convexPolygons[i])[o = polygon.length - 4], prevPrevY = polygon[o + 1], prevX = polygon[o + 2], prevY = polygon[o + 3], firstX = polygon[0], firstY = polygon[1], secondX = polygon[2], secondY = polygon[3], winding = Triangulator2.winding(prevPrevX, prevPrevY, prevX, prevY, firstX, firstY), ii = 0; ii < n; ii++) if (ii != i) {
            var otherIndices = convexPolygonsIndices[ii];
            if (3 == otherIndices.length) {
              var otherFirstIndex = otherIndices[0], otherSecondIndex = otherIndices[1], otherLastIndex = otherIndices[2], otherPoly = convexPolygons[ii], x3 = otherPoly[otherPoly.length - 2], y3 = otherPoly[otherPoly.length - 1];
              if (otherFirstIndex == firstIndex && otherSecondIndex == lastIndex) {
                var winding1 = Triangulator2.winding(prevPrevX, prevPrevY, prevX, prevY, x3, y3), winding2 = Triangulator2.winding(x3, y3, firstX, firstY, secondX, secondY);
                winding1 == winding && winding2 == winding && (otherPoly.length = 0, otherIndices.length = 0, polygon.push(x3), polygon.push(y3), polygonIndices.push(otherLastIndex), prevPrevX = prevX, prevPrevY = prevY, prevX = x3, prevY = y3, ii = 0);
              }
            }
          }
        }
        for (var i = convexPolygons.length - 1; i >= 0; i--) 0 == (polygon = convexPolygons[i]).length && (convexPolygons.splice(i, 1), this.polygonPool.free(polygon), polygonIndices = convexPolygonsIndices[i], convexPolygonsIndices.splice(i, 1), this.polygonIndicesPool.free(polygonIndices));
        return convexPolygons;
      }, Triangulator2.isConcave = function(index, vertexCount, vertices, indices) {
        var previous = indices[(vertexCount + index - 1) % vertexCount] << 1, current = indices[index] << 1, next = indices[(index + 1) % vertexCount] << 1;
        return !this.positiveArea(vertices[previous], vertices[previous + 1], vertices[current], vertices[current + 1], vertices[next], vertices[next + 1]);
      }, Triangulator2.positiveArea = function(p1x, p1y, p2x, p2y, p3x, p3y) {
        return p1x * (p3y - p2y) + p2x * (p1y - p3y) + p3x * (p2y - p1y) >= 0;
      }, Triangulator2.winding = function(p1x, p1y, p2x, p2y, p3x, p3y) {
        var px = p2x - p1x, py = p2y - p1y;
        return p3x * py - p3y * px + px * p1y - p1x * py >= 0 ? 1 : -1;
      }, Triangulator2;
    })();
    spine4.Triangulator = Triangulator;
  })(spine || (spine = {})), (function(spine4) {
    var IntSet = (function() {
      function IntSet2() {
        this.array = new Array();
      }
      return IntSet2.prototype.add = function(value) {
        var contains = this.contains(value);
        return this.array[0 | value] = 0 | value, !contains;
      }, IntSet2.prototype.contains = function(value) {
        return null != this.array[0 | value];
      }, IntSet2.prototype.remove = function(value) {
        this.array[0 | value] = void 0;
      }, IntSet2.prototype.clear = function() {
        this.array.length = 0;
      }, IntSet2;
    })();
    spine4.IntSet = IntSet;
    var Color = (function() {
      function Color2(r, g, b, a) {
        void 0 === r && (r = 0), void 0 === g && (g = 0), void 0 === b && (b = 0), void 0 === a && (a = 0), this.r = r, this.g = g, this.b = b, this.a = a;
      }
      return Color2.prototype.set = function(r, g, b, a) {
        return this.r = r, this.g = g, this.b = b, this.a = a, this.clamp(), this;
      }, Color2.prototype.setFromColor = function(c) {
        return this.r = c.r, this.g = c.g, this.b = c.b, this.a = c.a, this;
      }, Color2.prototype.setFromString = function(hex) {
        return hex = "#" == hex.charAt(0) ? hex.substr(1) : hex, this.r = parseInt(hex.substr(0, 2), 16) / 255, this.g = parseInt(hex.substr(2, 2), 16) / 255, this.b = parseInt(hex.substr(4, 2), 16) / 255, this.a = (8 != hex.length ? 255 : parseInt(hex.substr(6, 2), 16)) / 255, this;
      }, Color2.prototype.add = function(r, g, b, a) {
        return this.r += r, this.g += g, this.b += b, this.a += a, this.clamp(), this;
      }, Color2.prototype.clamp = function() {
        return this.r < 0 ? this.r = 0 : this.r > 1 && (this.r = 1), this.g < 0 ? this.g = 0 : this.g > 1 && (this.g = 1), this.b < 0 ? this.b = 0 : this.b > 1 && (this.b = 1), this.a < 0 ? this.a = 0 : this.a > 1 && (this.a = 1), this;
      }, Color2.rgba8888ToColor = function(color, value) {
        color.r = ((4278190080 & value) >>> 24) / 255, color.g = ((16711680 & value) >>> 16) / 255, color.b = ((65280 & value) >>> 8) / 255, color.a = (255 & value) / 255;
      }, Color2.rgb888ToColor = function(color, value) {
        color.r = ((16711680 & value) >>> 16) / 255, color.g = ((65280 & value) >>> 8) / 255, color.b = (255 & value) / 255;
      }, Color2.WHITE = new Color2(1, 1, 1, 1), Color2.RED = new Color2(1, 0, 0, 1), Color2.GREEN = new Color2(0, 1, 0, 1), Color2.BLUE = new Color2(0, 0, 1, 1), Color2.MAGENTA = new Color2(1, 0, 1, 1), Color2;
    })();
    spine4.Color = Color;
    var MathUtils = (function() {
      function MathUtils2() {
      }
      return MathUtils2.clamp = function(value, min, max) {
        return value < min ? min : value > max ? max : value;
      }, MathUtils2.cosDeg = function(degrees) {
        return Math.cos(degrees * MathUtils2.degRad);
      }, MathUtils2.sinDeg = function(degrees) {
        return Math.sin(degrees * MathUtils2.degRad);
      }, MathUtils2.signum = function(value) {
        return value > 0 ? 1 : value < 0 ? -1 : 0;
      }, MathUtils2.toInt = function(x) {
        return x > 0 ? Math.floor(x) : Math.ceil(x);
      }, MathUtils2.cbrt = function(x) {
        var y = Math.pow(Math.abs(x), 1 / 3);
        return x < 0 ? -y : y;
      }, MathUtils2.randomTriangular = function(min, max) {
        return MathUtils2.randomTriangularWith(min, max, 0.5 * (min + max));
      }, MathUtils2.randomTriangularWith = function(min, max, mode) {
        var u = Math.random(), d = max - min;
        return u <= (mode - min) / d ? min + Math.sqrt(u * d * (mode - min)) : max - Math.sqrt((1 - u) * d * (max - mode));
      }, MathUtils2.PI = 3.1415927, MathUtils2.PI2 = 2 * MathUtils2.PI, MathUtils2.radiansToDegrees = 180 / MathUtils2.PI, MathUtils2.radDeg = MathUtils2.radiansToDegrees, MathUtils2.degreesToRadians = MathUtils2.PI / 180, MathUtils2.degRad = MathUtils2.degreesToRadians, MathUtils2;
    })();
    spine4.MathUtils = MathUtils;
    var Interpolation = (function() {
      function Interpolation2() {
      }
      return Interpolation2.prototype.apply = function(start, end, a) {
        return start + (end - start) * this.applyInternal(a);
      }, Interpolation2;
    })();
    spine4.Interpolation = Interpolation;
    var Pow = (function(_super) {
      function Pow2(power) {
        var _this = _super.call(this) || this;
        return _this.power = 2, _this.power = power, _this;
      }
      return __extends(Pow2, _super), Pow2.prototype.applyInternal = function(a) {
        return a <= 0.5 ? Math.pow(2 * a, this.power) / 2 : Math.pow(2 * (a - 1), this.power) / (this.power % 2 == 0 ? -2 : 2) + 1;
      }, Pow2;
    })(Interpolation);
    spine4.Pow = Pow;
    var PowOut = (function(_super) {
      function PowOut2(power) {
        return _super.call(this, power) || this;
      }
      return __extends(PowOut2, _super), PowOut2.prototype.applyInternal = function(a) {
        return Math.pow(a - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1;
      }, PowOut2;
    })(Pow);
    spine4.PowOut = PowOut;
    var Utils = (function() {
      function Utils2() {
      }
      return Utils2.arrayCopy = function(source, sourceStart, dest, destStart, numElements) {
        for (var i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) dest[j] = source[i];
      }, Utils2.setArraySize = function(array, size, value) {
        void 0 === value && (value = 0);
        var oldSize = array.length;
        if (oldSize == size) return array;
        if (array.length = size, oldSize < size) for (var i = oldSize; i < size; i++) array[i] = value;
        return array;
      }, Utils2.ensureArrayCapacity = function(array, size, value) {
        return void 0 === value && (value = 0), array.length >= size ? array : Utils2.setArraySize(array, size, value);
      }, Utils2.newArray = function(size, defaultValue) {
        for (var array = new Array(size), i = 0; i < size; i++) array[i] = defaultValue;
        return array;
      }, Utils2.newFloatArray = function(size) {
        if (Utils2.SUPPORTS_TYPED_ARRAYS) return new Float32Array(size);
        for (var array = new Array(size), i = 0; i < array.length; i++) array[i] = 0;
        return array;
      }, Utils2.newShortArray = function(size) {
        if (Utils2.SUPPORTS_TYPED_ARRAYS) return new Int16Array(size);
        for (var array = new Array(size), i = 0; i < array.length; i++) array[i] = 0;
        return array;
      }, Utils2.toFloatArray = function(array) {
        return Utils2.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;
      }, Utils2.toSinglePrecision = function(value) {
        return Utils2.SUPPORTS_TYPED_ARRAYS ? Math.fround(value) : value;
      }, Utils2.webkit602BugfixHelper = function(alpha, blend) {
      }, Utils2.contains = function(array, element, identity) {
        for (var i = 0; i < array.length; i++) if (array[i] == element) return true;
        return false;
      }, Utils2.SUPPORTS_TYPED_ARRAYS = "undefined" != typeof Float32Array, Utils2;
    })();
    spine4.Utils = Utils;
    var DebugUtils = (function() {
      function DebugUtils2() {
      }
      return DebugUtils2.logBones = function(skeleton2) {
        for (var i = 0; i < Skeleton.bones.length; i++) {
          var bone = Skeleton.bones[i];
          console.log(bone.data.name + ", " + bone.a + ", " + bone.b + ", " + bone.c + ", " + bone.d + ", " + bone.worldX + ", " + bone.worldY);
        }
      }, DebugUtils2;
    })();
    spine4.DebugUtils = DebugUtils;
    var Pool = (function() {
      function Pool2(instantiator) {
        this.items = new Array(), this.instantiator = instantiator;
      }
      return Pool2.prototype.obtain = function() {
        return this.items.length > 0 ? this.items.pop() : this.instantiator();
      }, Pool2.prototype.free = function(item) {
        item.reset && item.reset(), this.items.push(item);
      }, Pool2.prototype.freeAll = function(items) {
        for (var i = 0; i < items.length; i++) this.free(items[i]);
      }, Pool2.prototype.clear = function() {
        this.items.length = 0;
      }, Pool2;
    })();
    spine4.Pool = Pool;
    var Vector2 = (function() {
      function Vector22(x, y) {
        void 0 === x && (x = 0), void 0 === y && (y = 0), this.x = x, this.y = y;
      }
      return Vector22.prototype.set = function(x, y) {
        return this.x = x, this.y = y, this;
      }, Vector22.prototype.length = function() {
        var x = this.x, y = this.y;
        return Math.sqrt(x * x + y * y);
      }, Vector22.prototype.normalize = function() {
        var len = this.length();
        return 0 != len && (this.x /= len, this.y /= len), this;
      }, Vector22;
    })();
    spine4.Vector2 = Vector2;
    var TimeKeeper = (function() {
      function TimeKeeper2() {
        this.maxDelta = 0.064, this.framesPerSecond = 0, this.delta = 0, this.totalTime = 0, this.lastTime = Date.now() / 1e3, this.frameCount = 0, this.frameTime = 0;
      }
      return TimeKeeper2.prototype.update = function() {
        var now = Date.now() / 1e3;
        this.delta = now - this.lastTime, this.frameTime += this.delta, this.totalTime += this.delta, this.delta > this.maxDelta && (this.delta = this.maxDelta), this.lastTime = now, this.frameCount++, this.frameTime > 1 && (this.framesPerSecond = this.frameCount / this.frameTime, this.frameTime = 0, this.frameCount = 0);
      }, TimeKeeper2;
    })();
    spine4.TimeKeeper = TimeKeeper;
    var WindowedMean = (function() {
      function WindowedMean2(windowSize) {
        void 0 === windowSize && (windowSize = 32), this.addedValues = 0, this.lastValue = 0, this.mean = 0, this.dirty = true, this.values = new Array(windowSize);
      }
      return WindowedMean2.prototype.hasEnoughData = function() {
        return this.addedValues >= this.values.length;
      }, WindowedMean2.prototype.addValue = function(value) {
        this.addedValues < this.values.length && this.addedValues++, this.values[this.lastValue++] = value, this.lastValue > this.values.length - 1 && (this.lastValue = 0), this.dirty = true;
      }, WindowedMean2.prototype.getMean = function() {
        if (this.hasEnoughData()) {
          if (this.dirty) {
            for (var mean = 0, i = 0; i < this.values.length; i++) mean += this.values[i];
            this.mean = mean / this.values.length, this.dirty = false;
          }
          return this.mean;
        }
        return 0;
      }, WindowedMean2;
    })();
    spine4.WindowedMean = WindowedMean;
  })(spine || (spine = {})), (function() {
    var array;
    Math.fround || (Math.fround = (array = new Float32Array(1), function(x) {
      return array[0] = x, array[0];
    }));
  })(), (function(spine4) {
    var Attachment = /* @__PURE__ */ (function() {
      function Attachment2(name) {
        if (null == name) throw new Error("name cannot be null.");
        this.name = name;
      }
      return Attachment2;
    })();
    spine4.Attachment = Attachment;
    var VertexAttachment = (function(_super) {
      function VertexAttachment2(name) {
        var _this = _super.call(this, name) || this;
        return _this.id = (65535 & VertexAttachment2.nextID++) << 11, _this.worldVerticesLength = 0, _this.deformAttachment = _this, _this;
      }
      return __extends(VertexAttachment2, _super), VertexAttachment2.prototype.computeWorldVertices = function(slot, start, count, worldVertices, offset, stride) {
        count = offset + (count >> 1) * stride;
        var Skeleton2 = slot.bone.skeleton, deformArray = slot.deform, vertices = this.vertices, bones = this.bones;
        if (null != bones) {
          for (var v = 0, skip = 0, i = 0; i < start; i += 2) {
            var n;
            v += (n = bones[v]) + 1, skip += n;
          }
          var SkeletonBones = Skeleton2.bones;
          if (0 == deformArray.length) for (var w = offset, b = 3 * skip; w < count; w += stride) {
            var wx = 0, wy = 0, n = bones[v++];
            for (n += v; v < n; v++, b += 3) {
              var bone = SkeletonBones[bones[v]], vx = vertices[b], vy = vertices[b + 1], weight = vertices[b + 2];
              wx += (vx * bone.a + vy * bone.b + bone.worldX) * weight, wy += (vx * bone.c + vy * bone.d + bone.worldY) * weight;
            }
            worldVertices[w] = wx, worldVertices[w + 1] = wy;
          }
          else for (var deform = deformArray, w = offset, b = 3 * skip, f = skip << 1; w < count; w += stride) {
            var wx = 0, wy = 0, n = bones[v++];
            for (n += v; v < n; v++, b += 3, f += 2) {
              var bone = SkeletonBones[bones[v]], vx = vertices[b] + deform[f], vy = vertices[b + 1] + deform[f + 1], weight = vertices[b + 2];
              wx += (vx * bone.a + vy * bone.b + bone.worldX) * weight, wy += (vx * bone.c + vy * bone.d + bone.worldY) * weight;
            }
            worldVertices[w] = wx, worldVertices[w + 1] = wy;
          }
        } else {
          deformArray.length > 0 && (vertices = deformArray);
          for (var bone, x = (bone = slot.bone).worldX, y = bone.worldY, a = bone.a, b = bone.b, c = bone.c, d = bone.d, v_1 = start, w = offset; w < count; v_1 += 2, w += stride) {
            var vx = vertices[v_1], vy = vertices[v_1 + 1];
            worldVertices[w] = vx * a + vy * b + x, worldVertices[w + 1] = vx * c + vy * d + y;
          }
        }
      }, VertexAttachment2.prototype.copyTo = function(attachment) {
        null != this.bones ? (attachment.bones = new Array(this.bones.length), spine4.Utils.arrayCopy(this.bones, 0, attachment.bones, 0, this.bones.length)) : attachment.bones = null, null != this.vertices ? (attachment.vertices = spine4.Utils.newFloatArray(this.vertices.length), spine4.Utils.arrayCopy(this.vertices, 0, attachment.vertices, 0, this.vertices.length)) : attachment.vertices = null, attachment.worldVerticesLength = this.worldVerticesLength, attachment.deformAttachment = this.deformAttachment;
      }, VertexAttachment2.nextID = 0, VertexAttachment2;
    })(Attachment);
    spine4.VertexAttachment = VertexAttachment;
  })(spine || (spine = {})), (function(spine4) {
    !(function(AttachmentType2) {
      AttachmentType2[AttachmentType2.Region = 0] = "Region", AttachmentType2[AttachmentType2.BoundingBox = 1] = "BoundingBox", AttachmentType2[AttachmentType2.Mesh = 2] = "Mesh", AttachmentType2[AttachmentType2.LinkedMesh = 3] = "LinkedMesh", AttachmentType2[AttachmentType2.Path = 4] = "Path", AttachmentType2[AttachmentType2.Point = 5] = "Point", AttachmentType2[AttachmentType2.Clipping = 6] = "Clipping";
    })(spine4.AttachmentType || (spine4.AttachmentType = {}));
  })(spine || (spine = {})), (function(spine4) {
    var BoundingBoxAttachment = (function(_super) {
      function BoundingBoxAttachment2(name) {
        var _this = _super.call(this, name) || this;
        return _this.color = new spine4.Color(1, 1, 1, 1), _this;
      }
      return __extends(BoundingBoxAttachment2, _super), BoundingBoxAttachment2.prototype.copy = function() {
        var copy = new BoundingBoxAttachment2(this.name);
        return this.copyTo(copy), copy.color.setFromColor(this.color), copy;
      }, BoundingBoxAttachment2;
    })(spine4.VertexAttachment);
    spine4.BoundingBoxAttachment = BoundingBoxAttachment;
  })(spine || (spine = {})), (function(spine4) {
    var ClippingAttachment = (function(_super) {
      function ClippingAttachment2(name) {
        var _this = _super.call(this, name) || this;
        return _this.color = new spine4.Color(0.2275, 0.2275, 0.8078, 1), _this;
      }
      return __extends(ClippingAttachment2, _super), ClippingAttachment2.prototype.copy = function() {
        var copy = new ClippingAttachment2(this.name);
        return this.copyTo(copy), copy.endSlot = this.endSlot, copy.color.setFromColor(this.color), copy;
      }, ClippingAttachment2;
    })(spine4.VertexAttachment);
    spine4.ClippingAttachment = ClippingAttachment;
  })(spine || (spine = {})), (function(spine4) {
    var MeshAttachment = (function(_super) {
      function MeshAttachment2(name) {
        var _this = _super.call(this, name) || this;
        return _this.color = new spine4.Color(1, 1, 1, 1), _this.tempColor = new spine4.Color(0, 0, 0, 0), _this;
      }
      return __extends(MeshAttachment2, _super), MeshAttachment2.prototype.updateUVs = function() {
        var regionUVs = this.regionUVs;
        null != this.uvs && this.uvs.length == regionUVs.length || (this.uvs = spine4.Utils.newFloatArray(regionUVs.length));
        var uvs = this.uvs, n = this.uvs.length, u = this.region.u, v = this.region.v, width = 0, height = 0;
        if (this.region instanceof spine4.TextureAtlasRegion) {
          var region = this.region, textureWidth = region.texture.getImage().width, textureHeight = region.texture.getImage().height;
          switch (region.degrees) {
            case 90:
              u -= (region.originalHeight - region.offsetY - region.height) / textureWidth, v -= (region.originalWidth - region.offsetX - region.width) / textureHeight, width = region.originalHeight / textureWidth, height = region.originalWidth / textureHeight;
              for (var i = 0; i < n; i += 2) uvs[i] = u + regionUVs[i + 1] * width, uvs[i + 1] = v + (1 - regionUVs[i]) * height;
              return;
            case 180:
              u -= (region.originalWidth - region.offsetX - region.width) / textureWidth, v -= region.offsetY / textureHeight, width = region.originalWidth / textureWidth, height = region.originalHeight / textureHeight;
              for (var i = 0; i < n; i += 2) uvs[i] = u + (1 - regionUVs[i]) * width, uvs[i + 1] = v + (1 - regionUVs[i + 1]) * height;
              return;
            case 270:
              u -= region.offsetY / textureWidth, v -= region.offsetX / textureHeight, width = region.originalHeight / textureWidth, height = region.originalWidth / textureHeight;
              for (var i = 0; i < n; i += 2) uvs[i] = u + (1 - regionUVs[i + 1]) * width, uvs[i + 1] = v + regionUVs[i] * height;
              return;
          }
          u -= region.offsetX / textureWidth, v -= (region.originalHeight - region.offsetY - region.height) / textureHeight, width = region.originalWidth / textureWidth, height = region.originalHeight / textureHeight;
        } else null == this.region ? (u = v = 0, width = height = 1) : (width = this.region.u2 - u, height = this.region.v2 - v);
        for (var i = 0; i < n; i += 2) uvs[i] = u + regionUVs[i] * width, uvs[i + 1] = v + regionUVs[i + 1] * height;
      }, MeshAttachment2.prototype.getParentMesh = function() {
        return this.parentMesh;
      }, MeshAttachment2.prototype.setParentMesh = function(parentMesh) {
        this.parentMesh = parentMesh, null != parentMesh && (this.bones = parentMesh.bones, this.vertices = parentMesh.vertices, this.worldVerticesLength = parentMesh.worldVerticesLength, this.regionUVs = parentMesh.regionUVs, this.triangles = parentMesh.triangles, this.hullLength = parentMesh.hullLength, this.worldVerticesLength = parentMesh.worldVerticesLength);
      }, MeshAttachment2.prototype.copy = function() {
        if (null != this.parentMesh) return this.newLinkedMesh();
        var copy = new MeshAttachment2(this.name);
        return copy.region = this.region, copy.path = this.path, copy.color.setFromColor(this.color), this.copyTo(copy), copy.regionUVs = new Array(this.regionUVs.length), spine4.Utils.arrayCopy(this.regionUVs, 0, copy.regionUVs, 0, this.regionUVs.length), copy.uvs = new Array(this.uvs.length), spine4.Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, this.uvs.length), copy.triangles = new Array(this.triangles.length), spine4.Utils.arrayCopy(this.triangles, 0, copy.triangles, 0, this.triangles.length), copy.hullLength = this.hullLength, null != this.edges && (copy.edges = new Array(this.edges.length), spine4.Utils.arrayCopy(this.edges, 0, copy.edges, 0, this.edges.length)), copy.width = this.width, copy.height = this.height, copy;
      }, MeshAttachment2.prototype.newLinkedMesh = function() {
        var copy = new MeshAttachment2(this.name);
        return copy.region = this.region, copy.path = this.path, copy.color.setFromColor(this.color), copy.deformAttachment = this.deformAttachment, copy.setParentMesh(null != this.parentMesh ? this.parentMesh : this), copy.updateUVs(), copy;
      }, MeshAttachment2;
    })(spine4.VertexAttachment);
    spine4.MeshAttachment = MeshAttachment;
  })(spine || (spine = {})), (function(spine4) {
    var PathAttachment = (function(_super) {
      function PathAttachment2(name) {
        var _this = _super.call(this, name) || this;
        return _this.closed = false, _this.constantSpeed = false, _this.color = new spine4.Color(1, 1, 1, 1), _this;
      }
      return __extends(PathAttachment2, _super), PathAttachment2.prototype.copy = function() {
        var copy = new PathAttachment2(this.name);
        return this.copyTo(copy), copy.lengths = new Array(this.lengths.length), spine4.Utils.arrayCopy(this.lengths, 0, copy.lengths, 0, this.lengths.length), copy.closed = closed, copy.constantSpeed = this.constantSpeed, copy.color.setFromColor(this.color), copy;
      }, PathAttachment2;
    })(spine4.VertexAttachment);
    spine4.PathAttachment = PathAttachment;
  })(spine || (spine = {})), (function(spine4) {
    var PointAttachment = (function(_super) {
      function PointAttachment2(name) {
        var _this = _super.call(this, name) || this;
        return _this.color = new spine4.Color(0.38, 0.94, 0, 1), _this;
      }
      return __extends(PointAttachment2, _super), PointAttachment2.prototype.computeWorldPosition = function(bone, point) {
        return point.x = this.x * bone.a + this.y * bone.b + bone.worldX, point.y = this.x * bone.c + this.y * bone.d + bone.worldY, point;
      }, PointAttachment2.prototype.computeWorldRotation = function(bone) {
        var cos = spine4.MathUtils.cosDeg(this.rotation), sin = spine4.MathUtils.sinDeg(this.rotation), x = cos * bone.a + sin * bone.b, y = cos * bone.c + sin * bone.d;
        return Math.atan2(y, x) * spine4.MathUtils.radDeg;
      }, PointAttachment2.prototype.copy = function() {
        var copy = new PointAttachment2(this.name);
        return copy.x = this.x, copy.y = this.y, copy.rotation = this.rotation, copy.color.setFromColor(this.color), copy;
      }, PointAttachment2;
    })(spine4.VertexAttachment);
    spine4.PointAttachment = PointAttachment;
  })(spine || (spine = {})), (function(spine4) {
    var RegionAttachment = (function(_super) {
      function RegionAttachment2(name) {
        var _this = _super.call(this, name) || this;
        return _this.x = 0, _this.y = 0, _this.scaleX = 1, _this.scaleY = 1, _this.rotation = 0, _this.width = 0, _this.height = 0, _this.color = new spine4.Color(1, 1, 1, 1), _this.offset = spine4.Utils.newFloatArray(8), _this.uvs = spine4.Utils.newFloatArray(8), _this.tempColor = new spine4.Color(1, 1, 1, 1), _this;
      }
      return __extends(RegionAttachment2, _super), RegionAttachment2.prototype.updateOffset = function() {
        var regionScaleX = this.width / this.region.originalWidth * this.scaleX, regionScaleY = this.height / this.region.originalHeight * this.scaleY, localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX, localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY, localX2 = localX + this.region.width * regionScaleX, localY2 = localY + this.region.height * regionScaleY, radians = this.rotation * Math.PI / 180, cos = Math.cos(radians), sin = Math.sin(radians), localXCos = localX * cos + this.x, localXSin = localX * sin, localYCos = localY * cos + this.y, localYSin = localY * sin, localX2Cos = localX2 * cos + this.x, localX2Sin = localX2 * sin, localY2Cos = localY2 * cos + this.y, localY2Sin = localY2 * sin, offset = this.offset;
        offset[RegionAttachment2.OX1] = localXCos - localYSin, offset[RegionAttachment2.OY1] = localYCos + localXSin, offset[RegionAttachment2.OX2] = localXCos - localY2Sin, offset[RegionAttachment2.OY2] = localY2Cos + localXSin, offset[RegionAttachment2.OX3] = localX2Cos - localY2Sin, offset[RegionAttachment2.OY3] = localY2Cos + localX2Sin, offset[RegionAttachment2.OX4] = localX2Cos - localYSin, offset[RegionAttachment2.OY4] = localYCos + localX2Sin;
      }, RegionAttachment2.prototype.setRegion = function(region) {
        this.region = region;
        var uvs = this.uvs;
        region.rotate ? (uvs[2] = region.u, uvs[3] = region.v2, uvs[4] = region.u, uvs[5] = region.v, uvs[6] = region.u2, uvs[7] = region.v, uvs[0] = region.u2, uvs[1] = region.v2) : (uvs[0] = region.u, uvs[1] = region.v2, uvs[2] = region.u, uvs[3] = region.v, uvs[4] = region.u2, uvs[5] = region.v, uvs[6] = region.u2, uvs[7] = region.v2);
      }, RegionAttachment2.prototype.computeWorldVertices = function(bone, worldVertices, offset, stride) {
        var vertexOffset = this.offset, x = bone.worldX, y = bone.worldY, a = bone.a, b = bone.b, c = bone.c, d = bone.d, offsetX = 0, offsetY = 0;
        offsetX = vertexOffset[RegionAttachment2.OX1], offsetY = vertexOffset[RegionAttachment2.OY1], worldVertices[offset] = offsetX * a + offsetY * b + x, worldVertices[offset + 1] = offsetX * c + offsetY * d + y, offset += stride, offsetX = vertexOffset[RegionAttachment2.OX2], offsetY = vertexOffset[RegionAttachment2.OY2], worldVertices[offset] = offsetX * a + offsetY * b + x, worldVertices[offset + 1] = offsetX * c + offsetY * d + y, offset += stride, offsetX = vertexOffset[RegionAttachment2.OX3], offsetY = vertexOffset[RegionAttachment2.OY3], worldVertices[offset] = offsetX * a + offsetY * b + x, worldVertices[offset + 1] = offsetX * c + offsetY * d + y, offset += stride, offsetX = vertexOffset[RegionAttachment2.OX4], offsetY = vertexOffset[RegionAttachment2.OY4], worldVertices[offset] = offsetX * a + offsetY * b + x, worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
      }, RegionAttachment2.prototype.copy = function() {
        var copy = new RegionAttachment2(this.name);
        return copy.region = this.region, copy.rendererObject = this.rendererObject, copy.path = this.path, copy.x = this.x, copy.y = this.y, copy.scaleX = this.scaleX, copy.scaleY = this.scaleY, copy.rotation = this.rotation, copy.width = this.width, copy.height = this.height, spine4.Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, 8), spine4.Utils.arrayCopy(this.offset, 0, copy.offset, 0, 8), copy.color.setFromColor(this.color), copy;
      }, RegionAttachment2.OX1 = 0, RegionAttachment2.OY1 = 1, RegionAttachment2.OX2 = 2, RegionAttachment2.OY2 = 3, RegionAttachment2.OX3 = 4, RegionAttachment2.OY3 = 5, RegionAttachment2.OX4 = 6, RegionAttachment2.OY4 = 7, RegionAttachment2.X1 = 0, RegionAttachment2.Y1 = 1, RegionAttachment2.C1R = 2, RegionAttachment2.C1G = 3, RegionAttachment2.C1B = 4, RegionAttachment2.C1A = 5, RegionAttachment2.U1 = 6, RegionAttachment2.V1 = 7, RegionAttachment2.X2 = 8, RegionAttachment2.Y2 = 9, RegionAttachment2.C2R = 10, RegionAttachment2.C2G = 11, RegionAttachment2.C2B = 12, RegionAttachment2.C2A = 13, RegionAttachment2.U2 = 14, RegionAttachment2.V2 = 15, RegionAttachment2.X3 = 16, RegionAttachment2.Y3 = 17, RegionAttachment2.C3R = 18, RegionAttachment2.C3G = 19, RegionAttachment2.C3B = 20, RegionAttachment2.C3A = 21, RegionAttachment2.U3 = 22, RegionAttachment2.V3 = 23, RegionAttachment2.X4 = 24, RegionAttachment2.Y4 = 25, RegionAttachment2.C4R = 26, RegionAttachment2.C4G = 27, RegionAttachment2.C4B = 28, RegionAttachment2.C4A = 29, RegionAttachment2.U4 = 30, RegionAttachment2.V4 = 31, RegionAttachment2;
    })(spine4.Attachment);
    spine4.RegionAttachment = RegionAttachment;
  })(spine || (spine = {})), (function(spine4) {
    var JitterEffect = (function() {
      function JitterEffect2(jitterX, jitterY) {
        this.jitterX = 0, this.jitterY = 0, this.jitterX = jitterX, this.jitterY = jitterY;
      }
      return JitterEffect2.prototype.begin = function(skeleton2) {
      }, JitterEffect2.prototype.transform = function(position, uv, light, dark) {
        position.x += spine4.MathUtils.randomTriangular(-this.jitterX, this.jitterY), position.y += spine4.MathUtils.randomTriangular(-this.jitterX, this.jitterY);
      }, JitterEffect2.prototype.end = function() {
      }, JitterEffect2;
    })();
    spine4.JitterEffect = JitterEffect;
  })(spine || (spine = {})), (function(spine4) {
    var SwirlEffect = (function() {
      function SwirlEffect2(radius) {
        this.centerX = 0, this.centerY = 0, this.radius = 0, this.angle = 0, this.worldX = 0, this.worldY = 0, this.radius = radius;
      }
      return SwirlEffect2.prototype.begin = function(skeleton2) {
        this.worldX = Skeleton.x + this.centerX, this.worldY = Skeleton.y + this.centerY;
      }, SwirlEffect2.prototype.transform = function(position, uv, light, dark) {
        var radAngle = this.angle * spine4.MathUtils.degreesToRadians, x = position.x - this.worldX, y = position.y - this.worldY, dist = Math.sqrt(x * x + y * y);
        if (dist < this.radius) {
          var theta = SwirlEffect2.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius), cos = Math.cos(theta), sin = Math.sin(theta);
          position.x = cos * x - sin * y + this.worldX, position.y = sin * x + cos * y + this.worldY;
        }
      }, SwirlEffect2.prototype.end = function() {
      }, SwirlEffect2.interpolation = new spine4.PowOut(2), SwirlEffect2;
    })();
    spine4.SwirlEffect = SwirlEffect;
  })(spine || (spine = {})), (function(spine4) {
    !(function(webgl2) {
      var AssetManager = (function(_super) {
        function AssetManager2(context, pathPrefix) {
          return void 0 === pathPrefix && (pathPrefix = ""), _super.call(this, (function(image) {
            return new spine4.webgl.GLTexture(context, image);
          }), pathPrefix) || this;
        }
        return __extends(AssetManager2, _super), AssetManager2;
      })(spine4.AssetManager);
      webgl2.AssetManager = AssetManager;
    })(spine4.webgl || (spine4.webgl = {}));
  })(spine || (spine = {})), (function(spine4) {
    !(function(webgl2) {
      var OrthoCamera = (function() {
        function OrthoCamera2(viewportWidth, viewportHeight) {
          this.position = new webgl2.Vector3(0, 0, 0), this.direction = new webgl2.Vector3(0, 0, -1), this.up = new webgl2.Vector3(0, 1, 0), this.near = 0, this.far = 100, this.zoom = 1, this.viewportWidth = 0, this.viewportHeight = 0, this.projectionView = new webgl2.Matrix4(), this.inverseProjectionView = new webgl2.Matrix4(), this.projection = new webgl2.Matrix4(), this.view = new webgl2.Matrix4(), this.tmp = new webgl2.Vector3(), this.viewportWidth = viewportWidth, this.viewportHeight = viewportHeight, this.update();
        }
        return OrthoCamera2.prototype.update = function() {
          var projection = this.projection, view = this.view, projectionView = this.projectionView, inverseProjectionView = this.inverseProjectionView, zoom = this.zoom, viewportWidth = this.viewportWidth, viewportHeight = this.viewportHeight;
          projection.ortho(zoom * (-viewportWidth / 2), zoom * (viewportWidth / 2), zoom * (-viewportHeight / 2), zoom * (viewportHeight / 2), this.near, this.far), view.lookAt(this.position, this.direction, this.up), projectionView.set(projection.values), projectionView.multiply(view), inverseProjectionView.set(projectionView.values).invert();
        }, OrthoCamera2.prototype.screenToWorld = function(screenCoords, screenWidth, screenHeight) {
          var x = screenCoords.x, y = screenHeight - screenCoords.y - 1, tmp = this.tmp;
          return tmp.x = 2 * x / screenWidth - 1, tmp.y = 2 * y / screenHeight - 1, tmp.z = 2 * screenCoords.z - 1, tmp.project(this.inverseProjectionView), screenCoords.set(tmp.x, tmp.y, tmp.z), screenCoords;
        }, OrthoCamera2.prototype.setViewport = function(viewportWidth, viewportHeight) {
          this.viewportWidth = viewportWidth, this.viewportHeight = viewportHeight;
        }, OrthoCamera2;
      })();
      webgl2.OrthoCamera = OrthoCamera;
    })(spine4.webgl || (spine4.webgl = {}));
  })(spine || (spine = {})), (function(spine4) {
    !(function(webgl2) {
      var GLTexture = (function(_super) {
        function GLTexture2(context, image, useMipMaps) {
          void 0 === useMipMaps && (useMipMaps = false);
          var _this = _super.call(this, image) || this;
          return _this.texture = null, _this.boundUnit = 0, _this.useMipMaps = false, _this.context = context instanceof webgl2.ManagedWebGLRenderingContext ? context : new webgl2.ManagedWebGLRenderingContext(context), _this.useMipMaps = useMipMaps, _this.restore(), _this.context.addRestorable(_this), _this;
        }
        return __extends(GLTexture2, _super), GLTexture2.prototype.setFilters = function(minFilter, magFilter) {
          var gl = this.context.gl;
          this.bind(), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, GLTexture2.validateMagFilter(magFilter));
        }, GLTexture2.validateMagFilter = function(magFilter) {
          switch (magFilter) {
            case spine4.TextureFilter.MipMap:
            case spine4.TextureFilter.MipMapLinearLinear:
            case spine4.TextureFilter.MipMapLinearNearest:
            case spine4.TextureFilter.MipMapNearestLinear:
            case spine4.TextureFilter.MipMapNearestNearest:
              return spine4.TextureFilter.Linear;
            default:
              return magFilter;
          }
        }, GLTexture2.prototype.setWraps = function(uWrap, vWrap) {
          var gl = this.context.gl;
          this.bind(), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, uWrap), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, vWrap);
        }, GLTexture2.prototype.update = function(useMipMaps) {
          var gl = this.context.gl;
          this.texture || (this.texture = this.context.gl.createTexture()), this.bind(), GLTexture2.DISABLE_UNPACK_PREMULTIPLIED_ALPHA_WEBGL && gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this._image), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, useMipMaps ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE), useMipMaps && gl.generateMipmap(gl.TEXTURE_2D);
        }, GLTexture2.prototype.restore = function() {
          this.texture = null, this.update(this.useMipMaps);
        }, GLTexture2.prototype.bind = function(unit) {
          void 0 === unit && (unit = 0);
          var gl = this.context.gl;
          this.boundUnit = unit, gl.activeTexture(gl.TEXTURE0 + unit), gl.bindTexture(gl.TEXTURE_2D, this.texture);
        }, GLTexture2.prototype.unbind = function() {
          var gl = this.context.gl;
          gl.activeTexture(gl.TEXTURE0 + this.boundUnit), gl.bindTexture(gl.TEXTURE_2D, null);
        }, GLTexture2.prototype.dispose = function() {
          this.context.removeRestorable(this), this.context.gl.deleteTexture(this.texture);
        }, GLTexture2.DISABLE_UNPACK_PREMULTIPLIED_ALPHA_WEBGL = false, GLTexture2;
      })(spine4.Texture);
      webgl2.GLTexture = GLTexture;
    })(spine4.webgl || (spine4.webgl = {}));
  })(spine || (spine = {})), (function(spine4) {
    !(function(webgl2) {
      var Input = (function() {
        function Input2(element) {
          this.lastX = 0, this.lastY = 0, this.buttonDown = false, this.currTouch = null, this.touchesPool = new spine4.Pool((function() {
            return new spine4.webgl.Touch(0, 0, 0);
          })), this.listeners = new Array(), this.element = element, this.setupCallbacks(element);
        }
        return Input2.prototype.setupCallbacks = function(element) {
          var _this = this, mouseDown = function(ev) {
            if (ev instanceof MouseEvent) {
              for (var rect = element.getBoundingClientRect(), x = ev.clientX - rect.left, y = ev.clientY - rect.top, listeners = _this.listeners, i = 0; i < listeners.length; i++) listeners[i].down && listeners[i].down(x, y);
              _this.lastX = x, _this.lastY = y, _this.buttonDown = true, document.addEventListener("mousemove", mouseMove), document.addEventListener("mouseup", mouseUp);
            }
          }, mouseMove = function(ev) {
            if (ev instanceof MouseEvent) {
              for (var rect = element.getBoundingClientRect(), x = ev.clientX - rect.left, y = ev.clientY - rect.top, listeners = _this.listeners, i = 0; i < listeners.length; i++) _this.buttonDown ? listeners[i].dragged && listeners[i].dragged(x, y) : listeners[i].moved && listeners[i].moved(x, y);
              _this.lastX = x, _this.lastY = y;
            }
          }, mouseUp = function(ev) {
            if (ev instanceof MouseEvent) {
              for (var rect = element.getBoundingClientRect(), x = ev.clientX - rect.left, y = ev.clientY - rect.top, listeners = _this.listeners, i = 0; i < listeners.length; i++) listeners[i].up && listeners[i].up(x, y);
              _this.lastX = x, _this.lastY = y, _this.buttonDown = false, document.removeEventListener("mousemove", mouseMove), document.removeEventListener("mouseup", mouseUp);
            }
          };
          element.addEventListener("mousedown", mouseDown, true), element.addEventListener("mousemove", mouseMove, true), element.addEventListener("mouseup", mouseUp, true), element.addEventListener("touchstart", (function(ev) {
            if (null == _this.currTouch) {
              for (var touches = ev.changedTouches, i = 0; i < touches.length; i++) {
                var touch = touches[i], rect = element.getBoundingClientRect(), x = touch.clientX - rect.left, y = touch.clientY - rect.top;
                _this.currTouch = _this.touchesPool.obtain(), _this.currTouch.identifier = touch.identifier, _this.currTouch.x = x, _this.currTouch.y = y;
                break;
              }
              for (var listeners = _this.listeners, i_17 = 0; i_17 < listeners.length; i_17++) listeners[i_17].down && listeners[i_17].down(_this.currTouch.x, _this.currTouch.y);
              _this.lastX = _this.currTouch.x, _this.lastY = _this.currTouch.y, _this.buttonDown = true, ev.preventDefault();
            }
          }), false), element.addEventListener("touchend", (function(ev) {
            for (var touches = ev.changedTouches, i = 0; i < touches.length; i++) {
              var touch = touches[i];
              if (_this.currTouch.identifier === touch.identifier) {
                var rect = element.getBoundingClientRect(), x = _this.currTouch.x = touch.clientX - rect.left, y = _this.currTouch.y = touch.clientY - rect.top;
                _this.touchesPool.free(_this.currTouch);
                for (var listeners = _this.listeners, i_18 = 0; i_18 < listeners.length; i_18++) listeners[i_18].up && listeners[i_18].up(x, y);
                _this.lastX = x, _this.lastY = y, _this.buttonDown = false, _this.currTouch = null;
                break;
              }
            }
            ev.preventDefault();
          }), false), element.addEventListener("touchcancel", (function(ev) {
            for (var touches = ev.changedTouches, i = 0; i < touches.length; i++) {
              var touch = touches[i];
              if (_this.currTouch.identifier === touch.identifier) {
                var rect = element.getBoundingClientRect(), x = _this.currTouch.x = touch.clientX - rect.left, y = _this.currTouch.y = touch.clientY - rect.top;
                _this.touchesPool.free(_this.currTouch);
                for (var listeners = _this.listeners, i_19 = 0; i_19 < listeners.length; i_19++) listeners[i_19].up && listeners[i_19].up(x, y);
                _this.lastX = x, _this.lastY = y, _this.buttonDown = false, _this.currTouch = null;
                break;
              }
            }
            ev.preventDefault();
          }), false), element.addEventListener("touchmove", (function(ev) {
            if (null != _this.currTouch) {
              for (var touches = ev.changedTouches, i = 0; i < touches.length; i++) {
                var touch = touches[i];
                if (_this.currTouch.identifier === touch.identifier) {
                  for (var rect = element.getBoundingClientRect(), x = touch.clientX - rect.left, y = touch.clientY - rect.top, listeners = _this.listeners, i_20 = 0; i_20 < listeners.length; i_20++) listeners[i_20].dragged && listeners[i_20].dragged(x, y);
                  _this.lastX = _this.currTouch.x = x, _this.lastY = _this.currTouch.y = y;
                  break;
                }
              }
              ev.preventDefault();
            }
          }), false);
        }, Input2.prototype.addListener = function(listener) {
          this.listeners.push(listener);
        }, Input2.prototype.removeListener = function(listener) {
          var idx = this.listeners.indexOf(listener);
          idx > -1 && this.listeners.splice(idx, 1);
        }, Input2;
      })();
      webgl2.Input = Input;
      var Touch = /* @__PURE__ */ (function() {
        function Touch2(identifier, x, y) {
          this.identifier = identifier, this.x = x, this.y = y;
        }
        return Touch2;
      })();
      webgl2.Touch = Touch;
    })(spine4.webgl || (spine4.webgl = {}));
  })(spine || (spine = {})), (function(spine4) {
    !(function(webgl2) {
      var LoadingScreen = (function() {
        function LoadingScreen2(renderer) {
          if (this.logo = null, this.spinner = null, this.angle = 0, this.fadeOut = 0, this.timeKeeper = new spine4.TimeKeeper(), this.backgroundColor = new spine4.Color(0.135, 0.135, 0.135, 1), this.tempColor = new spine4.Color(), this.firstDraw = 0, this.renderer = renderer, this.timeKeeper.maxDelta = 9, null === LoadingScreen2.logoImg) {
            var isSafari = navigator.userAgent.indexOf("Safari") > -1;
            LoadingScreen2.logoImg = new Image(), LoadingScreen2.logoImg.src = LoadingScreen2.SPINE_LOGO_DATA, isSafari || (LoadingScreen2.logoImg.crossOrigin = "anonymous"), LoadingScreen2.logoImg.onload = function(ev) {
              LoadingScreen2.loaded++;
            }, LoadingScreen2.spinnerImg = new Image(), LoadingScreen2.spinnerImg.src = LoadingScreen2.SPINNER_DATA, isSafari || (LoadingScreen2.spinnerImg.crossOrigin = "anonymous"), LoadingScreen2.spinnerImg.onload = function(ev) {
              LoadingScreen2.loaded++;
            };
          }
        }
        return LoadingScreen2.prototype.draw = function(complete) {
          if (void 0 === complete && (complete = false), !(complete && this.fadeOut > LoadingScreen2.FADE_SECONDS)) {
            this.timeKeeper.update();
            var a = Math.abs(Math.sin(this.timeKeeper.totalTime + 0.75));
            this.angle -= this.timeKeeper.delta / 1.4 * 360 * (1 + 1.5 * Math.pow(a, 5));
            var renderer = this.renderer, canvas = renderer.canvas, gl = renderer.context.gl;
            renderer.resize(webgl2.ResizeMode.Stretch);
            var oldX = renderer.camera.position.x, oldY = renderer.camera.position.y;
            if (renderer.camera.position.set(canvas.width / 2, canvas.height / 2, 0), renderer.camera.viewportWidth = canvas.width, renderer.camera.viewportHeight = canvas.height, complete) {
              if (this.fadeOut += this.timeKeeper.delta * (this.timeKeeper.totalTime < 1 ? 2 : 1), this.fadeOut > LoadingScreen2.FADE_SECONDS) return void renderer.camera.position.set(oldX, oldY, 0);
              a = 1 - this.fadeOut / LoadingScreen2.FADE_SECONDS, this.tempColor.setFromColor(this.backgroundColor), this.tempColor.a = 1 - (a - 1) * (a - 1), renderer.begin(), renderer.quad(true, 0, 0, canvas.width, 0, canvas.width, canvas.height, 0, canvas.height, this.tempColor, this.tempColor, this.tempColor, this.tempColor), renderer.end();
            } else gl.clearColor(this.backgroundColor.r, this.backgroundColor.g, this.backgroundColor.b, this.backgroundColor.a), gl.clear(gl.COLOR_BUFFER_BIT), this.tempColor.a = 1;
            if (this.tempColor.set(1, 1, 1, this.tempColor.a), 2 == LoadingScreen2.loaded) {
              null === this.logo && (this.logo = new webgl2.GLTexture(renderer.context, LoadingScreen2.logoImg), this.spinner = new webgl2.GLTexture(renderer.context, LoadingScreen2.spinnerImg)), this.logo.update(false), this.spinner.update(false);
              var logoWidth = this.logo.getImage().width, logoHeight = this.logo.getImage().height, spinnerWidth = this.spinner.getImage().width, spinnerHeight = this.spinner.getImage().height;
              renderer.batcher.setBlendMode(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA), renderer.begin(), renderer.drawTexture(this.logo, (canvas.width - logoWidth) / 2, (canvas.height - logoHeight) / 2, logoWidth, logoHeight, this.tempColor), renderer.drawTextureRotated(this.spinner, (canvas.width - spinnerWidth) / 2, (canvas.height - spinnerHeight) / 2, spinnerWidth, spinnerHeight, spinnerWidth / 2, spinnerHeight / 2, this.angle, this.tempColor), renderer.end(), renderer.camera.position.set(oldX, oldY, 0);
            }
          }
        }, LoadingScreen2.FADE_SECONDS = 1, LoadingScreen2.loaded = 0, LoadingScreen2.spinnerImg = null, LoadingScreen2.logoImg = null, LoadingScreen2.SPINNER_DATA = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKMAAACjCAYAAADmbK6AAAAACXBIWXMAAAsTAAALEwEAmpwYAAALB2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDIgNzkuMTYwOTI0LCAyMDE3LzA3LzEzLTAxOjA2OjM5ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIiB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNS41IChXaW5kb3dzKSIgeG1wOkNyZWF0ZURhdGU9IjIwMTYtMDktMDhUMTQ6MjU6MTIrMDI6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMTgtMTEtMTVUMTY6NDA6NTkrMDE6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDE4LTExLTE1VDE2OjQwOjU5KzAxOjAwIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpmZDhlNTljMC02NGJjLTIxNGQtODAyZi1jZDlhODJjM2ZjMGMiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDpmYmNmZWJlYS03MjY2LWE0NGQtOTI4NS0wOTJmNGNhYzk4ZWEiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDowODMzNWIyYy04NzYyLWQzNGMtOTBhOS02ODJjYjJmYTQ2M2UiIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIHRpZmY6T3JpZW50YXRpb249IjEiIHRpZmY6WFJlc29sdXRpb249IjcyMDAwMC8xMDAwMCIgdGlmZjpZUmVzb2x1dGlvbj0iNzIwMDAwLzEwMDAwIiB0aWZmOlJlc29sdXRpb25Vbml0PSIyIiBleGlmOkNvbG9yU3BhY2U9IjY1NTM1IiBleGlmOlBpeGVsWERpbWVuc2lvbj0iMjk3IiBleGlmOlBpeGVsWURpbWVuc2lvbj0iMjQyIj4gPHhtcE1NOkhpc3Rvcnk+IDxyZGY6U2VxPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iY3JlYXRlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDowODMzNWIyYy04NzYyLWQzNGMtOTBhOS02ODJjYjJmYTQ2M2UiIHN0RXZ0OndoZW49IjIwMTYtMDktMDhUMTQ6MjU6MTIrMDI6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE1LjUgKFdpbmRvd3MpIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpiNThlMTlkNi0xYTRjLTQyNDEtODU0ZC01MDVlZjYxMjRhODQiIHN0RXZ0OndoZW49IjIwMTgtMTEtMTVUMTY6NDA6MjMrMDE6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjQ3YzYzYzIwLWJkYjgtYzM0YS1hYzMyLWQ5MDdjOWEyOTA0MCIgc3RFdnQ6d2hlbj0iMjAxOC0xMS0xNVQxNjo0MDo1OSswMTowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iY29udmVydGVkIiBzdEV2dDpwYXJhbWV0ZXJzPSJmcm9tIGFwcGxpY2F0aW9uL3ZuZC5hZG9iZS5waG90b3Nob3AgdG8gaW1hZ2UvcG5nIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJkZXJpdmVkIiBzdEV2dDpwYXJhbWV0ZXJzPSJjb252ZXJ0ZWQgZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6ZmQ4ZTU5YzAtNjRiYy0yMTRkLTgwMmYtY2Q5YTgyYzNmYzBjIiBzdEV2dDp3aGVuPSIyMDE4LTExLTE1VDE2OjQwOjU5KzAxOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDwvcmRmOlNlcT4gPC94bXBNTTpIaXN0b3J5PiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo0N2M2M2MyMC1iZGI4LWMzNGEtYWMzMi1kOTA3YzlhMjkwNDAiIHN0UmVmOmRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDo2OWRmZjljYy01YzFiLWE5NDctOTc3OS03ODgxZjM0ODk3MDMiIHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDowODMzNWIyYy04NzYyLWQzNGMtOTBhOS02ODJjYjJmYTQ2M2UiLz4gPHBob3Rvc2hvcDpEb2N1bWVudEFu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", LoadingScreen2.SPINE_LOGO_DATA = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKUAAABsCAYAAAALzHKmAAAACXBIWXMAAAsTAAALEwEAmpwYAAALB2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDIgNzkuMTYwOTI0LCAyMDE3LzA3LzEzLTAxOjA2OjM5ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIiB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNS41IChXaW5kb3dzKSIgeG1wOkNyZWF0ZURhdGU9IjIwMTYtMDktMDhUMTQ6MjU6MTIrMDI6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMTgtMTEtMTVUMTY6NDA6NTkrMDE6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDE4LTExLTE1VDE2OjQwOjU5KzAxOjAwIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowMTdhZGQ3Ni04OTZlLThlNGUtYmM5MS00ZjEyNjI1YjA3MjgiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDplMTViNGE2ZS1hMDg3LWEzNDktODdhOS1mNDYzYjE2MzQ0Y2MiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDowODMzNWIyYy04NzYyLWQzNGMtOTBhOS02ODJjYjJmYTQ2M2UiIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIHRpZmY6T3JpZW50YXRpb249IjEiIHRpZmY6WFJlc29sdXRpb249IjcyMDAwMC8xMDAwMCIgdGlmZjpZUmVzb2x1dGlvbj0iNzIwMDAwLzEwMDAwIiB0aWZmOlJlc29sdXRpb25Vbml0PSIyIiBleGlmOkNvbG9yU3BhY2U9IjY1NTM1IiBleGlmOlBpeGVsWERpbWVuc2lvbj0iMjk3IiBleGlmOlBpeGVsWURpbWVuc2lvbj0iMjQyIj4gPHhtcE1NOkhpc3Rvcnk+IDxyZGY6U2VxPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iY3JlYXRlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDowODMzNWIyYy04NzYyLWQzNGMtOTBhOS02ODJjYjJmYTQ2M2UiIHN0RXZ0OndoZW49IjIwMTYtMDktMDhUMTQ6MjU6MTIrMDI6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE1LjUgKFdpbmRvd3MpIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpiNThlMTlkNi0xYTRjLTQyNDEtODU0ZC01MDVlZjYxMjRhODQiIHN0RXZ0OndoZW49IjIwMTgtMTEtMTVUMTY6NDA6MjMrMDE6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjJlNjJiMWM2LWIxYzQtNDk0MC04MDMxLWU4ZDkyNTBmODJjNSIgc3RFdnQ6d2hlbj0iMjAxOC0xMS0xNVQxNjo0MDo1OSswMTowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iY29udmVydGVkIiBzdEV2dDpwYXJhbWV0ZXJzPSJmcm9tIGFwcGxpY2F0aW9uL3ZuZC5hZG9iZS5waG90b3Nob3AgdG8gaW1hZ2UvcG5nIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJkZXJpdmVkIiBzdEV2dDpwYXJhbWV0ZXJzPSJjb252ZXJ0ZWQgZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6MDE3YWRkNzYtODk2ZS04ZTRlLWJjOTEtNGYxMjYyNWIwNzI4IiBzdEV2dDp3aGVuPSIyMDE4LTExLTE1VDE2OjQwOjU5KzAxOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDwvcmRmOlNlcT4gPC94bXBNTTpIaXN0b3J5PiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoyZTYyYjFjNi1iMWM0LTQ5NDAtODAzMS1lOGQ5MjUwZjgyYzUiIHN0UmVmOmRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDo2OWRmZjljYy01YzFiLWE5NDctOTc3OS03ODgxZjM0ODk3MDMiIHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDowODMzNWIyYy04NzYyLWQzNGMtOTBhOS02ODJjYjJmYTQ2M2UiLz4gPHBob3Rvc2hvcDpEb2N1bWVudEFu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", LoadingScreen2;
      })();
      webgl2.LoadingScreen = LoadingScreen;
    })(spine4.webgl || (spine4.webgl = {}));
  })(spine || (spine = {})), (function(spine4) {
    !(function(webgl2) {
      webgl2.M00 = 0, webgl2.M01 = 4, webgl2.M02 = 8, webgl2.M03 = 12, webgl2.M10 = 1, webgl2.M11 = 5, webgl2.M12 = 9, webgl2.M13 = 13, webgl2.M20 = 2, webgl2.M21 = 6, webgl2.M22 = 10, webgl2.M23 = 14, webgl2.M30 = 3, webgl2.M31 = 7, webgl2.M32 = 11, webgl2.M33 = 15;
      var Matrix4 = (function() {
        function Matrix42() {
          this.temp = new Float32Array(16), this.values = new Float32Array(16);
          var v = this.values;
          v[webgl2.M00] = 1, v[webgl2.M11] = 1, v[webgl2.M22] = 1, v[webgl2.M33] = 1;
        }
        return Matrix42.prototype.set = function(values) {
          return this.values.set(values), this;
        }, Matrix42.prototype.transpose = function() {
          var t = this.temp, v = this.values;
          return t[webgl2.M00] = v[webgl2.M00], t[webgl2.M01] = v[webgl2.M10], t[webgl2.M02] = v[webgl2.M20], t[webgl2.M03] = v[webgl2.M30], t[webgl2.M10] = v[webgl2.M01], t[webgl2.M11] = v[webgl2.M11], t[webgl2.M12] = v[webgl2.M21], t[webgl2.M13] = v[webgl2.M31], t[webgl2.M20] = v[webgl2.M02], t[webgl2.M21] = v[webgl2.M12], t[webgl2.M22] = v[webgl2.M22], t[webgl2.M23] = v[webgl2.M32], t[webgl2.M30] = v[webgl2.M03], t[webgl2.M31] = v[webgl2.M13], t[webgl2.M32] = v[webgl2.M23], t[webgl2.M33] = v[webgl2.M33], this.set(t);
        }, Matrix42.prototype.identity = function() {
          var v = this.values;
          return v[webgl2.M00] = 1, v[webgl2.M01] = 0, v[webgl2.M02] = 0, v[webgl2.M03] = 0, v[webgl2.M10] = 0, v[webgl2.M11] = 1, v[webgl2.M12] = 0, v[webgl2.M13] = 0, v[webgl2.M20] = 0, v[webgl2.M21] = 0, v[webgl2.M22] = 1, v[webgl2.M23] = 0, v[webgl2.M30] = 0, v[webgl2.M31] = 0, v[webgl2.M32] = 0, v[webgl2.M33] = 1, this;
        }, Matrix42.prototype.invert = function() {
          var v = this.values, t = this.temp, l_det = v[webgl2.M30] * v[webgl2.M21] * v[webgl2.M12] * v[webgl2.M03] - v[webgl2.M20] * v[webgl2.M31] * v[webgl2.M12] * v[webgl2.M03] - v[webgl2.M30] * v[webgl2.M11] * v[webgl2.M22] * v[webgl2.M03] + v[webgl2.M10] * v[webgl2.M31] * v[webgl2.M22] * v[webgl2.M03] + v[webgl2.M20] * v[webgl2.M11] * v[webgl2.M32] * v[webgl2.M03] - v[webgl2.M10] * v[webgl2.M21] * v[webgl2.M32] * v[webgl2.M03] - v[webgl2.M30] * v[webgl2.M21] * v[webgl2.M02] * v[webgl2.M13] + v[webgl2.M20] * v[webgl2.M31] * v[webgl2.M02] * v[webgl2.M13] + v[webgl2.M30] * v[webgl2.M01] * v[webgl2.M22] * v[webgl2.M13] - v[webgl2.M00] * v[webgl2.M31] * v[webgl2.M22] * v[webgl2.M13] - v[webgl2.M20] * v[webgl2.M01] * v[webgl2.M32] * v[webgl2.M13] + v[webgl2.M00] * v[webgl2.M21] * v[webgl2.M32] * v[webgl2.M13] + v[webgl2.M30] * v[webgl2.M11] * v[webgl2.M02] * v[webgl2.M23] - v[webgl2.M10] * v[webgl2.M31] * v[webgl2.M02] * v[webgl2.M23] - v[webgl2.M30] * v[webgl2.M01] * v[webgl2.M12] * v[webgl2.M23] + v[webgl2.M00] * v[webgl2.M31] * v[webgl2.M12] * v[webgl2.M23] + v[webgl2.M10] * v[webgl2.M01] * v[webgl2.M32] * v[webgl2.M23] - v[webgl2.M00] * v[webgl2.M11] * v[webgl2.M32] * v[webgl2.M23] - v[webgl2.M20] * v[webgl2.M11] * v[webgl2.M02] * v[webgl2.M33] + v[webgl2.M10] * v[webgl2.M21] * v[webgl2.M02] * v[webgl2.M33] + v[webgl2.M20] * v[webgl2.M01] * v[webgl2.M12] * v[webgl2.M33] - v[webgl2.M00] * v[webgl2.M21] * v[webgl2.M12] * v[webgl2.M33] - v[webgl2.M10] * v[webgl2.M01] * v[webgl2.M22] * v[webgl2.M33] + v[webgl2.M00] * v[webgl2.M11] * v[webgl2.M22] * v[webgl2.M33];
          if (0 == l_det) throw new Error("non-invertible matrix");
          var inv_det = 1 / l_det;
          return t[webgl2.M00] = v[webgl2.M12] * v[webgl2.M23] * v[webgl2.M31] - v[webgl2.M13] * v[webgl2.M22] * v[webgl2.M31] + v[webgl2.M13] * v[webgl2.M21] * v[webgl2.M32] - v[webgl2.M11] * v[webgl2.M23] * v[webgl2.M32] - v[webgl2.M12] * v[webgl2.M21] * v[webgl2.M33] + v[webgl2.M11] * v[webgl2.M22] * v[webgl2.M33], t[webgl2.M01] = v[webgl2.M03] * v[webgl2.M22] * v[webgl2.M31] - v[webgl2.M02] * v[webgl2.M23] * v[webgl2.M31] - v[webgl2.M03] * v[webgl2.M21] * v[webgl2.M32] + v[webgl2.M01] * v[webgl2.M23] * v[webgl2.M32] + v[webgl2.M02] * v[webgl2.M21] * v[webgl2.M33] - v[webgl2.M01] * v[webgl2.M22] * v[webgl2.M33], t[webgl2.M02] = v[webgl2.M02] * v[webgl2.M13] * v[webgl2.M31] - v[webgl2.M03] * v[webgl2.M12] * v[webgl2.M31] + v[webgl2.M03] * v[webgl2.M11] * v[webgl2.M32] - v[webgl2.M01] * v[webgl2.M13] * v[webgl2.M32] - v[webgl2.M02] * v[webgl2.M11] * v[webgl2.M33] + v[webgl2.M01] * v[webgl2.M12] * v[webgl2.M33], t[webgl2.M03] = v[webgl2.M03] * v[webgl2.M12] * v[webgl2.M21] - v[webgl2.M02] * v[webgl2.M13] * v[webgl2.M21] - v[webgl2.M03] * v[webgl2.M11] * v[webgl2.M22] + v[webgl2.M01] * v[webgl2.M13] * v[webgl2.M22] + v[webgl2.M02] * v[webgl2.M11] * v[webgl2.M23] - v[webgl2.M01] * v[webgl2.M12] * v[webgl2.M23], t[webgl2.M10] = v[webgl2.M13] * v[webgl2.M22] * v[webgl2.M30] - v[webgl2.M12] * v[webgl2.M23] * v[webgl2.M30] - v[webgl2.M13] * v[webgl2.M20] * v[webgl2.M32] + v[webgl2.M10] * v[webgl2.M23] * v[webgl2.M32] + v[webgl2.M12] * v[webgl2.M20] * v[webgl2.M33] - v[webgl2.M10] * v[webgl2.M22] * v[webgl2.M33], t[webgl2.M11] = v[webgl2.M02] * v[webgl2.M23] * v[webgl2.M30] - v[webgl2.M03] * v[webgl2.M22] * v[webgl2.M30] + v[webgl2.M03] * v[webgl2.M20] * v[webgl2.M32] - v[webgl2.M00] * v[webgl2.M23] * v[webgl2.M32] - v[webgl2.M02] * v[webgl2.M20] * v[webgl2.M33] + v[webgl2.M00] * v[webgl2.M22] * v[webgl2.M33], t[webgl2.M12] = v[webgl2.M03] * v[webgl2.M12] * v[webgl2.M30] - v[webgl2.M02] * v[webgl2.M13] * v[webgl2.M30] - v[webgl2.M03] * v[webgl2.M10] * v[webgl2.M32] + v[webgl2.M00] * v[webgl2.M13] * v[webgl2.M32] + v[webgl2.M02] * v[webgl2.M10] * v[webgl2.M33] - v[webgl2.M00] * v[webgl2.M12] * v[webgl2.M33], t[webgl2.M13] = v[webgl2.M02] * v[webgl2.M13] * v[webgl2.M20] - v[webgl2.M03] * v[webgl2.M12] * v[webgl2.M20] + v[webgl2.M03] * v[webgl2.M10] * v[webgl2.M22] - v[webgl2.M00] * v[webgl2.M13] * v[webgl2.M22] - v[webgl2.M02] * v[webgl2.M10] * v[webgl2.M23] + v[webgl2.M00] * v[webgl2.M12] * v[webgl2.M23], t[webgl2.M20] = v[webgl2.M11] * v[webgl2.M23] * v[webgl2.M30] - v[webgl2.M13] * v[webgl2.M21] * v[webgl2.M30] + v[webgl2.M13] * v[webgl2.M20] * v[webgl2.M31] - v[webgl2.M10] * v[webgl2.M23] * v[webgl2.M31] - v[webgl2.M11] * v[webgl2.M20] * v[webgl2.M33] + v[webgl2.M10] * v[webgl2.M21] * v[webgl2.M33], t[webgl2.M21] = v[webgl2.M03] * v[webgl2.M21] * v[webgl2.M30] - v[webgl2.M01] * v[webgl2.M23] * v[webgl2.M30] - v[webgl2.M03] * v[webgl2.M20] * v[webgl2.M31] + v[webgl2.M00] * v[webgl2.M23] * v[webgl2.M31] + v[webgl2.M01] * v[webgl2.M20] * v[webgl2.M33] - v[webgl2.M00] * v[webgl2.M21] * v[webgl2.M33], t[webgl2.M22] = v[webgl2.M01] * v[webgl2.M13] * v[webgl2.M30] - v[webgl2.M03] * v[webgl2.M11] * v[webgl2.M30] + v[webgl2.M03] * v[webgl2.M10] * v[webgl2.M31] - v[webgl2.M00] * v[webgl2.M13] * v[webgl2.M31] - v[webgl2.M01] * v[webgl2.M10] * v[webgl2.M33] + v[webgl2.M00] * v[webgl2.M11] * v[webgl2.M33], t[webgl2.M23] = v[webgl2.M03] * v[webgl2.M11] * v[webgl2.M20] - v[webgl2.M01] * v[webgl2.M13] * v[webgl2.M20] - v[webgl2.M03] * v[webgl2.M10] * v[webgl2.M21] + v[webgl2.M00] * v[webgl2.M13] * v[webgl2.M21] + v[webgl2.M01] * v[webgl2.M10] * v[webgl2.M23] - v[webgl2.M00] * v[webgl2.M11] * v[webgl2.M23], t[webgl2.M30] = v[webgl2.M12] * v[webgl2.M21] * v[webgl2.M30] - v[webgl2.M11] * v[webgl2.M22] * v[webgl2.M30] - v[webgl2.M12] * v[webgl2.M20] * v[webgl2.M31] + v[webgl2.M10] * v[webgl2.M22] * v[webgl2.M31] + v[webgl2.M11] * v[webgl2.M20] * v[webgl2.M32] - v[webgl2.M10] * v[webgl2.M21] * v[webgl2.M32], t[webgl2.M31] = v[webgl2.M01] * v[webgl2.M22] * v[webgl2.M30] - v[webgl2.M02] * v[webgl2.M21] * v[webgl2.M30] + v[webgl2.M02] * v[webgl2.M20] * v[webgl2.M31] - v[webgl2.M00] * v[webgl2.M22] * v[webgl2.M31] - v[webgl2.M01] * v[webgl2.M20] * v[webgl2.M32] + v[webgl2.M00] * v[webgl2.M21] * v[webgl2.M32], t[webgl2.M32] = v[webgl2.M02] * v[webgl2.M11] * v[webgl2.M30] - v[webgl2.M01] * v[webgl2.M12] * v[webgl2.M30] - v[webgl2.M02] * v[webgl2.M10] * v[webgl2.M31] + v[webgl2.M00] * v[webgl2.M12] * v[webgl2.M31] + v[webgl2.M01] * v[webgl2.M10] * v[webgl2.M32] - v[webgl2.M00] * v[webgl2.M11] * v[webgl2.M32], t[webgl2.M33] = v[webgl2.M01] * v[webgl2.M12] * v[webgl2.M20] - v[webgl2.M02] * v[webgl2.M11] * v[webgl2.M20] + v[webgl2.M02] * v[webgl2.M10] * v[webgl2.M21] - v[webgl2.M00] * v[webgl2.M12] * v[webgl2.M21] - v[webgl2.M01] * v[webgl2.M10] * v[webgl2.M22] + v[webgl2.M00] * v[webgl2.M11] * v[webgl2.M22], v[webgl2.M00] = t[webgl2.M00] * inv_det, v[webgl2.M01] = t[webgl2.M01] * inv_det, v[webgl2.M02] = t[webgl2.M02] * inv_det, v[webgl2.M03] = t[webgl2.M03] * inv_det, v[webgl2.M10] = t[webgl2.M10] * inv_det, v[webgl2.M11] = t[webgl2.M11] * inv_det, v[webgl2.M12] = t[webgl2.M12] * inv_det, v[webgl2.M13] = t[webgl2.M13] * inv_det, v[webgl2.M20] = t[webgl2.M20] * inv_det, v[webgl2.M21] = t[webgl2.M21] * inv_det, v[webgl2.M22] = t[webgl2.M22] * inv_det, v[webgl2.M23] = t[webgl2.M23] * inv_det, v[webgl2.M30] = t[webgl2.M30] * inv_det, v[webgl2.M31] = t[webgl2.M31] * inv_det, v[webgl2.M32] = t[webgl2.M32] * inv_det, v[webgl2.M33] = t[webgl2.M33] * inv_det, this;
        }, Matrix42.prototype.determinant = function() {
          var v = this.values;
          return v[webgl2.M30] * v[webgl2.M21] * v[webgl2.M12] * v[webgl2.M03] - v[webgl2.M20] * v[webgl2.M31] * v[webgl2.M12] * v[webgl2.M03] - v[webgl2.M30] * v[webgl2.M11] * v[webgl2.M22] * v[webgl2.M03] + v[webgl2.M10] * v[webgl2.M31] * v[webgl2.M22] * v[webgl2.M03] + v[webgl2.M20] * v[webgl2.M11] * v[webgl2.M32] * v[webgl2.M03] - v[webgl2.M10] * v[webgl2.M21] * v[webgl2.M32] * v[webgl2.M03] - v[webgl2.M30] * v[webgl2.M21] * v[webgl2.M02] * v[webgl2.M13] + v[webgl2.M20] * v[webgl2.M31] * v[webgl2.M02] * v[webgl2.M13] + v[webgl2.M30] * v[webgl2.M01] * v[webgl2.M22] * v[webgl2.M13] - v[webgl2.M00] * v[webgl2.M31] * v[webgl2.M22] * v[webgl2.M13] - v[webgl2.M20] * v[webgl2.M01] * v[webgl2.M32] * v[webgl2.M13] + v[webgl2.M00] * v[webgl2.M21] * v[webgl2.M32] * v[webgl2.M13] + v[webgl2.M30] * v[webgl2.M11] * v[webgl2.M02] * v[webgl2.M23] - v[webgl2.M10] * v[webgl2.M31] * v[webgl2.M02] * v[webgl2.M23] - v[webgl2.M30] * v[webgl2.M01] * v[webgl2.M12] * v[webgl2.M23] + v[webgl2.M00] * v[webgl2.M31] * v[webgl2.M12] * v[webgl2.M23] + v[webgl2.M10] * v[webgl2.M01] * v[webgl2.M32] * v[webgl2.M23] - v[webgl2.M00] * v[webgl2.M11] * v[webgl2.M32] * v[webgl2.M23] - v[webgl2.M20] * v[webgl2.M11] * v[webgl2.M02] * v[webgl2.M33] + v[webgl2.M10] * v[webgl2.M21] * v[webgl2.M02] * v[webgl2.M33] + v[webgl2.M20] * v[webgl2.M01] * v[webgl2.M12] * v[webgl2.M33] - v[webgl2.M00] * v[webgl2.M21] * v[webgl2.M12] * v[webgl2.M33] - v[webgl2.M10] * v[webgl2.M01] * v[webgl2.M22] * v[webgl2.M33] + v[webgl2.M00] * v[webgl2.M11] * v[webgl2.M22] * v[webgl2.M33];
        }, Matrix42.prototype.translate = function(x, y, z) {
          var v = this.values;
          return v[webgl2.M03] += x, v[webgl2.M13] += y, v[webgl2.M23] += z, this;
        }, Matrix42.prototype.copy = function() {
          return new Matrix42().set(this.values);
        }, Matrix42.prototype.projection = function(near, far, fovy, aspectRatio) {
          this.identity();
          var l_fd = 1 / Math.tan(fovy * (Math.PI / 180) / 2), l_a1 = (far + near) / (near - far), l_a2 = 2 * far * near / (near - far), v = this.values;
          return v[webgl2.M00] = l_fd / aspectRatio, v[webgl2.M10] = 0, v[webgl2.M20] = 0, v[webgl2.M30] = 0, v[webgl2.M01] = 0, v[webgl2.M11] = l_fd, v[webgl2.M21] = 0, v[webgl2.M31] = 0, v[webgl2.M02] = 0, v[webgl2.M12] = 0, v[webgl2.M22] = l_a1, v[webgl2.M32] = -1, v[webgl2.M03] = 0, v[webgl2.M13] = 0, v[webgl2.M23] = l_a2, v[webgl2.M33] = 0, this;
        }, Matrix42.prototype.ortho2d = function(x, y, width, height) {
          return this.ortho(x, x + width, y, y + height, 0, 1);
        }, Matrix42.prototype.ortho = function(left, right, bottom, top, near, far) {
          this.identity();
          var x_orth = 2 / (right - left), y_orth = 2 / (top - bottom), z_orth = -2 / (far - near), tx = -(right + left) / (right - left), ty = -(top + bottom) / (top - bottom), tz = -(far + near) / (far - near), v = this.values;
          return v[webgl2.M00] = x_orth, v[webgl2.M10] = 0, v[webgl2.M20] = 0, v[webgl2.M30] = 0, v[webgl2.M01] = 0, v[webgl2.M11] = y_orth, v[webgl2.M21] = 0, v[webgl2.M31] = 0, v[webgl2.M02] = 0, v[webgl2.M12] = 0, v[webgl2.M22] = z_orth, v[webgl2.M32] = 0, v[webgl2.M03] = tx, v[webgl2.M13] = ty, v[webgl2.M23] = tz, v[webgl2.M33] = 1, this;
        }, Matrix42.prototype.multiply = function(matrix) {
          var t = this.temp, v = this.values, m = matrix.values;
          return t[webgl2.M00] = v[webgl2.M00] * m[webgl2.M00] + v[webgl2.M01] * m[webgl2.M10] + v[webgl2.M02] * m[webgl2.M20] + v[webgl2.M03] * m[webgl2.M30], t[webgl2.M01] = v[webgl2.M00] * m[webgl2.M01] + v[webgl2.M01] * m[webgl2.M11] + v[webgl2.M02] * m[webgl2.M21] + v[webgl2.M03] * m[webgl2.M31], t[webgl2.M02] = v[webgl2.M00] * m[webgl2.M02] + v[webgl2.M01] * m[webgl2.M12] + v[webgl2.M02] * m[webgl2.M22] + v[webgl2.M03] * m[webgl2.M32], t[webgl2.M03] = v[webgl2.M00] * m[webgl2.M03] + v[webgl2.M01] * m[webgl2.M13] + v[webgl2.M02] * m[webgl2.M23] + v[webgl2.M03] * m[webgl2.M33], t[webgl2.M10] = v[webgl2.M10] * m[webgl2.M00] + v[webgl2.M11] * m[webgl2.M10] + v[webgl2.M12] * m[webgl2.M20] + v[webgl2.M13] * m[webgl2.M30], t[webgl2.M11] = v[webgl2.M10] * m[webgl2.M01] + v[webgl2.M11] * m[webgl2.M11] + v[webgl2.M12] * m[webgl2.M21] + v[webgl2.M13] * m[webgl2.M31], t[webgl2.M12] = v[webgl2.M10] * m[webgl2.M02] + v[webgl2.M11] * m[webgl2.M12] + v[webgl2.M12] * m[webgl2.M22] + v[webgl2.M13] * m[webgl2.M32], t[webgl2.M13] = v[webgl2.M10] * m[webgl2.M03] + v[webgl2.M11] * m[webgl2.M13] + v[webgl2.M12] * m[webgl2.M23] + v[webgl2.M13] * m[webgl2.M33], t[webgl2.M20] = v[webgl2.M20] * m[webgl2.M00] + v[webgl2.M21] * m[webgl2.M10] + v[webgl2.M22] * m[webgl2.M20] + v[webgl2.M23] * m[webgl2.M30], t[webgl2.M21] = v[webgl2.M20] * m[webgl2.M01] + v[webgl2.M21] * m[webgl2.M11] + v[webgl2.M22] * m[webgl2.M21] + v[webgl2.M23] * m[webgl2.M31], t[webgl2.M22] = v[webgl2.M20] * m[webgl2.M02] + v[webgl2.M21] * m[webgl2.M12] + v[webgl2.M22] * m[webgl2.M22] + v[webgl2.M23] * m[webgl2.M32], t[webgl2.M23] = v[webgl2.M20] * m[webgl2.M03] + v[webgl2.M21] * m[webgl2.M13] + v[webgl2.M22] * m[webgl2.M23] + v[webgl2.M23] * m[webgl2.M33], t[webgl2.M30] = v[webgl2.M30] * m[webgl2.M00] + v[webgl2.M31] * m[webgl2.M10] + v[webgl2.M32] * m[webgl2.M20] + v[webgl2.M33] * m[webgl2.M30], t[webgl2.M31] = v[webgl2.M30] * m[webgl2.M01] + v[webgl2.M31] * m[webgl2.M11] + v[webgl2.M32] * m[webgl2.M21] + v[webgl2.M33] * m[webgl2.M31], t[webgl2.M32] = v[webgl2.M30] * m[webgl2.M02] + v[webgl2.M31] * m[webgl2.M12] + v[webgl2.M32] * m[webgl2.M22] + v[webgl2.M33] * m[webgl2.M32], t[webgl2.M33] = v[webgl2.M30] * m[webgl2.M03] + v[webgl2.M31] * m[webgl2.M13] + v[webgl2.M32] * m[webgl2.M23] + v[webgl2.M33] * m[webgl2.M33], this.set(this.temp);
        }, Matrix42.prototype.multiplyLeft = function(matrix) {
          var t = this.temp, v = this.values, m = matrix.values;
          return t[webgl2.M00] = m[webgl2.M00] * v[webgl2.M00] + m[webgl2.M01] * v[webgl2.M10] + m[webgl2.M02] * v[webgl2.M20] + m[webgl2.M03] * v[webgl2.M30], t[webgl2.M01] = m[webgl2.M00] * v[webgl2.M01] + m[webgl2.M01] * v[webgl2.M11] + m[webgl2.M02] * v[webgl2.M21] + m[webgl2.M03] * v[webgl2.M31], t[webgl2.M02] = m[webgl2.M00] * v[webgl2.M02] + m[webgl2.M01] * v[webgl2.M12] + m[webgl2.M02] * v[webgl2.M22] + m[webgl2.M03] * v[webgl2.M32], t[webgl2.M03] = m[webgl2.M00] * v[webgl2.M03] + m[webgl2.M01] * v[webgl2.M13] + m[webgl2.M02] * v[webgl2.M23] + m[webgl2.M03] * v[webgl2.M33], t[webgl2.M10] = m[webgl2.M10] * v[webgl2.M00] + m[webgl2.M11] * v[webgl2.M10] + m[webgl2.M12] * v[webgl2.M20] + m[webgl2.M13] * v[webgl2.M30], t[webgl2.M11] = m[webgl2.M10] * v[webgl2.M01] + m[webgl2.M11] * v[webgl2.M11] + m[webgl2.M12] * v[webgl2.M21] + m[webgl2.M13] * v[webgl2.M31], t[webgl2.M12] = m[webgl2.M10] * v[webgl2.M02] + m[webgl2.M11] * v[webgl2.M12] + m[webgl2.M12] * v[webgl2.M22] + m[webgl2.M13] * v[webgl2.M32], t[webgl2.M13] = m[webgl2.M10] * v[webgl2.M03] + m[webgl2.M11] * v[webgl2.M13] + m[webgl2.M12] * v[webgl2.M23] + m[webgl2.M13] * v[webgl2.M33], t[webgl2.M20] = m[webgl2.M20] * v[webgl2.M00] + m[webgl2.M21] * v[webgl2.M10] + m[webgl2.M22] * v[webgl2.M20] + m[webgl2.M23] * v[webgl2.M30], t[webgl2.M21] = m[webgl2.M20] * v[webgl2.M01] + m[webgl2.M21] * v[webgl2.M11] + m[webgl2.M22] * v[webgl2.M21] + m[webgl2.M23] * v[webgl2.M31], t[webgl2.M22] = m[webgl2.M20] * v[webgl2.M02] + m[webgl2.M21] * v[webgl2.M12] + m[webgl2.M22] * v[webgl2.M22] + m[webgl2.M23] * v[webgl2.M32], t[webgl2.M23] = m[webgl2.M20] * v[webgl2.M03] + m[webgl2.M21] * v[webgl2.M13] + m[webgl2.M22] * v[webgl2.M23] + m[webgl2.M23] * v[webgl2.M33], t[webgl2.M30] = m[webgl2.M30] * v[webgl2.M00] + m[webgl2.M31] * v[webgl2.M10] + m[webgl2.M32] * v[webgl2.M20] + m[webgl2.M33] * v[webgl2.M30], t[webgl2.M31] = m[webgl2.M30] * v[webgl2.M01] + m[webgl2.M31] * v[webgl2.M11] + m[webgl2.M32] * v[webgl2.M21] + m[webgl2.M33] * v[webgl2.M31], t[webgl2.M32] = m[webgl2.M30] * v[webgl2.M02] + m[webgl2.M31] * v[webgl2.M12] + m[webgl2.M32] * v[webgl2.M22] + m[webgl2.M33] * v[webgl2.M32], t[webgl2.M33] = m[webgl2.M30] * v[webgl2.M03] + m[webgl2.M31] * v[webgl2.M13] + m[webgl2.M32] * v[webgl2.M23] + m[webgl2.M33] * v[webgl2.M33], this.set(this.temp);
        }, Matrix42.prototype.lookAt = function(position, direction, up) {
          Matrix42.initTemps();
          var xAxis = Matrix42.xAxis, yAxis = Matrix42.yAxis, zAxis = Matrix42.zAxis;
          zAxis.setFrom(direction).normalize(), xAxis.setFrom(direction).normalize(), xAxis.cross(up).normalize(), yAxis.setFrom(xAxis).cross(zAxis).normalize(), this.identity();
          var val = this.values;
          return val[webgl2.M00] = xAxis.x, val[webgl2.M01] = xAxis.y, val[webgl2.M02] = xAxis.z, val[webgl2.M10] = yAxis.x, val[webgl2.M11] = yAxis.y, val[webgl2.M12] = yAxis.z, val[webgl2.M20] = -zAxis.x, val[webgl2.M21] = -zAxis.y, val[webgl2.M22] = -zAxis.z, Matrix42.tmpMatrix.identity(), Matrix42.tmpMatrix.values[webgl2.M03] = -position.x, Matrix42.tmpMatrix.values[webgl2.M13] = -position.y, Matrix42.tmpMatrix.values[webgl2.M23] = -position.z, this.multiply(Matrix42.tmpMatrix), this;
        }, Matrix42.initTemps = function() {
          null === Matrix42.xAxis && (Matrix42.xAxis = new webgl2.Vector3()), null === Matrix42.yAxis && (Matrix42.yAxis = new webgl2.Vector3()), null === Matrix42.zAxis && (Matrix42.zAxis = new webgl2.Vector3());
        }, Matrix42.xAxis = null, Matrix42.yAxis = null, Matrix42.zAxis = null, Matrix42.tmpMatrix = new Matrix42(), Matrix42;
      })();
      webgl2.Matrix4 = Matrix4;
    })(spine4.webgl || (spine4.webgl = {}));
  })(spine || (spine = {})), (function(spine4) {
    !(function(webgl2) {
      var Mesh = (function() {
        function Mesh2(context, attributes, maxVertices, maxIndices) {
          this.attributes = attributes, this.verticesLength = 0, this.dirtyVertices = false, this.indicesLength = 0, this.dirtyIndices = false, this.elementsPerVertex = 0, this.context = context instanceof webgl2.ManagedWebGLRenderingContext ? context : new webgl2.ManagedWebGLRenderingContext(context), this.elementsPerVertex = 0;
          for (var i = 0; i < attributes.length; i++) this.elementsPerVertex += attributes[i].numElements;
          this.vertices = new Float32Array(maxVertices * this.elementsPerVertex), this.indices = new Uint16Array(maxIndices), this.context.addRestorable(this);
        }
        return Mesh2.prototype.getAttributes = function() {
          return this.attributes;
        }, Mesh2.prototype.maxVertices = function() {
          return this.vertices.length / this.elementsPerVertex;
        }, Mesh2.prototype.numVertices = function() {
          return this.verticesLength / this.elementsPerVertex;
        }, Mesh2.prototype.setVerticesLength = function(length) {
          this.dirtyVertices = true, this.verticesLength = length;
        }, Mesh2.prototype.getVertices = function() {
          return this.vertices;
        }, Mesh2.prototype.maxIndices = function() {
          return this.indices.length;
        }, Mesh2.prototype.numIndices = function() {
          return this.indicesLength;
        }, Mesh2.prototype.setIndicesLength = function(length) {
          this.dirtyIndices = true, this.indicesLength = length;
        }, Mesh2.prototype.getIndices = function() {
          return this.indices;
        }, Mesh2.prototype.getVertexSizeInFloats = function() {
          for (var size = 0, i = 0; i < this.attributes.length; i++) {
            size += this.attributes[i].numElements;
          }
          return size;
        }, Mesh2.prototype.setVertices = function(vertices) {
          if (this.dirtyVertices = true, vertices.length > this.vertices.length) throw Error("Mesh can't store more than " + this.maxVertices() + " vertices");
          this.vertices.set(vertices, 0), this.verticesLength = vertices.length;
        }, Mesh2.prototype.setIndices = function(indices) {
          if (this.dirtyIndices = true, indices.length > this.indices.length) throw Error("Mesh can't store more than " + this.maxIndices() + " indices");
          this.indices.set(indices, 0), this.indicesLength = indices.length;
        }, Mesh2.prototype.draw = function(shader, primitiveType) {
          this.drawWithOffset(shader, primitiveType, 0, this.indicesLength > 0 ? this.indicesLength : this.verticesLength / this.elementsPerVertex);
        }, Mesh2.prototype.drawWithOffset = function(shader, primitiveType, offset, count) {
          var gl = this.context.gl;
          (this.dirtyVertices || this.dirtyIndices) && this.update(), this.bind(shader), this.indicesLength > 0 ? gl.drawElements(primitiveType, count, gl.UNSIGNED_SHORT, 2 * offset) : gl.drawArrays(primitiveType, offset, count), this.unbind(shader);
        }, Mesh2.prototype.bind = function(shader) {
          var gl = this.context.gl;
          gl.bindBuffer(gl.ARRAY_BUFFER, this.verticesBuffer);
          for (var offset = 0, i = 0; i < this.attributes.length; i++) {
            var attrib = this.attributes[i], location_1 = shader.getAttributeLocation(attrib.name);
            gl.enableVertexAttribArray(location_1), gl.vertexAttribPointer(location_1, attrib.numElements, gl.FLOAT, false, 4 * this.elementsPerVertex, 4 * offset), offset += attrib.numElements;
          }
          this.indicesLength > 0 && gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);
        }, Mesh2.prototype.unbind = function(shader) {
          for (var gl = this.context.gl, i = 0; i < this.attributes.length; i++) {
            var attrib = this.attributes[i], location_2 = shader.getAttributeLocation(attrib.name);
            gl.disableVertexAttribArray(location_2);
          }
          gl.bindBuffer(gl.ARRAY_BUFFER, null), this.indicesLength > 0 && gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        }, Mesh2.prototype.update = function() {
          var gl = this.context.gl;
          this.dirtyVertices && (this.verticesBuffer || (this.verticesBuffer = gl.createBuffer()), gl.bindBuffer(gl.ARRAY_BUFFER, this.verticesBuffer), gl.bufferData(gl.ARRAY_BUFFER, this.vertices.subarray(0, this.verticesLength), gl.DYNAMIC_DRAW), this.dirtyVertices = false), this.dirtyIndices && (this.indicesBuffer || (this.indicesBuffer = gl.createBuffer()), gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer), gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices.subarray(0, this.indicesLength), gl.DYNAMIC_DRAW), this.dirtyIndices = false);
        }, Mesh2.prototype.restore = function() {
          this.verticesBuffer = null, this.indicesBuffer = null, this.update();
        }, Mesh2.prototype.dispose = function() {
          this.context.removeRestorable(this);
          var gl = this.context.gl;
          gl.deleteBuffer(this.verticesBuffer), gl.deleteBuffer(this.indicesBuffer);
        }, Mesh2;
      })();
      webgl2.Mesh = Mesh;
      var VertexAttribute = /* @__PURE__ */ (function() {
        function VertexAttribute2(name, type, numElements) {
          this.name = name, this.type = type, this.numElements = numElements;
        }
        return VertexAttribute2;
      })();
      webgl2.VertexAttribute = VertexAttribute;
      var Position2Attribute = (function(_super) {
        function Position2Attribute2() {
          return _super.call(this, webgl2.Shader.POSITION, VertexAttributeType.Float, 2) || this;
        }
        return __extends(Position2Attribute2, _super), Position2Attribute2;
      })(VertexAttribute);
      webgl2.Position2Attribute = Position2Attribute;
      var Position3Attribute = (function(_super) {
        function Position3Attribute2() {
          return _super.call(this, webgl2.Shader.POSITION, VertexAttributeType.Float, 3) || this;
        }
        return __extends(Position3Attribute2, _super), Position3Attribute2;
      })(VertexAttribute);
      webgl2.Position3Attribute = Position3Attribute;
      var TexCoordAttribute = (function(_super) {
        function TexCoordAttribute2(unit) {
          return void 0 === unit && (unit = 0), _super.call(this, webgl2.Shader.TEXCOORDS + (0 == unit ? "" : unit), VertexAttributeType.Float, 2) || this;
        }
        return __extends(TexCoordAttribute2, _super), TexCoordAttribute2;
      })(VertexAttribute);
      webgl2.TexCoordAttribute = TexCoordAttribute;
      var ColorAttribute = (function(_super) {
        function ColorAttribute2() {
          return _super.call(this, webgl2.Shader.COLOR, VertexAttributeType.Float, 4) || this;
        }
        return __extends(ColorAttribute2, _super), ColorAttribute2;
      })(VertexAttribute);
      webgl2.ColorAttribute = ColorAttribute;
      var Color2Attribute = (function(_super) {
        function Color2Attribute2() {
          return _super.call(this, webgl2.Shader.COLOR2, VertexAttributeType.Float, 4) || this;
        }
        return __extends(Color2Attribute2, _super), Color2Attribute2;
      })(VertexAttribute), VertexAttributeType;
      webgl2.Color2Attribute = Color2Attribute, (function(VertexAttributeType2) {
        VertexAttributeType2[VertexAttributeType2.Float = 0] = "Float";
      })(VertexAttributeType = webgl2.VertexAttributeType || (webgl2.VertexAttributeType = {}));
    })(spine4.webgl || (spine4.webgl = {}));
  })(spine || (spine = {})), (function(spine4) {
    !(function(webgl2) {
      var PolygonBatcher = (function() {
        function PolygonBatcher2(context, twoColorTint, maxVertices) {
          if (void 0 === twoColorTint && (twoColorTint = true), void 0 === maxVertices && (maxVertices = 10920), this.isDrawing = false, this.shader = null, this.lastTexture = null, this.verticesLength = 0, this.indicesLength = 0, maxVertices > 10920) throw new Error("Can't have more than 10920 triangles per batch: " + maxVertices);
          this.context = context instanceof webgl2.ManagedWebGLRenderingContext ? context : new webgl2.ManagedWebGLRenderingContext(context);
          var attributes = twoColorTint ? [new webgl2.Position2Attribute(), new webgl2.ColorAttribute(), new webgl2.TexCoordAttribute(), new webgl2.Color2Attribute()] : [new webgl2.Position2Attribute(), new webgl2.ColorAttribute(), new webgl2.TexCoordAttribute()];
          this.mesh = new webgl2.Mesh(context, attributes, maxVertices, 3 * maxVertices), this.srcBlend = this.context.gl.SRC_ALPHA, this.dstBlend = this.context.gl.ONE_MINUS_SRC_ALPHA;
        }
        return PolygonBatcher2.prototype.begin = function(shader) {
          var gl = this.context.gl;
          if (this.isDrawing) throw new Error("PolygonBatch is already drawing. Call PolygonBatch.end() before calling PolygonBatch.begin()");
          this.drawCalls = 0, this.shader = shader, this.lastTexture = null, this.isDrawing = true, gl.enable(gl.BLEND), gl.blendFunc(this.srcBlend, this.dstBlend);
        }, PolygonBatcher2.prototype.setBlendMode = function(srcBlend, dstBlend) {
          var gl = this.context.gl;
          this.srcBlend = srcBlend, this.dstBlend = dstBlend, this.isDrawing && (this.flush(), gl.blendFunc(this.srcBlend, this.dstBlend));
        }, PolygonBatcher2.prototype.draw = function(texture, vertices, indices) {
          texture != this.lastTexture ? (this.flush(), this.lastTexture = texture) : (this.verticesLength + vertices.length > this.mesh.getVertices().length || this.indicesLength + indices.length > this.mesh.getIndices().length) && this.flush();
          var indexStart = this.mesh.numVertices();
          this.mesh.getVertices().set(vertices, this.verticesLength), this.verticesLength += vertices.length, this.mesh.setVerticesLength(this.verticesLength);
          for (var indicesArray = this.mesh.getIndices(), i = this.indicesLength, j = 0; j < indices.length; i++, j++) indicesArray[i] = indices[j] + indexStart;
          this.indicesLength += indices.length, this.mesh.setIndicesLength(this.indicesLength);
        }, PolygonBatcher2.prototype.flush = function() {
          var gl = this.context.gl;
          0 != this.verticesLength && (this.lastTexture.bind(), this.mesh.draw(this.shader, gl.TRIANGLES), this.verticesLength = 0, this.indicesLength = 0, this.mesh.setVerticesLength(0), this.mesh.setIndicesLength(0), this.drawCalls++);
        }, PolygonBatcher2.prototype.end = function() {
          var gl = this.context.gl;
          if (!this.isDrawing) throw new Error("PolygonBatch is not drawing. Call PolygonBatch.begin() before calling PolygonBatch.end()");
          (this.verticesLength > 0 || this.indicesLength > 0) && this.flush(), this.shader = null, this.lastTexture = null, this.isDrawing = false, gl.disable(gl.BLEND);
        }, PolygonBatcher2.prototype.getDrawCalls = function() {
          return this.drawCalls;
        }, PolygonBatcher2.prototype.dispose = function() {
          this.mesh.dispose();
        }, PolygonBatcher2;
      })();
      webgl2.PolygonBatcher = PolygonBatcher;
    })(spine4.webgl || (spine4.webgl = {}));
  })(spine || (spine = {})), (function(spine4) {
    !(function(webgl2) {
      var SceneRenderer = (function() {
        function SceneRenderer2(canvas, context, twoColorTint) {
          void 0 === twoColorTint && (twoColorTint = true), this.twoColorTint = false, this.activeRenderer = null, this.QUAD = [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0], this.QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0], this.WHITE = new spine4.Color(1, 1, 1, 1), this.canvas = canvas, this.context = context instanceof webgl2.ManagedWebGLRenderingContext ? context : new webgl2.ManagedWebGLRenderingContext(context), this.twoColorTint = twoColorTint, this.camera = new webgl2.OrthoCamera(canvas.width, canvas.height), this.batcherShader = twoColorTint ? webgl2.Shader.newTwoColoredTextured(this.context) : webgl2.Shader.newColoredTextured(this.context), this.batcher = new webgl2.PolygonBatcher(this.context, twoColorTint), this.shapesShader = webgl2.Shader.newColored(this.context), this.shapes = new webgl2.ShapeRenderer(this.context), this.skeletonRenderer = new webgl2.SkeletonRenderer(this.context, twoColorTint), this.skeletonDebugRenderer = new webgl2.SkeletonDebugRenderer(this.context);
        }
        return SceneRenderer2.prototype.begin = function() {
          this.camera.update(), this.enableRenderer(this.batcher);
        }, SceneRenderer2.prototype.drawSkeleton = function(skeleton2, premultipliedAlpha, slotRangeStart, slotRangeEnd) {
          void 0 === premultipliedAlpha && (premultipliedAlpha = false), void 0 === slotRangeStart && (slotRangeStart = -1), void 0 === slotRangeEnd && (slotRangeEnd = -1), this.enableRenderer(this.batcher), this.skeletonRenderer.premultipliedAlpha = premultipliedAlpha, this.skeletonRenderer.draw(this.batcher, Skeleton, slotRangeStart, slotRangeEnd);
        }, SceneRenderer2.prototype.drawSkeletonDebug = function(skeleton2, premultipliedAlpha, ignoredBones) {
          void 0 === premultipliedAlpha && (premultipliedAlpha = false), void 0 === ignoredBones && (ignoredBones = null), this.enableRenderer(this.shapes), this.skeletonDebugRenderer.premultipliedAlpha = premultipliedAlpha, this.skeletonDebugRenderer.draw(this.shapes, Skeleton, ignoredBones);
        }, SceneRenderer2.prototype.drawTexture = function(texture, x, y, width, height, color) {
          void 0 === color && (color = null), this.enableRenderer(this.batcher), null === color && (color = this.WHITE);
          var quad = this.QUAD, i = 0;
          quad[i++] = x, quad[i++] = y, quad[i++] = color.r, quad[i++] = color.g, quad[i++] = color.b, quad[i++] = color.a, quad[i++] = 0, quad[i++] = 1, this.twoColorTint && (quad[i++] = 0, quad[i++] = 0, quad[i++] = 0, quad[i++] = 0), quad[i++] = x + width, quad[i++] = y, quad[i++] = color.r, quad[i++] = color.g, quad[i++] = color.b, quad[i++] = color.a, quad[i++] = 1, quad[i++] = 1, this.twoColorTint && (quad[i++] = 0, quad[i++] = 0, quad[i++] = 0, quad[i++] = 0), quad[i++] = x + width, quad[i++] = y + height, quad[i++] = color.r, quad[i++] = color.g, quad[i++] = color.b, quad[i++] = color.a, quad[i++] = 1, quad[i++] = 0, this.twoColorTint && (quad[i++] = 0, quad[i++] = 0, quad[i++] = 0, quad[i++] = 0), quad[i++] = x, quad[i++] = y + height, quad[i++] = color.r, quad[i++] = color.g, quad[i++] = color.b, quad[i++] = color.a, quad[i++] = 0, quad[i++] = 0, this.twoColorTint && (quad[i++] = 0, quad[i++] = 0, quad[i++] = 0, quad[i++] = 0), this.batcher.draw(texture, quad, this.QUAD_TRIANGLES);
        }, SceneRenderer2.prototype.drawTextureUV = function(texture, x, y, width, height, u, v, u2, v2, color) {
          void 0 === color && (color = null), this.enableRenderer(this.batcher), null === color && (color = this.WHITE);
          var quad = this.QUAD, i = 0;
          quad[i++] = x, quad[i++] = y, quad[i++] = color.r, quad[i++] = color.g, quad[i++] = color.b, quad[i++] = color.a, quad[i++] = u, quad[i++] = v, this.twoColorTint && (quad[i++] = 0, quad[i++] = 0, quad[i++] = 0, quad[i++] = 0), quad[i++] = x + width, quad[i++] = y, quad[i++] = color.r, quad[i++] = color.g, quad[i++] = color.b, quad[i++] = color.a, quad[i++] = u2, quad[i++] = v, this.twoColorTint && (quad[i++] = 0, quad[i++] = 0, quad[i++] = 0, quad[i++] = 0), quad[i++] = x + width, quad[i++] = y + height, quad[i++] = color.r, quad[i++] = color.g, quad[i++] = color.b, quad[i++] = color.a, quad[i++] = u2, quad[i++] = v2, this.twoColorTint && (quad[i++] = 0, quad[i++] = 0, quad[i++] = 0, quad[i++] = 0), quad[i++] = x, quad[i++] = y + height, quad[i++] = color.r, quad[i++] = color.g, quad[i++] = color.b, quad[i++] = color.a, quad[i++] = u, quad[i++] = v2, this.twoColorTint && (quad[i++] = 0, quad[i++] = 0, quad[i++] = 0, quad[i++] = 0), this.batcher.draw(texture, quad, this.QUAD_TRIANGLES);
        }, SceneRenderer2.prototype.drawTextureRotated = function(texture, x, y, width, height, pivotX, pivotY, angle, color, premultipliedAlpha) {
          void 0 === color && (color = null), this.enableRenderer(this.batcher), null === color && (color = this.WHITE);
          var quad = this.QUAD, worldOriginX = x + pivotX, worldOriginY = y + pivotY, fx = -pivotX, fy = -pivotY, fx2 = width - pivotX, fy2 = height - pivotY, p1x = fx, p1y = fy, p2x = fx, p2y = fy2, p3x = fx2, p3y = fy2, p4x = fx2, p4y = fy, x1 = 0, y1 = 0, x2 = 0, y2 = 0, x3 = 0, y3 = 0, x4 = 0, y4 = 0;
          if (0 != angle) {
            var cos = spine4.MathUtils.cosDeg(angle), sin = spine4.MathUtils.sinDeg(angle);
            x2 = (x3 = cos * p3x - sin * p3y) + ((x1 = cos * p1x - sin * p1y) - (x4 = cos * p2x - sin * p2y)), y2 = (y3 = sin * p3x + cos * p3y) + ((y1 = sin * p1x + cos * p1y) - (y4 = sin * p2x + cos * p2y));
          } else x1 = p1x, y1 = p1y, x4 = p2x, y4 = p2y, x3 = p3x, y3 = p3y, x2 = p4x, y2 = p4y;
          x1 += worldOriginX, y1 += worldOriginY, x2 += worldOriginX, y2 += worldOriginY, x3 += worldOriginX, y3 += worldOriginY, x4 += worldOriginX, y4 += worldOriginY;
          var i = 0;
          quad[i++] = x1, quad[i++] = y1, quad[i++] = color.r, quad[i++] = color.g, quad[i++] = color.b, quad[i++] = color.a, quad[i++] = 0, quad[i++] = 1, this.twoColorTint && (quad[i++] = 0, quad[i++] = 0, quad[i++] = 0, quad[i++] = 0), quad[i++] = x2, quad[i++] = y2, quad[i++] = color.r, quad[i++] = color.g, quad[i++] = color.b, quad[i++] = color.a, quad[i++] = 1, quad[i++] = 1, this.twoColorTint && (quad[i++] = 0, quad[i++] = 0, quad[i++] = 0, quad[i++] = 0), quad[i++] = x3, quad[i++] = y3, quad[i++] = color.r, quad[i++] = color.g, quad[i++] = color.b, quad[i++] = color.a, quad[i++] = 1, quad[i++] = 0, this.twoColorTint && (quad[i++] = 0, quad[i++] = 0, quad[i++] = 0, quad[i++] = 0), quad[i++] = x4, quad[i++] = y4, quad[i++] = color.r, quad[i++] = color.g, quad[i++] = color.b, quad[i++] = color.a, quad[i++] = 0, quad[i++] = 0, this.twoColorTint && (quad[i++] = 0, quad[i++] = 0, quad[i++] = 0, quad[i++] = 0), this.batcher.draw(texture, quad, this.QUAD_TRIANGLES);
        }, SceneRenderer2.prototype.drawRegion = function(region, x, y, width, height, color, premultipliedAlpha) {
          void 0 === color && (color = null), this.enableRenderer(this.batcher), null === color && (color = this.WHITE);
          var quad = this.QUAD, i = 0;
          quad[i++] = x, quad[i++] = y, quad[i++] = color.r, quad[i++] = color.g, quad[i++] = color.b, quad[i++] = color.a, quad[i++] = region.u, quad[i++] = region.v2, this.twoColorTint && (quad[i++] = 0, quad[i++] = 0, quad[i++] = 0, quad[i++] = 0), quad[i++] = x + width, quad[i++] = y, quad[i++] = color.r, quad[i++] = color.g, quad[i++] = color.b, quad[i++] = color.a, quad[i++] = region.u2, quad[i++] = region.v2, this.twoColorTint && (quad[i++] = 0, quad[i++] = 0, quad[i++] = 0, quad[i++] = 0), quad[i++] = x + width, quad[i++] = y + height, quad[i++] = color.r, quad[i++] = color.g, quad[i++] = color.b, quad[i++] = color.a, quad[i++] = region.u2, quad[i++] = region.v, this.twoColorTint && (quad[i++] = 0, quad[i++] = 0, quad[i++] = 0, quad[i++] = 0), quad[i++] = x, quad[i++] = y + height, quad[i++] = color.r, quad[i++] = color.g, quad[i++] = color.b, quad[i++] = color.a, quad[i++] = region.u, quad[i++] = region.v, this.twoColorTint && (quad[i++] = 0, quad[i++] = 0, quad[i++] = 0, quad[i++] = 0), this.batcher.draw(region.texture, quad, this.QUAD_TRIANGLES);
        }, SceneRenderer2.prototype.line = function(x, y, x2, y2, color, color2) {
          void 0 === color && (color = null), this.enableRenderer(this.shapes), this.shapes.line(x, y, x2, y2, color);
        }, SceneRenderer2.prototype.triangle = function(filled, x, y, x2, y2, x3, y3, color, color2, color3) {
          void 0 === color && (color = null), void 0 === color2 && (color2 = null), void 0 === color3 && (color3 = null), this.enableRenderer(this.shapes), this.shapes.triangle(filled, x, y, x2, y2, x3, y3, color, color2, color3);
        }, SceneRenderer2.prototype.quad = function(filled, x, y, x2, y2, x3, y3, x4, y4, color, color2, color3, color4) {
          void 0 === color && (color = null), void 0 === color2 && (color2 = null), void 0 === color3 && (color3 = null), void 0 === color4 && (color4 = null), this.enableRenderer(this.shapes), this.shapes.quad(filled, x, y, x2, y2, x3, y3, x4, y4, color, color2, color3, color4);
        }, SceneRenderer2.prototype.rect = function(filled, x, y, width, height, color) {
          void 0 === color && (color = null), this.enableRenderer(this.shapes), this.shapes.rect(filled, x, y, width, height, color);
        }, SceneRenderer2.prototype.rectLine = function(filled, x1, y1, x2, y2, width, color) {
          void 0 === color && (color = null), this.enableRenderer(this.shapes), this.shapes.rectLine(filled, x1, y1, x2, y2, width, color);
        }, SceneRenderer2.prototype.polygon = function(polygonVertices, offset, count, color) {
          void 0 === color && (color = null), this.enableRenderer(this.shapes), this.shapes.polygon(polygonVertices, offset, count, color);
        }, SceneRenderer2.prototype.circle = function(filled, x, y, radius, color, segments) {
          void 0 === color && (color = null), void 0 === segments && (segments = 0), this.enableRenderer(this.shapes), this.shapes.circle(filled, x, y, radius, color, segments);
        }, SceneRenderer2.prototype.curve = function(x1, y1, cx1, cy1, cx2, cy2, x2, y2, segments, color) {
          void 0 === color && (color = null), this.enableRenderer(this.shapes), this.shapes.curve(x1, y1, cx1, cy1, cx2, cy2, x2, y2, segments, color);
        }, SceneRenderer2.prototype.end = function() {
          this.activeRenderer === this.batcher ? this.batcher.end() : this.activeRenderer === this.shapes && this.shapes.end(), this.activeRenderer = null;
        }, SceneRenderer2.prototype.resize = function(resizeMode) {
          var canvas = this.canvas, w = canvas.clientWidth, h = canvas.clientHeight;
          if (canvas.width == w && canvas.height == h || (canvas.width = w, canvas.height = h), this.context.gl.viewport(0, 0, canvas.width, canvas.height), resizeMode === ResizeMode.Stretch) ;
          else if (resizeMode === ResizeMode.Expand) this.camera.setViewport(w, h);
          else if (resizeMode === ResizeMode.Fit) {
            var sourceWidth = canvas.width, sourceHeight = canvas.height, targetWidth = this.camera.viewportWidth, targetHeight = this.camera.viewportHeight, scale = targetHeight / targetWidth < sourceHeight / sourceWidth ? targetWidth / sourceWidth : targetHeight / sourceHeight;
            this.camera.viewportWidth = sourceWidth * scale, this.camera.viewportHeight = sourceHeight * scale;
          }
          this.camera.update();
        }, SceneRenderer2.prototype.enableRenderer = function(renderer) {
          this.activeRenderer !== renderer && (this.end(), renderer instanceof webgl2.PolygonBatcher ? (this.batcherShader.bind(), this.batcherShader.setUniform4x4f(webgl2.Shader.MVP_MATRIX, this.camera.projectionView.values), this.batcherShader.setUniformi("u_texture", 0), this.batcher.begin(this.batcherShader), this.activeRenderer = this.batcher) : renderer instanceof webgl2.ShapeRenderer ? (this.shapesShader.bind(), this.shapesShader.setUniform4x4f(webgl2.Shader.MVP_MATRIX, this.camera.projectionView.values), this.shapes.begin(this.shapesShader), this.activeRenderer = this.shapes) : this.activeRenderer = this.skeletonDebugRenderer);
        }, SceneRenderer2.prototype.dispose = function() {
          this.batcher.dispose(), this.batcherShader.dispose(), this.shapes.dispose(), this.shapesShader.dispose(), this.skeletonDebugRenderer.dispose();
        }, SceneRenderer2;
      })(), ResizeMode;
      webgl2.SceneRenderer = SceneRenderer, (function(ResizeMode2) {
        ResizeMode2[ResizeMode2.Stretch = 0] = "Stretch", ResizeMode2[ResizeMode2.Expand = 1] = "Expand", ResizeMode2[ResizeMode2.Fit = 2] = "Fit";
      })(ResizeMode = webgl2.ResizeMode || (webgl2.ResizeMode = {}));
    })(spine4.webgl || (spine4.webgl = {}));
  })(spine || (spine = {})), (function(spine4) {
    !(function(webgl2) {
      var Shader = (function() {
        function Shader2(context, vertexShader, fragmentShader) {
          this.vertexShader = vertexShader, this.fragmentShader = fragmentShader, this.vs = null, this.fs = null, this.program = null, this.tmp2x2 = new Float32Array(4), this.tmp3x3 = new Float32Array(9), this.tmp4x4 = new Float32Array(16), this.vsSource = vertexShader, this.fsSource = fragmentShader, this.context = context instanceof webgl2.ManagedWebGLRenderingContext ? context : new webgl2.ManagedWebGLRenderingContext(context), this.context.addRestorable(this), this.compile();
        }
        return Shader2.prototype.getProgram = function() {
          return this.program;
        }, Shader2.prototype.getVertexShader = function() {
          return this.vertexShader;
        }, Shader2.prototype.getFragmentShader = function() {
          return this.fragmentShader;
        }, Shader2.prototype.getVertexShaderSource = function() {
          return this.vsSource;
        }, Shader2.prototype.getFragmentSource = function() {
          return this.fsSource;
        }, Shader2.prototype.compile = function() {
          var gl = this.context.gl;
          try {
            this.vs = this.compileShader(gl.VERTEX_SHADER, this.vertexShader), this.fs = this.compileShader(gl.FRAGMENT_SHADER, this.fragmentShader), this.program = this.compileProgram(this.vs, this.fs);
          } catch (e) {
            throw this.dispose(), e;
          }
        }, Shader2.prototype.compileShader = function(type, source) {
          var gl = this.context.gl, shader = gl.createShader(type);
          if (gl.shaderSource(shader, source), gl.compileShader(shader), !gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            var error = "Couldn't compile shader: " + gl.getShaderInfoLog(shader);
            if (gl.deleteShader(shader), !gl.isContextLost()) throw new Error(error);
          }
          return shader;
        }, Shader2.prototype.compileProgram = function(vs, fs) {
          var gl = this.context.gl, program = gl.createProgram();
          if (gl.attachShader(program, vs), gl.attachShader(program, fs), gl.linkProgram(program), !gl.getProgramParameter(program, gl.LINK_STATUS)) {
            var error = "Couldn't compile shader program: " + gl.getProgramInfoLog(program);
            if (gl.deleteProgram(program), !gl.isContextLost()) throw new Error(error);
          }
          return program;
        }, Shader2.prototype.restore = function() {
          this.compile();
        }, Shader2.prototype.bind = function() {
          this.context.gl.useProgram(this.program);
        }, Shader2.prototype.unbind = function() {
          this.context.gl.useProgram(null);
        }, Shader2.prototype.setUniformi = function(uniform, value) {
          this.context.gl.uniform1i(this.getUniformLocation(uniform), value);
        }, Shader2.prototype.setUniformf = function(uniform, value) {
          this.context.gl.uniform1f(this.getUniformLocation(uniform), value);
        }, Shader2.prototype.setUniform2f = function(uniform, value, value2) {
          this.context.gl.uniform2f(this.getUniformLocation(uniform), value, value2);
        }, Shader2.prototype.setUniform3f = function(uniform, value, value2, value3) {
          this.context.gl.uniform3f(this.getUniformLocation(uniform), value, value2, value3);
        }, Shader2.prototype.setUniform4f = function(uniform, value, value2, value3, value4) {
          this.context.gl.uniform4f(this.getUniformLocation(uniform), value, value2, value3, value4);
        }, Shader2.prototype.setUniform2x2f = function(uniform, value) {
          var gl = this.context.gl;
          this.tmp2x2.set(value), gl.uniformMatrix2fv(this.getUniformLocation(uniform), false, this.tmp2x2);
        }, Shader2.prototype.setUniform3x3f = function(uniform, value) {
          var gl = this.context.gl;
          this.tmp3x3.set(value), gl.uniformMatrix3fv(this.getUniformLocation(uniform), false, this.tmp3x3);
        }, Shader2.prototype.setUniform4x4f = function(uniform, value) {
          var gl = this.context.gl;
          this.tmp4x4.set(value), gl.uniformMatrix4fv(this.getUniformLocation(uniform), false, this.tmp4x4);
        }, Shader2.prototype.getUniformLocation = function(uniform) {
          var gl = this.context.gl, location = gl.getUniformLocation(this.program, uniform);
          if (!location && !gl.isContextLost()) throw new Error("Couldn't find location for uniform " + uniform);
          return location;
        }, Shader2.prototype.getAttributeLocation = function(attribute) {
          var gl = this.context.gl, location = gl.getAttribLocation(this.program, attribute);
          if (-1 == location && !gl.isContextLost()) throw new Error("Couldn't find location for attribute " + attribute);
          return location;
        }, Shader2.prototype.dispose = function() {
          this.context.removeRestorable(this);
          var gl = this.context.gl;
          this.vs && (gl.deleteShader(this.vs), this.vs = null), this.fs && (gl.deleteShader(this.fs), this.fs = null), this.program && (gl.deleteProgram(this.program), this.program = null);
        }, Shader2.newColoredTextured = function(context) {
          return new Shader2(context, "\n				attribute vec4 " + Shader2.POSITION + ";\n				attribute vec4 " + Shader2.COLOR + ";\n				attribute vec2 " + Shader2.TEXCOORDS + ";\n				uniform mat4 " + Shader2.MVP_MATRIX + ";\n				varying vec4 v_color;\n				varying vec2 v_texCoords;\n\n				void main () {\n					v_color = " + Shader2.COLOR + ";\n					v_texCoords = " + Shader2.TEXCOORDS + ";\n					gl_Position = " + Shader2.MVP_MATRIX + " * " + Shader2.POSITION + ";\n				}\n			", "\n				#ifdef GL_ES\n					#define LOWP lowp\n					precision mediump float;\n				#else\n					#define LOWP\n				#endif\n				varying LOWP vec4 v_color;\n				varying vec2 v_texCoords;\n				uniform sampler2D u_texture;\n\n				void main () {\n					gl_FragColor = v_color * texture2D(u_texture, v_texCoords);\n				}\n			");
        }, Shader2.newTwoColoredTextured = function(context) {
          return new Shader2(context, "\n				attribute vec4 " + Shader2.POSITION + ";\n				attribute vec4 " + Shader2.COLOR + ";\n				attribute vec4 " + Shader2.COLOR2 + ";\n				attribute vec2 " + Shader2.TEXCOORDS + ";\n				uniform mat4 " + Shader2.MVP_MATRIX + ";\n				varying vec4 v_light;\n				varying vec4 v_dark;\n				varying vec2 v_texCoords;\n\n				void main () {\n					v_light = " + Shader2.COLOR + ";\n					v_dark = " + Shader2.COLOR2 + ";\n					v_texCoords = " + Shader2.TEXCOORDS + ";\n					gl_Position = " + Shader2.MVP_MATRIX + " * " + Shader2.POSITION + ";\n				}\n			", "\n				#ifdef GL_ES\n					#define LOWP lowp\n					precision mediump float;\n				#else\n					#define LOWP\n				#endif\n				varying LOWP vec4 v_light;\n				varying LOWP vec4 v_dark;\n				varying vec2 v_texCoords;\n				uniform sampler2D u_texture;\n\n				void main () {\n					vec4 texColor = texture2D(u_texture, v_texCoords);\n					gl_FragColor.a = texColor.a * v_light.a;\n					gl_FragColor.rgb = ((texColor.a - 1.0) * v_dark.a + 1.0 - texColor.rgb) * v_dark.rgb + texColor.rgb * v_light.rgb;\n				}\n			");
        }, Shader2.newColored = function(context) {
          return new Shader2(context, "\n				attribute vec4 " + Shader2.POSITION + ";\n				attribute vec4 " + Shader2.COLOR + ";\n				uniform mat4 " + Shader2.MVP_MATRIX + ";\n				varying vec4 v_color;\n\n				void main () {\n					v_color = " + Shader2.COLOR + ";\n					gl_Position = " + Shader2.MVP_MATRIX + " * " + Shader2.POSITION + ";\n				}\n			", "\n				#ifdef GL_ES\n					#define LOWP lowp\n					precision mediump float;\n				#else\n					#define LOWP\n				#endif\n				varying LOWP vec4 v_color;\n\n				void main () {\n					gl_FragColor = v_color;\n				}\n			");
        }, Shader2.MVP_MATRIX = "u_projTrans", Shader2.POSITION = "a_position", Shader2.COLOR = "a_color", Shader2.COLOR2 = "a_color2", Shader2.TEXCOORDS = "a_texCoords", Shader2.SAMPLER = "u_texture", Shader2;
      })();
      webgl2.Shader = Shader;
    })(spine4.webgl || (spine4.webgl = {}));
  })(spine || (spine = {})), (function(spine4) {
    !(function(webgl2) {
      var ShapeRenderer = (function() {
        function ShapeRenderer2(context, maxVertices) {
          if (void 0 === maxVertices && (maxVertices = 10920), this.isDrawing = false, this.shapeType = ShapeType.Filled, this.color = new spine4.Color(1, 1, 1, 1), this.vertexIndex = 0, this.tmp = new spine4.Vector2(), maxVertices > 10920) throw new Error("Can't have more than 10920 triangles per batch: " + maxVertices);
          this.context = context instanceof webgl2.ManagedWebGLRenderingContext ? context : new webgl2.ManagedWebGLRenderingContext(context), this.mesh = new webgl2.Mesh(context, [new webgl2.Position2Attribute(), new webgl2.ColorAttribute()], maxVertices, 0), this.srcBlend = this.context.gl.SRC_ALPHA, this.dstBlend = this.context.gl.ONE_MINUS_SRC_ALPHA;
        }
        return ShapeRenderer2.prototype.begin = function(shader) {
          if (this.isDrawing) throw new Error("ShapeRenderer.begin() has already been called");
          this.shader = shader, this.vertexIndex = 0, this.isDrawing = true;
          var gl = this.context.gl;
          gl.enable(gl.BLEND), gl.blendFunc(this.srcBlend, this.dstBlend);
        }, ShapeRenderer2.prototype.setBlendMode = function(srcBlend, dstBlend) {
          var gl = this.context.gl;
          this.srcBlend = srcBlend, this.dstBlend = dstBlend, this.isDrawing && (this.flush(), gl.blendFunc(this.srcBlend, this.dstBlend));
        }, ShapeRenderer2.prototype.setColor = function(color) {
          this.color.setFromColor(color);
        }, ShapeRenderer2.prototype.setColorWith = function(r, g, b, a) {
          this.color.set(r, g, b, a);
        }, ShapeRenderer2.prototype.point = function(x, y, color) {
          void 0 === color && (color = null), this.check(ShapeType.Point, 1), null === color && (color = this.color), this.vertex(x, y, color);
        }, ShapeRenderer2.prototype.line = function(x, y, x2, y2, color) {
          void 0 === color && (color = null), this.check(ShapeType.Line, 2);
          this.mesh.getVertices(); this.vertexIndex;
          null === color && (color = this.color), this.vertex(x, y, color), this.vertex(x2, y2, color);
        }, ShapeRenderer2.prototype.triangle = function(filled, x, y, x2, y2, x3, y3, color, color2, color3) {
          void 0 === color && (color = null), void 0 === color2 && (color2 = null), void 0 === color3 && (color3 = null), this.check(filled ? ShapeType.Filled : ShapeType.Line, 3);
          this.mesh.getVertices(); this.vertexIndex;
          null === color && (color = this.color), null === color2 && (color2 = this.color), null === color3 && (color3 = this.color), filled ? (this.vertex(x, y, color), this.vertex(x2, y2, color2), this.vertex(x3, y3, color3)) : (this.vertex(x, y, color), this.vertex(x2, y2, color2), this.vertex(x2, y2, color), this.vertex(x3, y3, color2), this.vertex(x3, y3, color), this.vertex(x, y, color2));
        }, ShapeRenderer2.prototype.quad = function(filled, x, y, x2, y2, x3, y3, x4, y4, color, color2, color3, color4) {
          void 0 === color && (color = null), void 0 === color2 && (color2 = null), void 0 === color3 && (color3 = null), void 0 === color4 && (color4 = null), this.check(filled ? ShapeType.Filled : ShapeType.Line, 3);
          this.mesh.getVertices(); this.vertexIndex;
          null === color && (color = this.color), null === color2 && (color2 = this.color), null === color3 && (color3 = this.color), null === color4 && (color4 = this.color), filled ? (this.vertex(x, y, color), this.vertex(x2, y2, color2), this.vertex(x3, y3, color3), this.vertex(x3, y3, color3), this.vertex(x4, y4, color4), this.vertex(x, y, color)) : (this.vertex(x, y, color), this.vertex(x2, y2, color2), this.vertex(x2, y2, color2), this.vertex(x3, y3, color3), this.vertex(x3, y3, color3), this.vertex(x4, y4, color4), this.vertex(x4, y4, color4), this.vertex(x, y, color));
        }, ShapeRenderer2.prototype.rect = function(filled, x, y, width, height, color) {
          void 0 === color && (color = null), this.quad(filled, x, y, x + width, y, x + width, y + height, x, y + height, color, color, color, color);
        }, ShapeRenderer2.prototype.rectLine = function(filled, x1, y1, x2, y2, width, color) {
          void 0 === color && (color = null), this.check(filled ? ShapeType.Filled : ShapeType.Line, 8), null === color && (color = this.color);
          var t = this.tmp.set(y2 - y1, x1 - x2);
          t.normalize(), width *= 0.5;
          var tx = t.x * width, ty = t.y * width;
          filled ? (this.vertex(x1 + tx, y1 + ty, color), this.vertex(x1 - tx, y1 - ty, color), this.vertex(x2 + tx, y2 + ty, color), this.vertex(x2 - tx, y2 - ty, color), this.vertex(x2 + tx, y2 + ty, color), this.vertex(x1 - tx, y1 - ty, color)) : (this.vertex(x1 + tx, y1 + ty, color), this.vertex(x1 - tx, y1 - ty, color), this.vertex(x2 + tx, y2 + ty, color), this.vertex(x2 - tx, y2 - ty, color), this.vertex(x2 + tx, y2 + ty, color), this.vertex(x1 + tx, y1 + ty, color), this.vertex(x2 - tx, y2 - ty, color), this.vertex(x1 - tx, y1 - ty, color));
        }, ShapeRenderer2.prototype.x = function(x, y, size) {
          this.line(x - size, y - size, x + size, y + size), this.line(x - size, y + size, x + size, y - size);
        }, ShapeRenderer2.prototype.polygon = function(polygonVertices, offset, count, color) {
          if (void 0 === color && (color = null), count < 3) throw new Error("Polygon must contain at least 3 vertices");
          this.check(ShapeType.Line, 2 * count), null === color && (color = this.color);
          this.mesh.getVertices(); this.vertexIndex;
          count <<= 1;
          for (var firstX = polygonVertices[offset <<= 1], firstY = polygonVertices[offset + 1], last = offset + count, i = offset, n = offset + count - 2; i < n; i += 2) {
            var x1 = polygonVertices[i], y1 = polygonVertices[i + 1], x2 = 0, y2 = 0;
            i + 2 >= last ? (x2 = firstX, y2 = firstY) : (x2 = polygonVertices[i + 2], y2 = polygonVertices[i + 3]), this.vertex(x1, y1, color), this.vertex(x2, y2, color);
          }
        }, ShapeRenderer2.prototype.circle = function(filled, x, y, radius, color, segments) {
          if (void 0 === color && (color = null), void 0 === segments && (segments = 0), 0 === segments && (segments = Math.max(1, 6 * spine4.MathUtils.cbrt(radius) | 0)), segments <= 0) throw new Error("segments must be > 0.");
          null === color && (color = this.color);
          var angle = 2 * spine4.MathUtils.PI / segments, cos = Math.cos(angle), sin = Math.sin(angle), cx = radius, cy = 0;
          if (filled) {
            this.check(ShapeType.Filled, 3 * segments + 3), segments--;
            for (var i = 0; i < segments; i++) {
              this.vertex(x, y, color), this.vertex(x + cx, y + cy, color);
              var temp_2 = cx;
              cx = cos * cx - sin * cy, cy = sin * temp_2 + cos * cy, this.vertex(x + cx, y + cy, color);
            }
            this.vertex(x, y, color), this.vertex(x + cx, y + cy, color);
          } else {
            this.check(ShapeType.Line, 2 * segments + 2);
            for (var i = 0; i < segments; i++) {
              this.vertex(x + cx, y + cy, color);
              var temp_1 = cx;
              cx = cos * cx - sin * cy, cy = sin * temp_1 + cos * cy, this.vertex(x + cx, y + cy, color);
            }
            this.vertex(x + cx, y + cy, color);
          }
          cx = radius, cy = 0, this.vertex(x + cx, y + cy, color);
        }, ShapeRenderer2.prototype.curve = function(x1, y1, cx1, cy1, cx2, cy2, x2, y2, segments, color) {
          void 0 === color && (color = null), this.check(ShapeType.Line, 2 * segments + 2), null === color && (color = this.color);
          for (var subdiv_step = 1 / segments, subdiv_step2 = subdiv_step * subdiv_step, subdiv_step3 = subdiv_step * subdiv_step * subdiv_step, pre1 = 3 * subdiv_step, pre2 = 3 * subdiv_step2, pre4 = 6 * subdiv_step2, pre5 = 6 * subdiv_step3, tmp1x = x1 - 2 * cx1 + cx2, tmp1y = y1 - 2 * cy1 + cy2, tmp2x = 3 * (cx1 - cx2) - x1 + x2, tmp2y = 3 * (cy1 - cy2) - y1 + y2, fx = x1, fy = y1, dfx = (cx1 - x1) * pre1 + tmp1x * pre2 + tmp2x * subdiv_step3, dfy = (cy1 - y1) * pre1 + tmp1y * pre2 + tmp2y * subdiv_step3, ddfx = tmp1x * pre4 + tmp2x * pre5, ddfy = tmp1y * pre4 + tmp2y * pre5, dddfx = tmp2x * pre5, dddfy = tmp2y * pre5; segments-- > 0; ) this.vertex(fx, fy, color), fx += dfx, fy += dfy, dfx += ddfx, dfy += ddfy, ddfx += dddfx, ddfy += dddfy, this.vertex(fx, fy, color);
          this.vertex(fx, fy, color), this.vertex(x2, y2, color);
        }, ShapeRenderer2.prototype.vertex = function(x, y, color) {
          var idx = this.vertexIndex, vertices = this.mesh.getVertices();
          vertices[idx++] = x, vertices[idx++] = y, vertices[idx++] = color.r, vertices[idx++] = color.g, vertices[idx++] = color.b, vertices[idx++] = color.a, this.vertexIndex = idx;
        }, ShapeRenderer2.prototype.end = function() {
          if (!this.isDrawing) throw new Error("ShapeRenderer.begin() has not been called");
          this.flush(), this.context.gl.disable(this.context.gl.BLEND), this.isDrawing = false;
        }, ShapeRenderer2.prototype.flush = function() {
          0 != this.vertexIndex && (this.mesh.setVerticesLength(this.vertexIndex), this.mesh.draw(this.shader, this.shapeType), this.vertexIndex = 0);
        }, ShapeRenderer2.prototype.check = function(shapeType, numVertices) {
          if (!this.isDrawing) throw new Error("ShapeRenderer.begin() has not been called");
          if (this.shapeType == shapeType) {
            if (!(this.mesh.maxVertices() - this.mesh.numVertices() < numVertices)) return;
            this.flush();
          } else this.flush(), this.shapeType = shapeType;
        }, ShapeRenderer2.prototype.dispose = function() {
          this.mesh.dispose();
        }, ShapeRenderer2;
      })(), ShapeType;
      webgl2.ShapeRenderer = ShapeRenderer, (function(ShapeType2) {
        ShapeType2[ShapeType2.Point = 0] = "Point", ShapeType2[ShapeType2.Line = 1] = "Line", ShapeType2[ShapeType2.Filled = 4] = "Filled";
      })(ShapeType = webgl2.ShapeType || (webgl2.ShapeType = {}));
    })(spine4.webgl || (spine4.webgl = {}));
  })(spine || (spine = {})), (function(spine4) {
    !(function(webgl2) {
      var SkeletonDebugRenderer = (function() {
        function SkeletonDebugRenderer2(context) {
          this.boneLineColor = new spine4.Color(1, 0, 0, 1), this.boneOriginColor = new spine4.Color(0, 1, 0, 1), this.attachmentLineColor = new spine4.Color(0, 0, 1, 0.5), this.triangleLineColor = new spine4.Color(1, 0.64, 0, 0.5), this.pathColor = new spine4.Color().setFromString("FF7F00"), this.clipColor = new spine4.Color(0.8, 0, 0, 2), this.aabbColor = new spine4.Color(0, 1, 0, 0.5), this.drawBones = true, this.drawRegionAttachments = true, this.drawBoundingBoxes = true, this.drawMeshHull = true, this.drawMeshTriangles = true, this.drawPaths = true, this.drawSkeletonXY = false, this.drawClipping = true, this.premultipliedAlpha = false, this.scale = 1, this.boneWidth = 2, this.bounds = new spine4.SkeletonBounds(), this.temp = new Array(), this.vertices = spine4.Utils.newFloatArray(2048), this.context = context instanceof webgl2.ManagedWebGLRenderingContext ? context : new webgl2.ManagedWebGLRenderingContext(context);
        }
        return SkeletonDebugRenderer2.prototype.draw = function(shapes, Skeleton2, ignoredBones) {
          void 0 === ignoredBones && (ignoredBones = null);
          var SkeletonX = Skeleton2.x, SkeletonY = Skeleton2.y, gl = this.context.gl, srcFunc = this.premultipliedAlpha ? gl.ONE : gl.SRC_ALPHA;
          shapes.setBlendMode(srcFunc, gl.ONE_MINUS_SRC_ALPHA);
          var bones = Skeleton2.bones;
          if (this.drawBones) {
            shapes.setColor(this.boneLineColor);
            for (var i = 0, n = bones.length; i < n; i++) {
              var bone = bones[i];
              if (!(ignoredBones && ignoredBones.indexOf(bone.data.name) > -1) && null != bone.parent) {
                var x = SkeletonX + bone.data.length * bone.a + bone.worldX, y = SkeletonY + bone.data.length * bone.c + bone.worldY;
                shapes.rectLine(true, SkeletonX + bone.worldX, SkeletonY + bone.worldY, x, y, this.boneWidth * this.scale);
              }
            }
            this.drawSkeletonXY && shapes.x(skeletonX, SkeletonY, 4 * this.scale);
          }
          if (this.drawRegionAttachments) {
            shapes.setColor(this.attachmentLineColor);
            for (var slots, i = 0, n = (slots = Skeleton2.slots).length; i < n; i++) {
              var slot, attachment;
              if ((attachment = (slot = slots[i]).getAttachment()) instanceof spine4.RegionAttachment) {
                var regionAttachment = attachment, vertices = this.vertices;
                regionAttachment.computeWorldVertices(slot.bone, vertices, 0, 2), shapes.line(vertices[0], vertices[1], vertices[2], vertices[3]), shapes.line(vertices[2], vertices[3], vertices[4], vertices[5]), shapes.line(vertices[4], vertices[5], vertices[6], vertices[7]), shapes.line(vertices[6], vertices[7], vertices[0], vertices[1]);
              }
            }
          }
          if (this.drawMeshHull || this.drawMeshTriangles) for (var slots, i = 0, n = (slots = Skeleton2.slots).length; i < n; i++) {
            var slot, attachment;
            if ((slot = slots[i]).bone.active) {
              if ((attachment = slot.getAttachment()) instanceof spine4.MeshAttachment) {
                var mesh = attachment, vertices = this.vertices;
                mesh.computeWorldVertices(slot, 0, mesh.worldVerticesLength, vertices, 0, 2);
                var triangles = mesh.triangles, hullLength = mesh.hullLength;
                if (this.drawMeshTriangles) {
                  shapes.setColor(this.triangleLineColor);
                  for (var ii = 0, nn = triangles.length; ii < nn; ii += 3) {
                    var v1 = 2 * triangles[ii], v2 = 2 * triangles[ii + 1], v3 = 2 * triangles[ii + 2];
                    shapes.triangle(false, vertices[v1], vertices[v1 + 1], vertices[v2], vertices[v2 + 1], vertices[v3], vertices[v3 + 1]);
                  }
                }
                if (this.drawMeshHull && hullLength > 0) {
                  shapes.setColor(this.attachmentLineColor);
                  for (var lastX = vertices[(hullLength = 2 * (hullLength >> 1)) - 2], lastY = vertices[hullLength - 1], ii = 0, nn = hullLength; ii < nn; ii += 2) {
                    var x = vertices[ii], y = vertices[ii + 1];
                    shapes.line(x, y, lastX, lastY), lastX = x, lastY = y;
                  }
                }
              }
            }
          }
          if (this.drawBoundingBoxes) {
            var bounds = this.bounds;
            bounds.update(skeleton, true), shapes.setColor(this.aabbColor), shapes.rect(false, bounds.minX, bounds.minY, bounds.getWidth(), bounds.getHeight());
            for (var polygons = bounds.polygons, boxes = bounds.boundingBoxes, i = 0, n = polygons.length; i < n; i++) {
              var polygon = polygons[i];
              shapes.setColor(boxes[i].color), shapes.polygon(polygon, 0, polygon.length);
            }
          }
          if (this.drawPaths) for (var slots, i = 0, n = (slots = Skeleton2.slots).length; i < n; i++) {
            var slot, attachment;
            if ((slot = slots[i]).bone.active) {
              if ((attachment = slot.getAttachment()) instanceof spine4.PathAttachment) {
                var path = attachment, nn = path.worldVerticesLength, world = this.temp = spine4.Utils.setArraySize(this.temp, nn, 0);
                path.computeWorldVertices(slot, 0, nn, world, 0, 2);
                var color = this.pathColor, x1 = world[2], y1 = world[3], x2 = 0, y2 = 0;
                if (path.closed) {
                  shapes.setColor(color);
                  var cx1 = world[0], cy1 = world[1], cx2 = world[nn - 2], cy2 = world[nn - 1];
                  x2 = world[nn - 4], y2 = world[nn - 3], shapes.curve(x1, y1, cx1, cy1, cx2, cy2, x2, y2, 32), shapes.setColor(SkeletonDebugRenderer2.LIGHT_GRAY), shapes.line(x1, y1, cx1, cy1), shapes.line(x2, y2, cx2, cy2);
                }
                nn -= 4;
                for (var ii = 4; ii < nn; ii += 6) {
                  var cx1 = world[ii], cy1 = world[ii + 1], cx2 = world[ii + 2], cy2 = world[ii + 3];
                  x2 = world[ii + 4], y2 = world[ii + 5], shapes.setColor(color), shapes.curve(x1, y1, cx1, cy1, cx2, cy2, x2, y2, 32), shapes.setColor(SkeletonDebugRenderer2.LIGHT_GRAY), shapes.line(x1, y1, cx1, cy1), shapes.line(x2, y2, cx2, cy2), x1 = x2, y1 = y2;
                }
              }
            }
          }
          if (this.drawBones) {
            shapes.setColor(this.boneOriginColor);
            for (var i = 0, n = bones.length; i < n; i++) {
              var bone = bones[i];
              ignoredBones && ignoredBones.indexOf(bone.data.name) > -1 || shapes.circle(true, SkeletonX + bone.worldX, SkeletonY + bone.worldY, 3 * this.scale, SkeletonDebugRenderer2.GREEN, 8);
            }
          }
          if (this.drawClipping) {
            var slots = Skeleton2.slots;
            shapes.setColor(this.clipColor);
            for (var i = 0, n = slots.length; i < n; i++) {
              var slot, attachment;
              if ((slot = slots[i]).bone.active) {
                if ((attachment = slot.getAttachment()) instanceof spine4.ClippingAttachment) {
                  var clip = attachment, nn = clip.worldVerticesLength, world = this.temp = spine4.Utils.setArraySize(this.temp, nn, 0);
                  clip.computeWorldVertices(slot, 0, nn, world, 0, 2);
                  for (var i_21 = 0, n_3 = world.length; i_21 < n_3; i_21 += 2) {
                    var x = world[i_21], y = world[i_21 + 1], x2 = world[(i_21 + 2) % world.length], y2 = world[(i_21 + 3) % world.length];
                    shapes.line(x, y, x2, y2);
                  }
                }
              }
            }
          }
        }, SkeletonDebugRenderer2.prototype.dispose = function() {
        }, SkeletonDebugRenderer2.LIGHT_GRAY = new spine4.Color(192 / 255, 192 / 255, 192 / 255, 1), SkeletonDebugRenderer2.GREEN = new spine4.Color(0, 1, 0, 1), SkeletonDebugRenderer2;
      })();
      webgl2.SkeletonDebugRenderer = SkeletonDebugRenderer;
    })(spine4.webgl || (spine4.webgl = {}));
  })(spine || (spine = {})), (function(spine4) {
    !(function(webgl2) {
      var Renderable = /* @__PURE__ */ (function() {
        function Renderable2(vertices, numVertices, numFloats) {
          this.vertices = vertices, this.numVertices = numVertices, this.numFloats = numFloats;
        }
        return Renderable2;
      })(), SkeletonRenderer = (function() {
        function SkeletonRenderer2(context, twoColorTint) {
          void 0 === twoColorTint && (twoColorTint = true), this.premultipliedAlpha = false, this.vertexEffect = null, this.tempColor = new spine4.Color(), this.tempColor2 = new spine4.Color(), this.vertexSize = 8, this.twoColorTint = false, this.renderable = new Renderable(null, 0, 0), this.clipper = new spine4.SkeletonClipping(), this.temp = new spine4.Vector2(), this.temp2 = new spine4.Vector2(), this.temp3 = new spine4.Color(), this.temp4 = new spine4.Color(), this.twoColorTint = twoColorTint, twoColorTint && (this.vertexSize += 4), this.vertices = spine4.Utils.newFloatArray(1024 * this.vertexSize);
        }
        return SkeletonRenderer2.prototype.draw = function(batcher, Skeleton2, slotRangeStart, slotRangeEnd) {
          void 0 === slotRangeStart && (slotRangeStart = -1), void 0 === slotRangeEnd && (slotRangeEnd = -1);
          var clipper = this.clipper, premultipliedAlpha = this.premultipliedAlpha, twoColorTint = this.twoColorTint, blendMode = null, tempPos = this.temp, tempUv = this.temp2, tempLight = this.temp3, tempDark = this.temp4, renderable = this.renderable, uvs = null, triangles = null, drawOrder = Skeleton2.drawOrder, attachmentColor = null, SkeletonColor = Skeleton2.color, vertexSize = twoColorTint ? 12 : 8, inRange = false;
          -1 == slotRangeStart && (inRange = true);
          for (var i = 0, n = drawOrder.length; i < n; i++) {
            var clippedVertexSize = clipper.isClipping() ? 2 : vertexSize, slot = drawOrder[i];
            if (slot.bone.active) if (slotRangeStart >= 0 && slotRangeStart == slot.data.index && (inRange = true), inRange) {
              slotRangeEnd >= 0 && slotRangeEnd == slot.data.index && (inRange = false);
              var attachment = slot.getAttachment(), texture = null;
              if (attachment instanceof spine4.RegionAttachment) {
                var region = attachment;
                renderable.vertices = this.vertices, renderable.numVertices = 4, renderable.numFloats = clippedVertexSize << 2, region.computeWorldVertices(slot.bone, renderable.vertices, 0, clippedVertexSize), triangles = SkeletonRenderer2.QUAD_TRIANGLES, uvs = region.uvs, texture = region.region.renderObject.texture, attachmentColor = region.color;
              } else {
                if (!(attachment instanceof spine4.MeshAttachment)) {
                  if (attachment instanceof spine4.ClippingAttachment) {
                    var clip = attachment;
                    clipper.clipStart(slot, clip);
                    continue;
                  }
                  clipper.clipEndWithSlot(slot);
                  continue;
                }
                var mesh = attachment;
                renderable.vertices = this.vertices, renderable.numVertices = mesh.worldVerticesLength >> 1, renderable.numFloats = renderable.numVertices * clippedVertexSize, renderable.numFloats > renderable.vertices.length && (renderable.vertices = this.vertices = spine4.Utils.newFloatArray(renderable.numFloats)), mesh.computeWorldVertices(slot, 0, mesh.worldVerticesLength, renderable.vertices, 0, clippedVertexSize), triangles = mesh.triangles, texture = mesh.region.renderObject.texture, uvs = mesh.uvs, attachmentColor = mesh.color;
              }
              if (null != texture) {
                var slotColor = slot.color, finalColor = this.tempColor;
                finalColor.r = SkeletonColor.r * slotColor.r * attachmentColor.r, finalColor.g = SkeletonColor.g * slotColor.g * attachmentColor.g, finalColor.b = SkeletonColor.b * slotColor.b * attachmentColor.b, finalColor.a = SkeletonColor.a * slotColor.a * attachmentColor.a, premultipliedAlpha && (finalColor.r *= finalColor.a, finalColor.g *= finalColor.a, finalColor.b *= finalColor.a);
                var darkColor = this.tempColor2;
                null == slot.darkColor ? darkColor.set(0, 0, 0, 1) : (premultipliedAlpha ? (darkColor.r = slot.darkColor.r * finalColor.a, darkColor.g = slot.darkColor.g * finalColor.a, darkColor.b = slot.darkColor.b * finalColor.a) : darkColor.setFromColor(slot.darkColor), darkColor.a = premultipliedAlpha ? 1 : 0);
                var slotBlendMode = slot.data.blendMode;
                if (slotBlendMode != blendMode && (blendMode = slotBlendMode, batcher.setBlendMode(webgl2.WebGLBlendModeConverter.getSourceGLBlendMode(blendMode, premultipliedAlpha), webgl2.WebGLBlendModeConverter.getDestGLBlendMode(blendMode))), clipper.isClipping()) {
                  clipper.clipTriangles(renderable.vertices, renderable.numFloats, triangles, triangles.length, uvs, finalColor, darkColor, twoColorTint);
                  var clippedVertices = new Float32Array(clipper.clippedVertices), clippedTriangles = clipper.clippedTriangles;
                  if (null != this.vertexEffect) {
                    var vertexEffect = this.vertexEffect, verts = clippedVertices;
                    if (twoColorTint) for (var v = 0, n_5 = clippedVertices.length; v < n_5; v += vertexSize) tempPos.x = verts[v], tempPos.y = verts[v + 1], tempLight.set(verts[v + 2], verts[v + 3], verts[v + 4], verts[v + 5]), tempUv.x = verts[v + 6], tempUv.y = verts[v + 7], tempDark.set(verts[v + 8], verts[v + 9], verts[v + 10], verts[v + 11]), vertexEffect.transform(tempPos, tempUv, tempLight, tempDark), verts[v] = tempPos.x, verts[v + 1] = tempPos.y, verts[v + 2] = tempLight.r, verts[v + 3] = tempLight.g, verts[v + 4] = tempLight.b, verts[v + 5] = tempLight.a, verts[v + 6] = tempUv.x, verts[v + 7] = tempUv.y, verts[v + 8] = tempDark.r, verts[v + 9] = tempDark.g, verts[v + 10] = tempDark.b, verts[v + 11] = tempDark.a;
                    else for (var v = 0, n_4 = clippedVertices.length; v < n_4; v += vertexSize) tempPos.x = verts[v], tempPos.y = verts[v + 1], tempLight.set(verts[v + 2], verts[v + 3], verts[v + 4], verts[v + 5]), tempUv.x = verts[v + 6], tempUv.y = verts[v + 7], tempDark.set(0, 0, 0, 0), vertexEffect.transform(tempPos, tempUv, tempLight, tempDark), verts[v] = tempPos.x, verts[v + 1] = tempPos.y, verts[v + 2] = tempLight.r, verts[v + 3] = tempLight.g, verts[v + 4] = tempLight.b, verts[v + 5] = tempLight.a, verts[v + 6] = tempUv.x, verts[v + 7] = tempUv.y;
                  }
                  batcher.draw(texture, clippedVertices, clippedTriangles);
                } else {
                  var verts = renderable.vertices;
                  if (null != this.vertexEffect) {
                    var vertexEffect = this.vertexEffect;
                    if (twoColorTint) for (var v = 0, u = 0, n_7 = renderable.numFloats; v < n_7; v += vertexSize, u += 2) tempPos.x = verts[v], tempPos.y = verts[v + 1], tempUv.x = uvs[u], tempUv.y = uvs[u + 1], tempLight.setFromColor(finalColor), tempDark.setFromColor(darkColor), vertexEffect.transform(tempPos, tempUv, tempLight, tempDark), verts[v] = tempPos.x, verts[v + 1] = tempPos.y, verts[v + 2] = tempLight.r, verts[v + 3] = tempLight.g, verts[v + 4] = tempLight.b, verts[v + 5] = tempLight.a, verts[v + 6] = tempUv.x, verts[v + 7] = tempUv.y, verts[v + 8] = tempDark.r, verts[v + 9] = tempDark.g, verts[v + 10] = tempDark.b, verts[v + 11] = tempDark.a;
                    else for (var v = 0, u = 0, n_6 = renderable.numFloats; v < n_6; v += vertexSize, u += 2) tempPos.x = verts[v], tempPos.y = verts[v + 1], tempUv.x = uvs[u], tempUv.y = uvs[u + 1], tempLight.setFromColor(finalColor), tempDark.set(0, 0, 0, 0), vertexEffect.transform(tempPos, tempUv, tempLight, tempDark), verts[v] = tempPos.x, verts[v + 1] = tempPos.y, verts[v + 2] = tempLight.r, verts[v + 3] = tempLight.g, verts[v + 4] = tempLight.b, verts[v + 5] = tempLight.a, verts[v + 6] = tempUv.x, verts[v + 7] = tempUv.y;
                  } else if (twoColorTint) for (var v = 2, u = 0, n_9 = renderable.numFloats; v < n_9; v += vertexSize, u += 2) verts[v] = finalColor.r, verts[v + 1] = finalColor.g, verts[v + 2] = finalColor.b, verts[v + 3] = finalColor.a, verts[v + 4] = uvs[u], verts[v + 5] = uvs[u + 1], verts[v + 6] = darkColor.r, verts[v + 7] = darkColor.g, verts[v + 8] = darkColor.b, verts[v + 9] = darkColor.a;
                  else for (var v = 2, u = 0, n_8 = renderable.numFloats; v < n_8; v += vertexSize, u += 2) verts[v] = finalColor.r, verts[v + 1] = finalColor.g, verts[v + 2] = finalColor.b, verts[v + 3] = finalColor.a, verts[v + 4] = uvs[u], verts[v + 5] = uvs[u + 1];
                  var view = renderable.vertices.subarray(0, renderable.numFloats);
                  batcher.draw(texture, view, triangles);
                }
              }
              clipper.clipEndWithSlot(slot);
            } else clipper.clipEndWithSlot(slot);
            else clipper.clipEndWithSlot(slot);
          }
          clipper.clipEnd();
        }, SkeletonRenderer2.QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0], SkeletonRenderer2;
      })();
      webgl2.SkeletonRenderer = SkeletonRenderer;
    })(spine4.webgl || (spine4.webgl = {}));
  })(spine || (spine = {})), (function(spine4) {
    !(function(webgl2) {
      var Vector3 = (function() {
        function Vector32(x, y, z) {
          void 0 === x && (x = 0), void 0 === y && (y = 0), void 0 === z && (z = 0), this.x = 0, this.y = 0, this.z = 0, this.x = x, this.y = y, this.z = z;
        }
        return Vector32.prototype.setFrom = function(v) {
          return this.x = v.x, this.y = v.y, this.z = v.z, this;
        }, Vector32.prototype.set = function(x, y, z) {
          return this.x = x, this.y = y, this.z = z, this;
        }, Vector32.prototype.add = function(v) {
          return this.x += v.x, this.y += v.y, this.z += v.z, this;
        }, Vector32.prototype.sub = function(v) {
          return this.x -= v.x, this.y -= v.y, this.z -= v.z, this;
        }, Vector32.prototype.scale = function(s) {
          return this.x *= s, this.y *= s, this.z *= s, this;
        }, Vector32.prototype.normalize = function() {
          var len = this.length();
          return 0 == len ? this : (len = 1 / len, this.x *= len, this.y *= len, this.z *= len, this);
        }, Vector32.prototype.cross = function(v) {
          return this.set(this.y * v.z - this.z * v.y, this.z * v.x - this.x * v.z, this.x * v.y - this.y * v.x);
        }, Vector32.prototype.multiply = function(matrix) {
          var l_mat = matrix.values;
          return this.set(this.x * l_mat[webgl2.M00] + this.y * l_mat[webgl2.M01] + this.z * l_mat[webgl2.M02] + l_mat[webgl2.M03], this.x * l_mat[webgl2.M10] + this.y * l_mat[webgl2.M11] + this.z * l_mat[webgl2.M12] + l_mat[webgl2.M13], this.x * l_mat[webgl2.M20] + this.y * l_mat[webgl2.M21] + this.z * l_mat[webgl2.M22] + l_mat[webgl2.M23]);
        }, Vector32.prototype.project = function(matrix) {
          var l_mat = matrix.values, l_w = 1 / (this.x * l_mat[webgl2.M30] + this.y * l_mat[webgl2.M31] + this.z * l_mat[webgl2.M32] + l_mat[webgl2.M33]);
          return this.set((this.x * l_mat[webgl2.M00] + this.y * l_mat[webgl2.M01] + this.z * l_mat[webgl2.M02] + l_mat[webgl2.M03]) * l_w, (this.x * l_mat[webgl2.M10] + this.y * l_mat[webgl2.M11] + this.z * l_mat[webgl2.M12] + l_mat[webgl2.M13]) * l_w, (this.x * l_mat[webgl2.M20] + this.y * l_mat[webgl2.M21] + this.z * l_mat[webgl2.M22] + l_mat[webgl2.M23]) * l_w);
        }, Vector32.prototype.dot = function(v) {
          return this.x * v.x + this.y * v.y + this.z * v.z;
        }, Vector32.prototype.length = function() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }, Vector32.prototype.distance = function(v) {
          var a = v.x - this.x, b = v.y - this.y, c = v.z - this.z;
          return Math.sqrt(a * a + b * b + c * c);
        }, Vector32;
      })();
      webgl2.Vector3 = Vector3;
    })(spine4.webgl || (spine4.webgl = {}));
  })(spine || (spine = {})), (function(spine4) {
    !(function(webgl2) {
      var ManagedWebGLRenderingContext = (function() {
        function ManagedWebGLRenderingContext2(canvasOrContext, contextConfig) {
          void 0 === contextConfig && (contextConfig = { alpha: "true" }), this.restorables = new Array(), canvasOrContext instanceof WebGLRenderingContext || canvasOrContext instanceof WebGL2RenderingContext ? (this.gl = canvasOrContext, this.canvas = this.gl.canvas) : this.setupCanvas(canvasOrContext, contextConfig);
        }
        return ManagedWebGLRenderingContext2.prototype.setupCanvas = function(canvas, contextConfig) {
          var _this = this;
          this.gl = canvas.getContext("webgl2", contextConfig) || canvas.getContext("webgl", contextConfig), this.canvas = canvas, canvas.addEventListener("webglcontextlost", (function(e) {
            e && e.preventDefault();
          })), canvas.addEventListener("webglcontextrestored", (function(e) {
            for (var i = 0, n = _this.restorables.length; i < n; i++) _this.restorables[i].restore();
          }));
        }, ManagedWebGLRenderingContext2.prototype.addRestorable = function(restorable) {
          this.restorables.push(restorable);
        }, ManagedWebGLRenderingContext2.prototype.removeRestorable = function(restorable) {
          var index = this.restorables.indexOf(restorable);
          index > -1 && this.restorables.splice(index, 1);
        }, ManagedWebGLRenderingContext2;
      })();
      webgl2.ManagedWebGLRenderingContext = ManagedWebGLRenderingContext;
      var WebGLBlendModeConverter = (function() {
        function WebGLBlendModeConverter2() {
        }
        return WebGLBlendModeConverter2.getDestGLBlendMode = function(blendMode) {
          switch (blendMode) {
            case spine4.BlendMode.Normal:
              return WebGLBlendModeConverter2.ONE_MINUS_SRC_ALPHA;
            case spine4.BlendMode.Additive:
              return WebGLBlendModeConverter2.ONE;
            case spine4.BlendMode.Multiply:
            case spine4.BlendMode.Screen:
              return WebGLBlendModeConverter2.ONE_MINUS_SRC_ALPHA;
            default:
              throw new Error("Unknown blend mode: " + blendMode);
          }
        }, WebGLBlendModeConverter2.getSourceGLBlendMode = function(blendMode, premultipliedAlpha) {
          switch (void 0 === premultipliedAlpha && (premultipliedAlpha = false), blendMode) {
            case spine4.BlendMode.Normal:
            case spine4.BlendMode.Additive:
              return premultipliedAlpha ? WebGLBlendModeConverter2.ONE : WebGLBlendModeConverter2.SRC_ALPHA;
            case spine4.BlendMode.Multiply:
              return WebGLBlendModeConverter2.DST_COLOR;
            case spine4.BlendMode.Screen:
              return WebGLBlendModeConverter2.ONE;
            default:
              throw new Error("Unknown blend mode: " + blendMode);
          }
        }, WebGLBlendModeConverter2.ZERO = 0, WebGLBlendModeConverter2.ONE = 1, WebGLBlendModeConverter2.SRC_COLOR = 768, WebGLBlendModeConverter2.ONE_MINUS_SRC_COLOR = 769, WebGLBlendModeConverter2.SRC_ALPHA = 770, WebGLBlendModeConverter2.ONE_MINUS_SRC_ALPHA = 771, WebGLBlendModeConverter2.DST_ALPHA = 772, WebGLBlendModeConverter2.ONE_MINUS_DST_ALPHA = 773, WebGLBlendModeConverter2.DST_COLOR = 774, WebGLBlendModeConverter2;
      })();
      webgl2.WebGLBlendModeConverter = WebGLBlendModeConverter;
    })(spine4.webgl || (spine4.webgl = {}));
  })(spine || (spine = {}));
  var spine38 = Object.assign(spine, spine.webgl);
  var spine_webgl_default = spine38;

  // src/spine/4.0/spine-webgl.js
  var spine2 = (() => {
    var Li = Object.defineProperty, vs = (t) => Li(t, "__esModule", { value: true }), ys = (t, e) => {
      vs(t);
      for (var i in e) Li(t, i, { get: e[i], enumerable: true });
    }, Pi = {};
    ys(Pi, { AlphaTimeline: () => Ze, Animation: () => be, AnimationState: () => ri, AnimationStateAdapter: () => Ts, AnimationStateData: () => Ms, AssetManager: () => ns, AssetManagerBase: () => Ji, AtlasAttachmentLoader: () => ks, Attachment: () => Oe, AttachmentTimeline: () => Zt, BinaryInput: () => es, BlendMode: () => wt, Bone: () => fi, BoneData: () => ui, BoundingBoxAttachment: () => ye, CURRENT: () => qi, CameraController: () => rr, ClippingAttachment: () => fe, Color: () => D, Color2Attribute: () => os, ColorAttribute: () => Ie, ConstraintData: () => Ae, CurveTimeline: () => Xt, CurveTimeline1: () => Rt, CurveTimeline2: () => pe, DebugUtils: () => Ss, DeformTimeline: () => Qe, Downloader: () => Ki, DrawOrderTimeline: () => Jt, Event: () => mi, EventData: () => gi, EventQueue: () => Wi, EventTimeline: () => ue, EventType: () => St, FIRST: () => ai, FakeTexture: () => Ys, GLTexture: () => me, HOLD_FIRST: () => ve, HOLD_MIX: () => _i, HOLD_SUBSEQUENT: () => ni, IkConstraint: () => Qi, IkConstraintData: () => xi, IkConstraintTimeline: () => $e, Input: () => Ti, IntSet: () => As, Interpolation: () => Bi, JitterEffect: () => er, LoadingScreen: () => hr, M00: () => N, M01: () => G, M02: () => j, M03: () => U, M10: () => H, M11: () => z, M12: () => Z, M13: () => W, M20: () => J, M21: () => K, M22: () => _, M23: () => q, M30: () => $, M31: () => tt, M32: () => et, M33: () => Q, ManagedWebGLRenderingContext: () => vt, MathUtils: () => F, Matrix4: () => Wt, Mesh: () => Mi, MeshAttachment: () => _t, MixBlend: () => ft, MixDirection: () => Dt, OrthoCamera: () => ls, PathAttachment: () => Qt, PathConstraint: () => ie, PathConstraintData: () => bi, PathConstraintMixTimeline: () => si, PathConstraintPositionTimeline: () => ei, PathConstraintSpacingTimeline: () => ii, PointAttachment: () => di, PolygonBatcher: () => Ii, Pool: () => ce, Position2Attribute: () => Ye, Position3Attribute: () => ar, PositionMode: () => Bt, Pow: () => Oi, PowOut: () => Vi, RGB2Timeline: () => Ke, RGBA2Timeline: () => Je, RGBATimeline: () => je, RGBTimeline: () => He, RegionAttachment: () => at, ResizeMode: () => ae, RotateMode: () => $t, RotateTimeline: () => de, SETUP: () => li, SUBSEQUENT: () => we, ScaleTimeline: () => Ue, ScaleXTimeline: () => ze, ScaleYTimeline: () => We, SceneRenderer: () => ds, Shader: () => bt, ShapeRenderer: () => ki, ShapeType: () => yt, ShearTimeline: () => _e, ShearXTimeline: () => qe, ShearYTimeline: () => Ge, Skeleton: () => Xs, SkeletonBinary: () => Rs, SkeletonBounds: () => is, SkeletonClipping: () => Ce, SkeletonData: () => pi, SkeletonDebugRenderer: () => Xe, SkeletonJson: () => $s, SkeletonRenderer: () => Xi, Skin: () => Se, SkinEntry: () => wi, Slot: () => $i, SlotData: () => vi, SpacingMode: () => gt, SpineCanvas: () => dr, StringSet: () => Pe, SwirlEffect: () => rs, TexCoordAttribute: () => Yi, Texture: () => oi, TextureAtlas: () => ji, TextureAtlasPage: () => Hi, TextureAtlasRegion: () => ci, TextureFilter: () => Mt, TextureRegion: () => Gi, TextureWrap: () => Kt, TimeKeeper: () => Be, Timeline: () => mt, Touch: () => hs, TrackEntry: () => zi, TransformConstraint: () => ts, TransformConstraintData: () => yi, TransformConstraintTimeline: () => ti, TransformMode: () => Ct, TranslateTimeline: () => Ve, TranslateXTimeline: () => De, TranslateYTimeline: () => Ne, Triangulator: () => Tt, Utils: () => O, Vector2: () => Ht, Vector3: () => Yt, VertexAttachment: () => Pt, VertexAttribute: () => re, VertexAttributeType: () => qt, WebGLBlendModeConverter: () => Me, WindowedMean: () => Cs });
    var As = class {
      constructor() {
        this.array = new Array();
      }
      add(t) {
        let e = this.contains(t);
        return this.array[t | 0] = t | 0, !e;
      }
      contains(t) {
        return this.array[t | 0] != null;
      }
      remove(t) {
        this.array[t | 0] = void 0;
      }
      clear() {
        this.array.length = 0;
      }
    }, Pe = class {
      constructor() {
        this.entries = {}, this.size = 0;
      }
      add(t) {
        let e = this.entries[t];
        return this.entries[t] = true, e ? false : (this.size++, true);
      }
      addAll(t) {
        let e = this.size;
        for (var i = 0, s = t.length; i < s; i++) this.add(t[i]);
        return e != this.size;
      }
      contains(t) {
        return this.entries[t];
      }
      clear() {
        this.entries = {}, this.size = 0;
      }
    }, jt = class {
      constructor(t = 0, e = 0, i = 0, s = 0) {
        this.r = t, this.g = e, this.b = i, this.a = s;
      }
      set(t, e, i, s) {
        return this.r = t, this.g = e, this.b = i, this.a = s, this.clamp();
      }
      setFromColor(t) {
        return this.r = t.r, this.g = t.g, this.b = t.b, this.a = t.a, this;
      }
      setFromString(t) {
        return t = t.charAt(0) == "#" ? t.substr(1) : t, this.r = parseInt(t.substr(0, 2), 16) / 255, this.g = parseInt(t.substr(2, 2), 16) / 255, this.b = parseInt(t.substr(4, 2), 16) / 255, this.a = t.length != 8 ? 1 : parseInt(t.substr(6, 2), 16) / 255, this;
      }
      add(t, e, i, s) {
        return this.r += t, this.g += e, this.b += i, this.a += s, this.clamp();
      }
      clamp() {
        return this.r < 0 ? this.r = 0 : this.r > 1 && (this.r = 1), this.g < 0 ? this.g = 0 : this.g > 1 && (this.g = 1), this.b < 0 ? this.b = 0 : this.b > 1 && (this.b = 1), this.a < 0 ? this.a = 0 : this.a > 1 && (this.a = 1), this;
      }
      static rgba8888ToColor(t, e) {
        t.r = ((e & 4278190080) >>> 24) / 255, t.g = ((e & 16711680) >>> 16) / 255, t.b = ((e & 65280) >>> 8) / 255, t.a = (e & 255) / 255;
      }
      static rgb888ToColor(t, e) {
        t.r = ((e & 16711680) >>> 16) / 255, t.g = ((e & 65280) >>> 8) / 255, t.b = (e & 255) / 255;
      }
      static fromString(t) {
        return new jt().setFromString(t);
      }
    }, D = jt;
    D.WHITE = new jt(1, 1, 1, 1), D.RED = new jt(1, 0, 0, 1), D.GREEN = new jt(0, 1, 0, 1), D.BLUE = new jt(0, 0, 1, 1), D.MAGENTA = new jt(1, 0, 1, 1);
    var Vt = class {
      static clamp(t, e, i) {
        return t < e ? e : t > i ? i : t;
      }
      static cosDeg(t) {
        return Math.cos(t * Vt.degRad);
      }
      static sinDeg(t) {
        return Math.sin(t * Vt.degRad);
      }
      static signum(t) {
        return t > 0 ? 1 : t < 0 ? -1 : 0;
      }
      static toInt(t) {
        return t > 0 ? Math.floor(t) : Math.ceil(t);
      }
      static cbrt(t) {
        let e = Math.pow(Math.abs(t), 1 / 3);
        return t < 0 ? -e : e;
      }
      static randomTriangular(t, e) {
        return Vt.randomTriangularWith(t, e, (t + e) * 0.5);
      }
      static randomTriangularWith(t, e, i) {
        let s = Math.random(), a = e - t;
        return s <= (i - t) / a ? t + Math.sqrt(s * a * (i - t)) : e - Math.sqrt((1 - s) * a * (e - i));
      }
      static isPowerOfTwo(t) {
        return t && (t & t - 1) == 0;
      }
    }, F = Vt;
    F.PI = 3.1415927, F.PI2 = Vt.PI * 2, F.radiansToDegrees = 180 / Vt.PI, F.radDeg = Vt.radiansToDegrees, F.degreesToRadians = Vt.PI / 180, F.degRad = Vt.degreesToRadians;
    var Bi = class {
      apply(t, e, i) {
        return t + (e - t) * this.applyInternal(i);
      }
    }, Oi = class extends Bi {
      constructor(t) {
        super();
        this.power = 2, this.power = t;
      }
      applyInternal(t) {
        return t <= 0.5 ? Math.pow(t * 2, this.power) / 2 : Math.pow((t - 1) * 2, this.power) / (this.power % 2 == 0 ? -2 : 2) + 1;
      }
    }, Vi = class extends Oi {
      constructor(t) {
        super(t);
      }
      applyInternal(t) {
        return Math.pow(t - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1;
      }
    }, ee = class {
      static arrayCopy(t, e, i, s, a) {
        for (let c = e, n = s; c < e + a; c++, n++) i[n] = t[c];
      }
      static arrayFill(t, e, i, s) {
        for (let a = e; a < i; a++) t[a] = s;
      }
      static setArraySize(t, e, i = 0) {
        let s = t.length;
        if (s == e) return t;
        if (t.length = e, s < e) for (let a = s; a < e; a++) t[a] = i;
        return t;
      }
      static ensureArrayCapacity(t, e, i = 0) {
        return t.length >= e ? t : ee.setArraySize(t, e, i);
      }
      static newArray(t, e) {
        let i = new Array(t);
        for (let s = 0; s < t; s++) i[s] = e;
        return i;
      }
      static newFloatArray(t) {
        if (ee.SUPPORTS_TYPED_ARRAYS) return new Float32Array(t);
        {
          let e = new Array(t);
          for (let i = 0; i < e.length; i++) e[i] = 0;
          return e;
        }
      }
      static newShortArray(t) {
        if (ee.SUPPORTS_TYPED_ARRAYS) return new Int16Array(t);
        {
          let e = new Array(t);
          for (let i = 0; i < e.length; i++) e[i] = 0;
          return e;
        }
      }
      static toFloatArray(t) {
        return ee.SUPPORTS_TYPED_ARRAYS ? new Float32Array(t) : t;
      }
      static toSinglePrecision(t) {
        return ee.SUPPORTS_TYPED_ARRAYS ? Math.fround(t) : t;
      }
      static webkit602BugfixHelper(t, e) {
      }
      static contains(t, e, i = true) {
        for (var s = 0; s < t.length; s++) if (t[s] == e) return true;
        return false;
      }
      static enumValue(t, e) {
        return t[e[0].toUpperCase() + e.slice(1)];
      }
    }, O = ee;
    O.SUPPORTS_TYPED_ARRAYS = typeof Float32Array != "undefined";
    var Ss = class {
      static logBones(t) {
        for (let e = 0; e < t.bones.length; e++) {
          let i = t.bones[e];
          console.log(i.data.name + ", " + i.a + ", " + i.b + ", " + i.c + ", " + i.d + ", " + i.worldX + ", " + i.worldY);
        }
      }
    }, ce = class {
      constructor(t) {
        this.items = new Array(), this.instantiator = t;
      }
      obtain() {
        return this.items.length > 0 ? this.items.pop() : this.instantiator();
      }
      free(t) {
        t.reset && t.reset(), this.items.push(t);
      }
      freeAll(t) {
        for (let e = 0; e < t.length; e++) this.free(t[e]);
      }
      clear() {
        this.items.length = 0;
      }
    }, Ht = class {
      constructor(t = 0, e = 0) {
        this.x = t, this.y = e;
      }
      set(t, e) {
        return this.x = t, this.y = e, this;
      }
      length() {
        let t = this.x, e = this.y;
        return Math.sqrt(t * t + e * e);
      }
      normalize() {
        let t = this.length();
        return t != 0 && (this.x /= t, this.y /= t), this;
      }
    }, Be = class {
      constructor() {
        this.maxDelta = 0.064, this.framesPerSecond = 0, this.delta = 0, this.totalTime = 0, this.lastTime = Date.now() / 1e3, this.frameCount = 0, this.frameTime = 0;
      }
      update() {
        let t = Date.now() / 1e3;
        this.delta = t - this.lastTime, this.frameTime += this.delta, this.totalTime += this.delta, this.delta > this.maxDelta && (this.delta = this.maxDelta), this.lastTime = t, this.frameCount++, this.frameTime > 1 && (this.framesPerSecond = this.frameCount / this.frameTime, this.frameTime = 0, this.frameCount = 0);
      }
    }, Cs = class {
      constructor(t = 32) {
        this.addedValues = 0, this.lastValue = 0, this.mean = 0, this.dirty = true, this.values = new Array(t);
      }
      hasEnoughData() {
        return this.addedValues >= this.values.length;
      }
      addValue(t) {
        this.addedValues < this.values.length && this.addedValues++, this.values[this.lastValue++] = t, this.lastValue > this.values.length - 1 && (this.lastValue = 0), this.dirty = true;
      }
      getMean() {
        if (this.hasEnoughData()) {
          if (this.dirty) {
            let t = 0;
            for (let e = 0; e < this.values.length; e++) t += this.values[e];
            this.mean = t / this.values.length, this.dirty = false;
          }
          return this.mean;
        }
        return 0;
      }
    }, Oe = class {
      constructor(t) {
        if (!t) throw new Error("name cannot be null.");
        this.name = t;
      }
    }, Di = class extends Oe {
      constructor(t) {
        super(t);
        this.id = Di.nextID++, this.bones = null, this.vertices = null, this.worldVerticesLength = 0, this.deformAttachment = this;
      }
      computeWorldVertices(t, e, i, s, a, c) {
        i = a + (i >> 1) * c;
        let n = t.bone.skeleton, r = t.deform, h = this.vertices, l = this.bones;
        if (!l) {
          r.length > 0 && (h = r);
          let m = t.bone, f = m.worldX, x = m.worldY, w = m.a, v = m.b, g = m.c, p = m.d;
          for (let b = e, y = a; y < i; b += 2, y += c) {
            let T = h[b], A = h[b + 1];
            s[y] = T * w + A * v + f, s[y + 1] = T * g + A * p + x;
          }
          return;
        }
        let o = 0, d = 0;
        for (let m = 0; m < e; m += 2) {
          let f = l[o];
          o += f + 1, d += f;
        }
        let u = n.bones;
        if (r.length == 0) for (let m = a, f = d * 3; m < i; m += c) {
          let x = 0, w = 0, v = l[o++];
          for (v += o; o < v; o++, f += 3) {
            let g = u[l[o]], p = h[f], b = h[f + 1], y = h[f + 2];
            x += (p * g.a + b * g.b + g.worldX) * y, w += (p * g.c + b * g.d + g.worldY) * y;
          }
          s[m] = x, s[m + 1] = w;
        }
        else {
          let m = r;
          for (let f = a, x = d * 3, w = d << 1; f < i; f += c) {
            let v = 0, g = 0, p = l[o++];
            for (p += o; o < p; o++, x += 3, w += 2) {
              let b = u[l[o]], y = h[x] + m[w], T = h[x + 1] + m[w + 1], A = h[x + 2];
              v += (y * b.a + T * b.b + b.worldX) * A, g += (y * b.c + T * b.d + b.worldY) * A;
            }
            s[f] = v, s[f + 1] = g;
          }
        }
      }
      copyTo(t) {
        this.bones ? (t.bones = new Array(this.bones.length), O.arrayCopy(this.bones, 0, t.bones, 0, this.bones.length)) : t.bones = null, this.vertices ? (t.vertices = O.newFloatArray(this.vertices.length), O.arrayCopy(this.vertices, 0, t.vertices, 0, this.vertices.length)) : t.vertices = null, t.worldVerticesLength = this.worldVerticesLength, t.deformAttachment = this.deformAttachment;
      }
    }, Pt = Di;
    Pt.nextID = 0;
    var be = class {
      constructor(t, e, i) {
        if (this.timelines = null, this.timelineIds = null, !t) throw new Error("name cannot be null.");
        this.name = t, this.setTimelines(e), this.duration = i;
      }
      setTimelines(t) {
        if (!t) throw new Error("timelines cannot be null.");
        this.timelines = t, this.timelineIds = new Pe();
        for (var e = 0; e < t.length; e++) this.timelineIds.addAll(t[e].getPropertyIds());
      }
      hasTimeline(t) {
        for (let e = 0; e < t.length; e++) if (this.timelineIds.contains(t[e])) return true;
        return false;
      }
      apply(t, e, i, s, a, c, n, r) {
        if (!t) throw new Error("skeleton cannot be null.");
        s && this.duration != 0 && (i %= this.duration, e > 0 && (e %= this.duration));
        let h = this.timelines;
        for (let l = 0, o = h.length; l < o; l++) h[l].apply(t, e, i, a, c, n, r);
      }
    }, ft;
    (function(t) {
      t[t.setup = 0] = "setup", t[t.first = 1] = "first", t[t.replace = 2] = "replace", t[t.add = 3] = "add";
    })(ft || (ft = {}));
    var Dt;
    (function(t) {
      t[t.mixIn = 0] = "mixIn", t[t.mixOut = 1] = "mixOut";
    })(Dt || (Dt = {}));
    var ht = { rotate: 0, x: 1, y: 2, scaleX: 3, scaleY: 4, shearX: 5, shearY: 6, rgb: 7, alpha: 8, rgb2: 9, attachment: 10, deform: 11, event: 12, drawOrder: 13, ikConstraint: 14, transformConstraint: 15, pathConstraintPosition: 16, pathConstraintSpacing: 17, pathConstraintMix: 18 }, mt = class {
      constructor(t, e) {
        this.propertyIds = null, this.frames = null, this.propertyIds = e, this.frames = O.newFloatArray(t * this.getFrameEntries());
      }
      getPropertyIds() {
        return this.propertyIds;
      }
      getFrameEntries() {
        return 1;
      }
      getFrameCount() {
        return this.frames.length / this.getFrameEntries();
      }
      getDuration() {
        return this.frames[this.frames.length - this.getFrameEntries()];
      }
      static search1(t, e) {
        let i = t.length;
        for (let s = 1; s < i; s++) if (t[s] > e) return s - 1;
        return i - 1;
      }
      static search(t, e, i) {
        let s = t.length;
        for (let a = i; a < s; a += i) if (t[a] > e) return a - i;
        return s - i;
      }
    }, Xt = class extends mt {
      constructor(t, e, i) {
        super(t, i);
        this.curves = null, this.curves = O.newFloatArray(t + e * 18), this.curves[t - 1] = 1;
      }
      setLinear(t) {
        this.curves[t] = 0;
      }
      setStepped(t) {
        this.curves[t] = 1;
      }
      shrink(t) {
        let e = this.getFrameCount() + t * 18;
        if (this.curves.length > e) {
          let i = O.newFloatArray(e);
          O.arrayCopy(this.curves, 0, i, 0, e), this.curves = i;
        }
      }
      setBezier(t, e, i, s, a, c, n, r, h, l, o) {
        let d = this.curves, u = this.getFrameCount() + t * 18;
        i == 0 && (d[e] = 2 + u);
        let m = (s - c * 2 + r) * 0.03, f = (a - n * 2 + h) * 0.03, x = ((c - r) * 3 - s + l) * 6e-3, w = ((n - h) * 3 - a + o) * 6e-3, v = m * 2 + x, g = f * 2 + w, p = (c - s) * 0.3 + m + x * 0.16666667, b = (n - a) * 0.3 + f + w * 0.16666667, y = s + p, T = a + b;
        for (let A = u + 18; u < A; u += 2) d[u] = y, d[u + 1] = T, p += v, b += g, v += x, g += w, y += p, T += b;
      }
      getBezierValue(t, e, i, s) {
        let a = this.curves;
        if (a[s] > t) {
          let h = this.frames[e], l = this.frames[e + i];
          return l + (t - h) / (a[s] - h) * (a[s + 1] - l);
        }
        let c = s + 18;
        for (s += 2; s < c; s += 2) if (a[s] >= t) {
          let h = a[s - 2], l = a[s - 1];
          return l + (t - h) / (a[s] - h) * (a[s + 1] - l);
        }
        e += this.getFrameEntries();
        let n = a[c - 2], r = a[c - 1];
        return r + (t - n) / (this.frames[e] - n) * (this.frames[e + i] - r);
      }
    }, Rt = class extends Xt {
      constructor(t, e, i) {
        super(t, e, [i]);
      }
      getFrameEntries() {
        return 2;
      }
      setFrame(t, e, i) {
        t <<= 1, this.frames[t] = e, this.frames[t + 1] = i;
      }
      getCurveValue(t) {
        let e = this.frames, i = e.length - 2;
        for (let a = 2; a <= i; a += 2) if (e[a] > t) {
          i = a - 2;
          break;
        }
        let s = this.curves[i >> 1];
        switch (s) {
          case 0:
            let a = e[i], c = e[i + 1];
            return c + (t - a) / (e[i + 2] - a) * (e[i + 2 + 1] - c);
          case 1:
            return e[i + 1];
        }
        return this.getBezierValue(t, i, 1, s - 2);
      }
    }, pe = class extends Xt {
      constructor(t, e, i, s) {
        super(t, e, [i, s]);
      }
      getFrameEntries() {
        return 3;
      }
      setFrame(t, e, i, s) {
        t *= 3, this.frames[t] = e, this.frames[t + 1] = i, this.frames[t + 2] = s;
      }
    }, de = class extends Rt {
      constructor(t, e, i) {
        super(t, e, ht.rotate + "|" + i);
        this.boneIndex = 0, this.boneIndex = i;
      }
      apply(t, e, i, s, a, c, n) {
        let r = t.bones[this.boneIndex];
        if (!r.active) return;
        let h = this.frames;
        if (i < h[0]) {
          switch (c) {
            case 0:
              r.rotation = r.data.rotation;
              return;
            case 1:
              r.rotation += (r.data.rotation - r.rotation) * a;
          }
          return;
        }
        let l = this.getCurveValue(i);
        switch (c) {
          case 0:
            r.rotation = r.data.rotation + l * a;
            break;
          case 1:
          case 2:
            l += r.data.rotation - r.rotation;
          case 3:
            r.rotation += l * a;
        }
      }
    }, Ve = class extends pe {
      constructor(t, e, i) {
        super(t, e, ht.x + "|" + i, ht.y + "|" + i);
        this.boneIndex = 0, this.boneIndex = i;
      }
      apply(t, e, i, s, a, c, n) {
        let r = t.bones[this.boneIndex];
        if (!r.active) return;
        let h = this.frames;
        if (i < h[0]) {
          switch (c) {
            case 0:
              r.x = r.data.x, r.y = r.data.y;
              return;
            case 1:
              r.x += (r.data.x - r.x) * a, r.y += (r.data.y - r.y) * a;
          }
          return;
        }
        let l = 0, o = 0, d = mt.search(h, i, 3), u = this.curves[d / 3];
        switch (u) {
          case 0:
            let m = h[d];
            l = h[d + 1], o = h[d + 2];
            let f = (i - m) / (h[d + 3] - m);
            l += (h[d + 3 + 1] - l) * f, o += (h[d + 3 + 2] - o) * f;
            break;
          case 1:
            l = h[d + 1], o = h[d + 2];
            break;
          default:
            l = this.getBezierValue(i, d, 1, u - 2), o = this.getBezierValue(i, d, 2, u + 18 - 2);
        }
        switch (c) {
          case 0:
            r.x = r.data.x + l * a, r.y = r.data.y + o * a;
            break;
          case 1:
          case 2:
            r.x += (r.data.x + l - r.x) * a, r.y += (r.data.y + o - r.y) * a;
            break;
          case 3:
            r.x += l * a, r.y += o * a;
        }
      }
    }, De = class extends Rt {
      constructor(t, e, i) {
        super(t, e, ht.x + "|" + i);
        this.boneIndex = 0, this.boneIndex = i;
      }
      apply(t, e, i, s, a, c, n) {
        let r = t.bones[this.boneIndex];
        if (!r.active) return;
        let h = this.frames;
        if (i < h[0]) {
          switch (c) {
            case 0:
              r.x = r.data.x;
              return;
            case 1:
              r.x += (r.data.x - r.x) * a;
          }
          return;
        }
        let l = this.getCurveValue(i);
        switch (c) {
          case 0:
            r.x = r.data.x + l * a;
            break;
          case 1:
          case 2:
            r.x += (r.data.x + l - r.x) * a;
            break;
          case 3:
            r.x += l * a;
        }
      }
    }, Ne = class extends Rt {
      constructor(t, e, i) {
        super(t, e, ht.y + "|" + i);
        this.boneIndex = 0, this.boneIndex = i;
      }
      apply(t, e, i, s, a, c, n) {
        let r = t.bones[this.boneIndex];
        if (!r.active) return;
        let h = this.frames;
        if (i < h[0]) {
          switch (c) {
            case 0:
              r.y = r.data.y;
              return;
            case 1:
              r.y += (r.data.y - r.y) * a;
          }
          return;
        }
        let l = this.getCurveValue(i);
        switch (c) {
          case 0:
            r.y = r.data.y + l * a;
            break;
          case 1:
          case 2:
            r.y += (r.data.y + l - r.y) * a;
            break;
          case 3:
            r.y += l * a;
        }
      }
    }, Ue = class extends pe {
      constructor(t, e, i) {
        super(t, e, ht.scaleX + "|" + i, ht.scaleY + "|" + i);
        this.boneIndex = 0, this.boneIndex = i;
      }
      apply(t, e, i, s, a, c, n) {
        let r = t.bones[this.boneIndex];
        if (!r.active) return;
        let h = this.frames;
        if (i < h[0]) {
          switch (c) {
            case 0:
              r.scaleX = r.data.scaleX, r.scaleY = r.data.scaleY;
              return;
            case 1:
              r.scaleX += (r.data.scaleX - r.scaleX) * a, r.scaleY += (r.data.scaleY - r.scaleY) * a;
          }
          return;
        }
        let l, o, d = mt.search(h, i, 3), u = this.curves[d / 3];
        switch (u) {
          case 0:
            let m = h[d];
            l = h[d + 1], o = h[d + 2];
            let f = (i - m) / (h[d + 3] - m);
            l += (h[d + 3 + 1] - l) * f, o += (h[d + 3 + 2] - o) * f;
            break;
          case 1:
            l = h[d + 1], o = h[d + 2];
            break;
          default:
            l = this.getBezierValue(i, d, 1, u - 2), o = this.getBezierValue(i, d, 2, u + 18 - 2);
        }
        if (l *= r.data.scaleX, o *= r.data.scaleY, a == 1) c == 3 ? (r.scaleX += l - r.data.scaleX, r.scaleY += o - r.data.scaleY) : (r.scaleX = l, r.scaleY = o);
        else {
          let m = 0, f = 0;
          if (n == 1) switch (c) {
            case 0:
              m = r.data.scaleX, f = r.data.scaleY, r.scaleX = m + (Math.abs(l) * F.signum(m) - m) * a, r.scaleY = f + (Math.abs(o) * F.signum(f) - f) * a;
              break;
            case 1:
            case 2:
              m = r.scaleX, f = r.scaleY, r.scaleX = m + (Math.abs(l) * F.signum(m) - m) * a, r.scaleY = f + (Math.abs(o) * F.signum(f) - f) * a;
              break;
            case 3:
              r.scaleX += (l - r.data.scaleX) * a, r.scaleY += (o - r.data.scaleY) * a;
          }
          else switch (c) {
            case 0:
              m = Math.abs(r.data.scaleX) * F.signum(l), f = Math.abs(r.data.scaleY) * F.signum(o), r.scaleX = m + (l - m) * a, r.scaleY = f + (o - f) * a;
              break;
            case 1:
            case 2:
              m = Math.abs(r.scaleX) * F.signum(l), f = Math.abs(r.scaleY) * F.signum(o), r.scaleX = m + (l - m) * a, r.scaleY = f + (o - f) * a;
              break;
            case 3:
              r.scaleX += (l - r.data.scaleX) * a, r.scaleY += (o - r.data.scaleY) * a;
          }
        }
      }
    }, ze = class extends Rt {
      constructor(t, e, i) {
        super(t, e, ht.scaleX + "|" + i);
        this.boneIndex = 0, this.boneIndex = i;
      }
      apply(t, e, i, s, a, c, n) {
        let r = t.bones[this.boneIndex];
        if (!r.active) return;
        let h = this.frames;
        if (i < h[0]) {
          switch (c) {
            case 0:
              r.scaleX = r.data.scaleX;
              return;
            case 1:
              r.scaleX += (r.data.scaleX - r.scaleX) * a;
          }
          return;
        }
        let l = this.getCurveValue(i) * r.data.scaleX;
        if (a == 1) c == 3 ? r.scaleX += l - r.data.scaleX : r.scaleX = l;
        else {
          let o = 0;
          if (n == 1) switch (c) {
            case 0:
              o = r.data.scaleX, r.scaleX = o + (Math.abs(l) * F.signum(o) - o) * a;
              break;
            case 1:
            case 2:
              o = r.scaleX, r.scaleX = o + (Math.abs(l) * F.signum(o) - o) * a;
              break;
            case 3:
              r.scaleX += (l - r.data.scaleX) * a;
          }
          else switch (c) {
            case 0:
              o = Math.abs(r.data.scaleX) * F.signum(l), r.scaleX = o + (l - o) * a;
              break;
            case 1:
            case 2:
              o = Math.abs(r.scaleX) * F.signum(l), r.scaleX = o + (l - o) * a;
              break;
            case 3:
              r.scaleX += (l - r.data.scaleX) * a;
          }
        }
      }
    }, We = class extends Rt {
      constructor(t, e, i) {
        super(t, e, ht.scaleY + "|" + i);
        this.boneIndex = 0, this.boneIndex = i;
      }
      apply(t, e, i, s, a, c, n) {
        let r = t.bones[this.boneIndex];
        if (!r.active) return;
        let h = this.frames;
        if (i < h[0]) {
          switch (c) {
            case 0:
              r.scaleY = r.data.scaleY;
              return;
            case 1:
              r.scaleY += (r.data.scaleY - r.scaleY) * a;
          }
          return;
        }
        let l = this.getCurveValue(i) * r.data.scaleY;
        if (a == 1) c == 3 ? r.scaleY += l - r.data.scaleY : r.scaleY = l;
        else {
          let o = 0;
          if (n == 1) switch (c) {
            case 0:
              o = r.data.scaleY, r.scaleY = o + (Math.abs(l) * F.signum(o) - o) * a;
              break;
            case 1:
            case 2:
              o = r.scaleY, r.scaleY = o + (Math.abs(l) * F.signum(o) - o) * a;
              break;
            case 3:
              r.scaleY += (l - r.data.scaleY) * a;
          }
          else switch (c) {
            case 0:
              o = Math.abs(r.data.scaleY) * F.signum(l), r.scaleY = o + (l - o) * a;
              break;
            case 1:
            case 2:
              o = Math.abs(r.scaleY) * F.signum(l), r.scaleY = o + (l - o) * a;
              break;
            case 3:
              r.scaleY += (l - r.data.scaleY) * a;
          }
        }
      }
    }, _e = class extends pe {
      constructor(t, e, i) {
        super(t, e, ht.shearX + "|" + i, ht.shearY + "|" + i);
        this.boneIndex = 0, this.boneIndex = i;
      }
      apply(t, e, i, s, a, c, n) {
        let r = t.bones[this.boneIndex];
        if (!r.active) return;
        let h = this.frames;
        if (i < h[0]) {
          switch (c) {
            case 0:
              r.shearX = r.data.shearX, r.shearY = r.data.shearY;
              return;
            case 1:
              r.shearX += (r.data.shearX - r.shearX) * a, r.shearY += (r.data.shearY - r.shearY) * a;
          }
          return;
        }
        let l = 0, o = 0, d = mt.search(h, i, 3), u = this.curves[d / 3];
        switch (u) {
          case 0:
            let m = h[d];
            l = h[d + 1], o = h[d + 2];
            let f = (i - m) / (h[d + 3] - m);
            l += (h[d + 3 + 1] - l) * f, o += (h[d + 3 + 2] - o) * f;
            break;
          case 1:
            l = h[d + 1], o = h[d + 2];
            break;
          default:
            l = this.getBezierValue(i, d, 1, u - 2), o = this.getBezierValue(i, d, 2, u + 18 - 2);
        }
        switch (c) {
          case 0:
            r.shearX = r.data.shearX + l * a, r.shearY = r.data.shearY + o * a;
            break;
          case 1:
          case 2:
            r.shearX += (r.data.shearX + l - r.shearX) * a, r.shearY += (r.data.shearY + o - r.shearY) * a;
            break;
          case 3:
            r.shearX += l * a, r.shearY += o * a;
        }
      }
    }, qe = class extends Rt {
      constructor(t, e, i) {
        super(t, e, ht.shearX + "|" + i);
        this.boneIndex = 0, this.boneIndex = i;
      }
      apply(t, e, i, s, a, c, n) {
        let r = t.bones[this.boneIndex];
        if (!r.active) return;
        let h = this.frames;
        if (i < h[0]) {
          switch (c) {
            case 0:
              r.shearX = r.data.shearX;
              return;
            case 1:
              r.shearX += (r.data.shearX - r.shearX) * a;
          }
          return;
        }
        let l = this.getCurveValue(i);
        switch (c) {
          case 0:
            r.shearX = r.data.shearX + l * a;
            break;
          case 1:
          case 2:
            r.shearX += (r.data.shearX + l - r.shearX) * a;
            break;
          case 3:
            r.shearX += l * a;
        }
      }
    }, Ge = class extends Rt {
      constructor(t, e, i) {
        super(t, e, ht.shearY + "|" + i);
        this.boneIndex = 0, this.boneIndex = i;
      }
      apply(t, e, i, s, a, c, n) {
        let r = t.bones[this.boneIndex];
        if (!r.active) return;
        let h = this.frames;
        if (i < h[0]) {
          switch (c) {
            case 0:
              r.shearY = r.data.shearY;
              return;
            case 1:
              r.shearY += (r.data.shearY - r.shearY) * a;
          }
          return;
        }
        let l = this.getCurveValue(i);
        switch (c) {
          case 0:
            r.shearY = r.data.shearY + l * a;
            break;
          case 1:
          case 2:
            r.shearY += (r.data.shearY + l - r.shearY) * a;
            break;
          case 3:
            r.shearY += l * a;
        }
      }
    }, je = class extends Xt {
      constructor(t, e, i) {
        super(t, e, [ht.rgb + "|" + i, ht.alpha + "|" + i]);
        this.slotIndex = 0, this.slotIndex = i;
      }
      getFrameEntries() {
        return 5;
      }
      setFrame(t, e, i, s, a, c) {
        t *= 5, this.frames[t] = e, this.frames[t + 1] = i, this.frames[t + 2] = s, this.frames[t + 3] = a, this.frames[t + 4] = c;
      }
      apply(t, e, i, s, a, c, n) {
        let r = t.slots[this.slotIndex];
        if (!r.bone.active) return;
        let h = this.frames, l = r.color;
        if (i < h[0]) {
          let w = r.data.color;
          switch (c) {
            case 0:
              l.setFromColor(w);
              return;
            case 1:
              l.add((w.r - l.r) * a, (w.g - l.g) * a, (w.b - l.b) * a, (w.a - l.a) * a);
          }
          return;
        }
        let o = 0, d = 0, u = 0, m = 0, f = mt.search(h, i, 5), x = this.curves[f / 5];
        switch (x) {
          case 0:
            let w = h[f];
            o = h[f + 1], d = h[f + 2], u = h[f + 3], m = h[f + 4];
            let v = (i - w) / (h[f + 5] - w);
            o += (h[f + 5 + 1] - o) * v, d += (h[f + 5 + 2] - d) * v, u += (h[f + 5 + 3] - u) * v, m += (h[f + 5 + 4] - m) * v;
            break;
          case 1:
            o = h[f + 1], d = h[f + 2], u = h[f + 3], m = h[f + 4];
            break;
          default:
            o = this.getBezierValue(i, f, 1, x - 2), d = this.getBezierValue(i, f, 2, x + 18 - 2), u = this.getBezierValue(i, f, 3, x + 18 * 2 - 2), m = this.getBezierValue(i, f, 4, x + 18 * 3 - 2);
        }
        a == 1 ? l.set(o, d, u, m) : (c == 0 && l.setFromColor(r.data.color), l.add((o - l.r) * a, (d - l.g) * a, (u - l.b) * a, (m - l.a) * a));
      }
    }, He = class extends Xt {
      constructor(t, e, i) {
        super(t, e, [ht.rgb + "|" + i]);
        this.slotIndex = 0, this.slotIndex = i;
      }
      getFrameEntries() {
        return 4;
      }
      setFrame(t, e, i, s, a) {
        t <<= 2, this.frames[t] = e, this.frames[t + 1] = i, this.frames[t + 2] = s, this.frames[t + 3] = a;
      }
      apply(t, e, i, s, a, c, n) {
        let r = t.slots[this.slotIndex];
        if (!r.bone.active) return;
        let h = this.frames, l = r.color;
        if (i < h[0]) {
          let x = r.data.color;
          switch (c) {
            case 0:
              l.r = x.r, l.g = x.g, l.b = x.b;
              return;
            case 1:
              l.r += (x.r - l.r) * a, l.g += (x.g - l.g) * a, l.b += (x.b - l.b) * a;
          }
          return;
        }
        let o = 0, d = 0, u = 0, m = mt.search(h, i, 4), f = this.curves[m >> 2];
        switch (f) {
          case 0:
            let x = h[m];
            o = h[m + 1], d = h[m + 2], u = h[m + 3];
            let w = (i - x) / (h[m + 4] - x);
            o += (h[m + 4 + 1] - o) * w, d += (h[m + 4 + 2] - d) * w, u += (h[m + 4 + 3] - u) * w;
            break;
          case 1:
            o = h[m + 1], d = h[m + 2], u = h[m + 3];
            break;
          default:
            o = this.getBezierValue(i, m, 1, f - 2), d = this.getBezierValue(i, m, 2, f + 18 - 2), u = this.getBezierValue(i, m, 3, f + 18 * 2 - 2);
        }
        if (a == 1) l.r = o, l.g = d, l.b = u;
        else {
          if (c == 0) {
            let x = r.data.color;
            l.r = x.r, l.g = x.g, l.b = x.b;
          }
          l.r += (o - l.r) * a, l.g += (d - l.g) * a, l.b += (u - l.b) * a;
        }
      }
    }, Ze = class extends Rt {
      constructor(t, e, i) {
        super(t, e, ht.alpha + "|" + i);
        this.slotIndex = 0, this.slotIndex = i;
      }
      apply(t, e, i, s, a, c, n) {
        let r = t.slots[this.slotIndex];
        if (!r.bone.active) return;
        let h = r.color;
        if (i < this.frames[0]) {
          let o = r.data.color;
          switch (c) {
            case 0:
              h.a = o.a;
              return;
            case 1:
              h.a += (o.a - h.a) * a;
          }
          return;
        }
        let l = this.getCurveValue(i);
        a == 1 ? h.a = l : (c == 0 && (h.a = r.data.color.a), h.a += (l - h.a) * a);
      }
    }, Je = class extends Xt {
      constructor(t, e, i) {
        super(t, e, [ht.rgb + "|" + i, ht.alpha + "|" + i, ht.rgb2 + "|" + i]);
        this.slotIndex = 0, this.slotIndex = i;
      }
      getFrameEntries() {
        return 8;
      }
      setFrame(t, e, i, s, a, c, n, r, h) {
        t <<= 3, this.frames[t] = e, this.frames[t + 1] = i, this.frames[t + 2] = s, this.frames[t + 3] = a, this.frames[t + 4] = c, this.frames[t + 5] = n, this.frames[t + 6] = r, this.frames[t + 7] = h;
      }
      apply(t, e, i, s, a, c, n) {
        let r = t.slots[this.slotIndex];
        if (!r.bone.active) return;
        let h = this.frames, l = r.color, o = r.darkColor;
        if (i < h[0]) {
          let b = r.data.color, y = r.data.darkColor;
          switch (c) {
            case 0:
              l.setFromColor(b), o.r = y.r, o.g = y.g, o.b = y.b;
              return;
            case 1:
              l.add((b.r - l.r) * a, (b.g - l.g) * a, (b.b - l.b) * a, (b.a - l.a) * a), o.r += (y.r - o.r) * a, o.g += (y.g - o.g) * a, o.b += (y.b - o.b) * a;
          }
          return;
        }
        let d = 0, u = 0, m = 0, f = 0, x = 0, w = 0, v = 0, g = mt.search(h, i, 8), p = this.curves[g >> 3];
        switch (p) {
          case 0:
            let b = h[g];
            d = h[g + 1], u = h[g + 2], m = h[g + 3], f = h[g + 4], x = h[g + 5], w = h[g + 6], v = h[g + 7];
            let y = (i - b) / (h[g + 8] - b);
            d += (h[g + 8 + 1] - d) * y, u += (h[g + 8 + 2] - u) * y, m += (h[g + 8 + 3] - m) * y, f += (h[g + 8 + 4] - f) * y, x += (h[g + 8 + 5] - x) * y, w += (h[g + 8 + 6] - w) * y, v += (h[g + 8 + 7] - v) * y;
            break;
          case 1:
            d = h[g + 1], u = h[g + 2], m = h[g + 3], f = h[g + 4], x = h[g + 5], w = h[g + 6], v = h[g + 7];
            break;
          default:
            d = this.getBezierValue(i, g, 1, p - 2), u = this.getBezierValue(i, g, 2, p + 18 - 2), m = this.getBezierValue(i, g, 3, p + 18 * 2 - 2), f = this.getBezierValue(i, g, 4, p + 18 * 3 - 2), x = this.getBezierValue(i, g, 5, p + 18 * 4 - 2), w = this.getBezierValue(i, g, 6, p + 18 * 5 - 2), v = this.getBezierValue(i, g, 7, p + 18 * 6 - 2);
        }
        if (a == 1) l.set(d, u, m, f), o.r = x, o.g = w, o.b = v;
        else {
          if (c == 0) {
            l.setFromColor(r.data.color);
            let b = r.data.darkColor;
            o.r = b.r, o.g = b.g, o.b = b.b;
          }
          l.add((d - l.r) * a, (u - l.g) * a, (m - l.b) * a, (f - l.a) * a), o.r += (x - o.r) * a, o.g += (w - o.g) * a, o.b += (v - o.b) * a;
        }
      }
    }, Ke = class extends Xt {
      constructor(t, e, i) {
        super(t, e, [ht.rgb + "|" + i, ht.rgb2 + "|" + i]);
        this.slotIndex = 0, this.slotIndex = i;
      }
      getFrameEntries() {
        return 7;
      }
      setFrame(t, e, i, s, a, c, n, r) {
        t *= 7, this.frames[t] = e, this.frames[t + 1] = i, this.frames[t + 2] = s, this.frames[t + 3] = a, this.frames[t + 4] = c, this.frames[t + 5] = n, this.frames[t + 6] = r;
      }
      apply(t, e, i, s, a, c, n) {
        let r = t.slots[this.slotIndex];
        if (!r.bone.active) return;
        let h = this.frames, l = r.color, o = r.darkColor;
        if (i < h[0]) {
          let b = r.data.color, y = r.data.darkColor;
          switch (c) {
            case 0:
              l.r = b.r, l.g = b.g, l.b = b.b, o.r = y.r, o.g = y.g, o.b = y.b;
              return;
            case 1:
              l.r += (b.r - l.r) * a, l.g += (b.g - l.g) * a, l.b += (b.b - l.b) * a, o.r += (y.r - o.r) * a, o.g += (y.g - o.g) * a, o.b += (y.b - o.b) * a;
          }
          return;
        }
        let d = 0, u = 0, m = 0, x = 0, w = 0, v = 0, g = mt.search(h, i, 7), p = this.curves[g / 7];
        switch (p) {
          case 0:
            let b = h[g];
            d = h[g + 1], u = h[g + 2], m = h[g + 3], x = h[g + 4], w = h[g + 5], v = h[g + 6];
            let y = (i - b) / (h[g + 7] - b);
            d += (h[g + 7 + 1] - d) * y, u += (h[g + 7 + 2] - u) * y, m += (h[g + 7 + 3] - m) * y, x += (h[g + 7 + 4] - x) * y, w += (h[g + 7 + 5] - w) * y, v += (h[g + 7 + 6] - v) * y;
            break;
          case 1:
            d = h[g + 1], u = h[g + 2], m = h[g + 3], x = h[g + 4], w = h[g + 5], v = h[g + 6];
            break;
          default:
            d = this.getBezierValue(i, g, 1, p - 2), u = this.getBezierValue(i, g, 2, p + 18 - 2), m = this.getBezierValue(i, g, 3, p + 18 * 2 - 2), x = this.getBezierValue(i, g, 4, p + 18 * 3 - 2), w = this.getBezierValue(i, g, 5, p + 18 * 4 - 2), v = this.getBezierValue(i, g, 6, p + 18 * 5 - 2);
        }
        if (a == 1) l.r = d, l.g = u, l.b = m, o.r = x, o.g = w, o.b = v;
        else {
          if (c == 0) {
            let b = r.data.color, y = r.data.darkColor;
            l.r = b.r, l.g = b.g, l.b = b.b, o.r = y.r, o.g = y.g, o.b = y.b;
          }
          l.r += (d - l.r) * a, l.g += (u - l.g) * a, l.b += (m - l.b) * a, o.r += (x - o.r) * a, o.g += (w - o.g) * a, o.b += (v - o.b) * a;
        }
      }
    }, Zt = class extends mt {
      constructor(t, e) {
        super(t, [ht.attachment + "|" + e]);
        this.slotIndex = 0, this.slotIndex = e, this.attachmentNames = new Array(t);
      }
      getFrameCount() {
        return this.frames.length;
      }
      setFrame(t, e, i) {
        this.frames[t] = e, this.attachmentNames[t] = i;
      }
      apply(t, e, i, s, a, c, n) {
        let r = t.slots[this.slotIndex];
        if (!!r.bone.active) {
          if (n == 1) {
            c == 0 && this.setAttachment(t, r, r.data.attachmentName);
            return;
          }
          if (i < this.frames[0]) {
            (c == 0 || c == 1) && this.setAttachment(t, r, r.data.attachmentName);
            return;
          }
          this.setAttachment(t, r, this.attachmentNames[mt.search1(this.frames, i)]);
        }
      }
      setAttachment(t, e, i) {
        e.setAttachment(i ? t.getAttachment(this.slotIndex, i) : null);
      }
    }, Qe = class extends Xt {
      constructor(t, e, i, s) {
        super(t, e, [ht.deform + "|" + i + "|" + s.id]);
        this.slotIndex = 0, this.attachment = null, this.vertices = null, this.slotIndex = i, this.attachment = s, this.vertices = new Array(t);
      }
      getFrameCount() {
        return this.frames.length;
      }
      setFrame(t, e, i) {
        this.frames[t] = e, this.vertices[t] = i;
      }
      setBezier(t, e, i, s, a, c, n, r, h, l, o) {
        let d = this.curves, u = this.getFrameCount() + t * 18;
        i == 0 && (d[e] = 2 + u);
        let m = (s - c * 2 + r) * 0.03, f = h * 0.03 - n * 0.06, x = ((c - r) * 3 - s + l) * 6e-3, w = (n - h + 0.33333333) * 0.018, v = m * 2 + x, g = f * 2 + w, p = (c - s) * 0.3 + m + x * 0.16666667, b = n * 0.3 + f + w * 0.16666667, y = s + p, T = b;
        for (let A = u + 18; u < A; u += 2) d[u] = y, d[u + 1] = T, p += v, b += g, v += x, g += w, y += p, T += b;
      }
      getCurvePercent(t, e) {
        let i = this.curves, s = i[e];
        switch (s) {
          case 0:
            let r = this.frames[e];
            return (t - r) / (this.frames[e + this.getFrameEntries()] - r);
          case 1:
            return 0;
        }
        if (s -= 2, i[s] > t) {
          let r = this.frames[e];
          return i[s + 1] * (t - r) / (i[s] - r);
        }
        let a = s + 18;
        for (s += 2; s < a; s += 2) if (i[s] >= t) {
          let r = i[s - 2], h = i[s - 1];
          return h + (t - r) / (i[s] - r) * (i[s + 1] - h);
        }
        let c = i[a - 2], n = i[a - 1];
        return n + (1 - n) * (t - c) / (this.frames[e + this.getFrameEntries()] - c);
      }
      apply(t, e, i, s, a, c, n) {
        let r = t.slots[this.slotIndex];
        if (!r.bone.active) return;
        let h = r.getAttachment();
        if (!(h instanceof Pt) || h.deformAttachment != this.attachment) return;
        let l = r.deform;
        l.length == 0 && (c = 0);
        let o = this.vertices, d = o[0].length, u = this.frames;
        if (i < u[0]) {
          let g = h;
          switch (c) {
            case 0:
              l.length = 0;
              return;
            case 1:
              if (a == 1) {
                l.length = 0;
                return;
              }
              if (l.length = d, g.bones) {
                a = 1 - a;
                for (var m = 0; m < d; m++) l[m] *= a;
              } else {
                let p = g.vertices;
                for (var m = 0; m < d; m++) l[m] += (p[m] - l[m]) * a;
              }
          }
          return;
        }
        if (l.length = d, i >= u[u.length - 1]) {
          let g = o[u.length - 1];
          if (a == 1) if (c == 3) {
            let p = h;
            if (p.bones) for (let b = 0; b < d; b++) l[b] += g[b];
            else {
              let b = p.vertices;
              for (let y = 0; y < d; y++) l[y] += g[y] - b[y];
            }
          } else O.arrayCopy(g, 0, l, 0, d);
          else switch (c) {
            case 0: {
              let b = h;
              if (b.bones) for (let y = 0; y < d; y++) l[y] = g[y] * a;
              else {
                let y = b.vertices;
                for (let T = 0; T < d; T++) {
                  let A = y[T];
                  l[T] = A + (g[T] - A) * a;
                }
              }
              break;
            }
            case 1:
            case 2:
              for (let b = 0; b < d; b++) l[b] += (g[b] - l[b]) * a;
              break;
            case 3:
              let p = h;
              if (p.bones) for (let b = 0; b < d; b++) l[b] += g[b] * a;
              else {
                let b = p.vertices;
                for (let y = 0; y < d; y++) l[y] += (g[y] - b[y]) * a;
              }
          }
          return;
        }
        let f = mt.search1(u, i), x = this.getCurvePercent(i, f), w = o[f], v = o[f + 1];
        if (a == 1) if (c == 3) {
          let g = h;
          if (g.bones) for (let p = 0; p < d; p++) {
            let b = w[p];
            l[p] += b + (v[p] - b) * x;
          }
          else {
            let p = g.vertices;
            for (let b = 0; b < d; b++) {
              let y = w[b];
              l[b] += y + (v[b] - y) * x - p[b];
            }
          }
        } else for (let g = 0; g < d; g++) {
          let p = w[g];
          l[g] = p + (v[g] - p) * x;
        }
        else switch (c) {
          case 0: {
            let p = h;
            if (p.bones) for (let b = 0; b < d; b++) {
              let y = w[b];
              l[b] = (y + (v[b] - y) * x) * a;
            }
            else {
              let b = p.vertices;
              for (let y = 0; y < d; y++) {
                let T = w[y], A = b[y];
                l[y] = A + (T + (v[y] - T) * x - A) * a;
              }
            }
            break;
          }
          case 1:
          case 2:
            for (let p = 0; p < d; p++) {
              let b = w[p];
              l[p] += (b + (v[p] - b) * x - l[p]) * a;
            }
            break;
          case 3:
            let g = h;
            if (g.bones) for (let p = 0; p < d; p++) {
              let b = w[p];
              l[p] += (b + (v[p] - b) * x) * a;
            }
            else {
              let p = g.vertices;
              for (let b = 0; b < d; b++) {
                let y = w[b];
                l[b] += (y + (v[b] - y) * x - p[b]) * a;
              }
            }
        }
      }
    }, Ni = class extends mt {
      constructor(t) {
        super(t, Ni.propertyIds);
        this.events = null, this.events = new Array(t);
      }
      getFrameCount() {
        return this.frames.length;
      }
      setFrame(t, e) {
        this.frames[t] = e.time, this.events[t] = e;
      }
      apply(t, e, i, s, a, c, n) {
        if (!s) return;
        let r = this.frames, h = this.frames.length;
        if (e > i) this.apply(t, e, Number.MAX_VALUE, s, a, c, n), e = -1;
        else if (e >= r[h - 1]) return;
        if (i < r[0]) return;
        let l = 0;
        if (e < r[0]) l = 0;
        else {
          l = mt.search1(r, e) + 1;
          let o = r[l];
          for (; l > 0 && r[l - 1] == o; ) l--;
        }
        for (; l < h && i >= r[l]; l++) s.push(this.events[l]);
      }
    }, ue = Ni;
    ue.propertyIds = ["" + ht.event];
    var Ui = class extends mt {
      constructor(t) {
        super(t, Ui.propertyIds);
        this.drawOrders = null, this.drawOrders = new Array(t);
      }
      getFrameCount() {
        return this.frames.length;
      }
      setFrame(t, e, i) {
        this.frames[t] = e, this.drawOrders[t] = i;
      }
      apply(t, e, i, s, a, c, n) {
        if (n == 1) {
          c == 0 && O.arrayCopy(t.slots, 0, t.drawOrder, 0, t.slots.length);
          return;
        }
        if (i < this.frames[0]) {
          (c == 0 || c == 1) && O.arrayCopy(t.slots, 0, t.drawOrder, 0, t.slots.length);
          return;
        }
        let r = this.drawOrders[mt.search1(this.frames, i)];
        if (!r) O.arrayCopy(t.slots, 0, t.drawOrder, 0, t.slots.length);
        else {
          let h = t.drawOrder, l = t.slots;
          for (let o = 0, d = r.length; o < d; o++) h[o] = l[r[o]];
        }
      }
    }, Jt = Ui;
    Jt.propertyIds = ["" + ht.drawOrder];
    var $e = class extends Xt {
      constructor(t, e, i) {
        super(t, e, [ht.ikConstraint + "|" + i]);
        this.ikConstraintIndex = 0, this.ikConstraintIndex = i;
      }
      getFrameEntries() {
        return 6;
      }
      setFrame(t, e, i, s, a, c, n) {
        t *= 6, this.frames[t] = e, this.frames[t + 1] = i, this.frames[t + 2] = s, this.frames[t + 3] = a, this.frames[t + 4] = c ? 1 : 0, this.frames[t + 5] = n ? 1 : 0;
      }
      apply(t, e, i, s, a, c, n) {
        let r = t.ikConstraints[this.ikConstraintIndex];
        if (!r.active) return;
        let h = this.frames;
        if (i < h[0]) {
          switch (c) {
            case 0:
              r.mix = r.data.mix, r.softness = r.data.softness, r.bendDirection = r.data.bendDirection, r.compress = r.data.compress, r.stretch = r.data.stretch;
              return;
            case 1:
              r.mix += (r.data.mix - r.mix) * a, r.softness += (r.data.softness - r.softness) * a, r.bendDirection = r.data.bendDirection, r.compress = r.data.compress, r.stretch = r.data.stretch;
          }
          return;
        }
        let l = 0, o = 0, d = mt.search(h, i, 6), u = this.curves[d / 6];
        switch (u) {
          case 0:
            let m = h[d];
            l = h[d + 1], o = h[d + 2];
            let f = (i - m) / (h[d + 6] - m);
            l += (h[d + 6 + 1] - l) * f, o += (h[d + 6 + 2] - o) * f;
            break;
          case 1:
            l = h[d + 1], o = h[d + 2];
            break;
          default:
            l = this.getBezierValue(i, d, 1, u - 2), o = this.getBezierValue(i, d, 2, u + 18 - 2);
        }
        c == 0 ? (r.mix = r.data.mix + (l - r.data.mix) * a, r.softness = r.data.softness + (o - r.data.softness) * a, n == 1 ? (r.bendDirection = r.data.bendDirection, r.compress = r.data.compress, r.stretch = r.data.stretch) : (r.bendDirection = h[d + 3], r.compress = h[d + 4] != 0, r.stretch = h[d + 5] != 0)) : (r.mix += (l - r.mix) * a, r.softness += (o - r.softness) * a, n == 0 && (r.bendDirection = h[d + 3], r.compress = h[d + 4] != 0, r.stretch = h[d + 5] != 0));
      }
    }, ti = class extends Xt {
      constructor(t, e, i) {
        super(t, e, [ht.transformConstraint + "|" + i]);
        this.transformConstraintIndex = 0, this.transformConstraintIndex = i;
      }
      getFrameEntries() {
        return 7;
      }
      setFrame(t, e, i, s, a, c, n, r) {
        let h = this.frames;
        t *= 7, h[t] = e, h[t + 1] = i, h[t + 2] = s, h[t + 3] = a, h[t + 4] = c, h[t + 5] = n, h[t + 6] = r;
      }
      apply(t, e, i, s, a, c, n) {
        let r = t.transformConstraints[this.transformConstraintIndex];
        if (!r.active) return;
        let h = this.frames;
        if (i < h[0]) {
          let v = r.data;
          switch (c) {
            case 0:
              r.mixRotate = v.mixRotate, r.mixX = v.mixX, r.mixY = v.mixY, r.mixScaleX = v.mixScaleX, r.mixScaleY = v.mixScaleY, r.mixShearY = v.mixShearY;
              return;
            case 1:
              r.mixRotate += (v.mixRotate - r.mixRotate) * a, r.mixX += (v.mixX - r.mixX) * a, r.mixY += (v.mixY - r.mixY) * a, r.mixScaleX += (v.mixScaleX - r.mixScaleX) * a, r.mixScaleY += (v.mixScaleY - r.mixScaleY) * a, r.mixShearY += (v.mixShearY - r.mixShearY) * a;
          }
          return;
        }
        let l, o, d, u, m, f, x = mt.search(h, i, 7), w = this.curves[x / 7];
        switch (w) {
          case 0:
            let v = h[x];
            l = h[x + 1], o = h[x + 2], d = h[x + 3], u = h[x + 4], m = h[x + 5], f = h[x + 6];
            let g = (i - v) / (h[x + 7] - v);
            l += (h[x + 7 + 1] - l) * g, o += (h[x + 7 + 2] - o) * g, d += (h[x + 7 + 3] - d) * g, u += (h[x + 7 + 4] - u) * g, m += (h[x + 7 + 5] - m) * g, f += (h[x + 7 + 6] - f) * g;
            break;
          case 1:
            l = h[x + 1], o = h[x + 2], d = h[x + 3], u = h[x + 4], m = h[x + 5], f = h[x + 6];
            break;
          default:
            l = this.getBezierValue(i, x, 1, w - 2), o = this.getBezierValue(i, x, 2, w + 18 - 2), d = this.getBezierValue(i, x, 3, w + 18 * 2 - 2), u = this.getBezierValue(i, x, 4, w + 18 * 3 - 2), m = this.getBezierValue(i, x, 5, w + 18 * 4 - 2), f = this.getBezierValue(i, x, 6, w + 18 * 5 - 2);
        }
        if (c == 0) {
          let v = r.data;
          r.mixRotate = v.mixRotate + (l - v.mixRotate) * a, r.mixX = v.mixX + (o - v.mixX) * a, r.mixY = v.mixY + (d - v.mixY) * a, r.mixScaleX = v.mixScaleX + (u - v.mixScaleX) * a, r.mixScaleY = v.mixScaleY + (m - v.mixScaleY) * a, r.mixShearY = v.mixShearY + (f - v.mixShearY) * a;
        } else r.mixRotate += (l - r.mixRotate) * a, r.mixX += (o - r.mixX) * a, r.mixY += (d - r.mixY) * a, r.mixScaleX += (u - r.mixScaleX) * a, r.mixScaleY += (m - r.mixScaleY) * a, r.mixShearY += (f - r.mixShearY) * a;
      }
    }, ei = class extends Rt {
      constructor(t, e, i) {
        super(t, e, ht.pathConstraintPosition + "|" + i);
        this.pathConstraintIndex = 0, this.pathConstraintIndex = i;
      }
      apply(t, e, i, s, a, c, n) {
        let r = t.pathConstraints[this.pathConstraintIndex];
        if (!r.active) return;
        let h = this.frames;
        if (i < h[0]) {
          switch (c) {
            case 0:
              r.position = r.data.position;
              return;
            case 1:
              r.position += (r.data.position - r.position) * a;
          }
          return;
        }
        let l = this.getCurveValue(i);
        c == 0 ? r.position = r.data.position + (l - r.data.position) * a : r.position += (l - r.position) * a;
      }
    }, ii = class extends Rt {
      constructor(t, e, i) {
        super(t, e, ht.pathConstraintSpacing + "|" + i);
        this.pathConstraintIndex = 0, this.pathConstraintIndex = i;
      }
      apply(t, e, i, s, a, c, n) {
        let r = t.pathConstraints[this.pathConstraintIndex];
        if (!r.active) return;
        let h = this.frames;
        if (i < h[0]) {
          switch (c) {
            case 0:
              r.spacing = r.data.spacing;
              return;
            case 1:
              r.spacing += (r.data.spacing - r.spacing) * a;
          }
          return;
        }
        let l = this.getCurveValue(i);
        c == 0 ? r.spacing = r.data.spacing + (l - r.data.spacing) * a : r.spacing += (l - r.spacing) * a;
      }
    }, si = class extends Xt {
      constructor(t, e, i) {
        super(t, e, [ht.pathConstraintMix + "|" + i]);
        this.pathConstraintIndex = 0, this.pathConstraintIndex = i;
      }
      getFrameEntries() {
        return 4;
      }
      setFrame(t, e, i, s, a) {
        let c = this.frames;
        t <<= 2, c[t] = e, c[t + 1] = i, c[t + 2] = s, c[t + 3] = a;
      }
      apply(t, e, i, s, a, c, n) {
        let r = t.pathConstraints[this.pathConstraintIndex];
        if (!r.active) return;
        let h = this.frames;
        if (i < h[0]) {
          switch (c) {
            case 0:
              r.mixRotate = r.data.mixRotate, r.mixX = r.data.mixX, r.mixY = r.data.mixY;
              return;
            case 1:
              r.mixRotate += (r.data.mixRotate - r.mixRotate) * a, r.mixX += (r.data.mixX - r.mixX) * a, r.mixY += (r.data.mixY - r.mixY) * a;
          }
          return;
        }
        let l, o, d, u = mt.search(h, i, 4), m = this.curves[u >> 2];
        switch (m) {
          case 0:
            let f = h[u];
            l = h[u + 1], o = h[u + 2], d = h[u + 3];
            let x = (i - f) / (h[u + 4] - f);
            l += (h[u + 4 + 1] - l) * x, o += (h[u + 4 + 2] - o) * x, d += (h[u + 4 + 3] - d) * x;
            break;
          case 1:
            l = h[u + 1], o = h[u + 2], d = h[u + 3];
            break;
          default:
            l = this.getBezierValue(i, u, 1, m - 2), o = this.getBezierValue(i, u, 2, m + 18 - 2), d = this.getBezierValue(i, u, 3, m + 18 * 2 - 2);
        }
        if (c == 0) {
          let f = r.data;
          r.mixRotate = f.mixRotate + (l - f.mixRotate) * a, r.mixX = f.mixX + (o - f.mixX) * a, r.mixY = f.mixY + (d - f.mixY) * a;
        } else r.mixRotate += (l - r.mixRotate) * a, r.mixX += (o - r.mixX) * a, r.mixY += (d - r.mixY) * a;
      }
    }, ri = class {
      constructor(t) {
        this.data = null, this.tracks = new Array(), this.timeScale = 1, this.unkeyedState = 0, this.events = new Array(), this.listeners = new Array(), this.queue = new Wi(this), this.propertyIDs = new Pe(), this.animationsChanged = false, this.trackEntryPool = new ce(() => new zi()), this.data = t;
      }
      static emptyAnimation() {
        return hi || (hi = new be("<empty>", [], 0)), hi;
      }
      update(t) {
        t *= this.timeScale;
        let e = this.tracks;
        for (let i = 0, s = e.length; i < s; i++) {
          let a = e[i];
          if (!a) continue;
          a.animationLast = a.nextAnimationLast, a.trackLast = a.nextTrackLast;
          let c = t * a.timeScale;
          if (a.delay > 0) {
            if (a.delay -= c, a.delay > 0) continue;
            c = -a.delay, a.delay = 0;
          }
          let n = a.next;
          if (n) {
            let r = a.trackLast - n.delay;
            if (r >= 0) {
              for (n.delay = 0, n.trackTime += a.timeScale == 0 ? 0 : (r / a.timeScale + t) * n.timeScale, a.trackTime += c, this.setCurrent(i, n, true); n.mixingFrom; ) n.mixTime += t, n = n.mixingFrom;
              continue;
            }
          } else if (a.trackLast >= a.trackEnd && !a.mixingFrom) {
            e[i] = null, this.queue.end(a), this.clearNext(a);
            continue;
          }
          if (a.mixingFrom && this.updateMixingFrom(a, t)) {
            let r = a.mixingFrom;
            for (a.mixingFrom = null, r && (r.mixingTo = null); r; ) this.queue.end(r), r = r.mixingFrom;
          }
          a.trackTime += c;
        }
        this.queue.drain();
      }
      updateMixingFrom(t, e) {
        let i = t.mixingFrom;
        if (!i) return true;
        let s = this.updateMixingFrom(i, e);
        return i.animationLast = i.nextAnimationLast, i.trackLast = i.nextTrackLast, t.mixTime > 0 && t.mixTime >= t.mixDuration ? ((i.totalAlpha == 0 || t.mixDuration == 0) && (t.mixingFrom = i.mixingFrom, i.mixingFrom && (i.mixingFrom.mixingTo = t), t.interruptAlpha = i.interruptAlpha, this.queue.end(i)), s) : (i.trackTime += e * i.timeScale, t.mixTime += e, false);
      }
      apply(t) {
        if (!t) throw new Error("skeleton cannot be null.");
        this.animationsChanged && this._animationsChanged();
        let e = this.events, i = this.tracks, s = false;
        for (let d = 0, u = i.length; d < u; d++) {
          let m = i[d];
          if (!m || m.delay > 0) continue;
          s = true;
          let f = d == 0 ? ft.first : m.mixBlend, x = m.alpha;
          m.mixingFrom ? x *= this.applyMixingFrom(m, t, f) : m.trackTime >= m.trackEnd && !m.next && (x = 0);
          let w = m.animationLast, v = m.getAnimationTime(), g = v, p = e;
          m.reverse && (g = m.animation.duration - g, p = null);
          let b = m.animation.timelines, y = b.length;
          if (d == 0 && x == 1 || f == ft.add) for (let T = 0; T < y; T++) {
            var a = b[T];
            a instanceof Zt ? this.applyAttachmentTimeline(a, t, g, f, true) : a.apply(t, w, g, p, x, f, Dt.mixIn);
          }
          else {
            let T = m.timelineMode, A = m.timelinesRotation.length != y << 1;
            A && (m.timelinesRotation.length = y << 1);
            for (let I = 0; I < y; I++) {
              let k = b[I], X = T[I] == we ? f : ft.setup;
              k instanceof de ? this.applyRotateTimeline(k, t, g, x, X, m.timelinesRotation, I << 1, A) : k instanceof Zt ? this.applyAttachmentTimeline(k, t, g, f, true) : (k.apply(t, w, g, p, x, X, Dt.mixIn));
            }
          }
          this.queueEvents(m, v), e.length = 0, m.nextAnimationLast = v, m.nextTrackLast = m.trackTime;
        }
        for (var c = this.unkeyedState + li, n = t.slots, r = 0, h = t.slots.length; r < h; r++) {
          var l = n[r];
          if (l.attachmentState == c) {
            var o = l.data.attachmentName;
            l.setAttachment(o ? t.getAttachment(l.data.index, o) : null);
          }
        }
        return this.unkeyedState += 2, this.queue.drain(), s;
      }
      applyMixingFrom(t, e, i) {
        let s = t.mixingFrom;
        s.mixingFrom && this.applyMixingFrom(s, e, i);
        let a = 0;
        t.mixDuration == 0 ? (a = 1, i == ft.first && (i = ft.setup)) : (a = t.mixTime / t.mixDuration, a > 1 && (a = 1), i != ft.first && (i = s.mixBlend));
        let c = a < s.attachmentThreshold, n = a < s.drawOrderThreshold, r = s.animation.timelines, h = r.length, l = s.alpha * t.interruptAlpha, o = l * (1 - a), d = s.animationLast, u = s.getAnimationTime(), m = u, f = null;
        if (s.reverse ? m = s.animation.duration - m : a < s.eventThreshold && (f = this.events), i == ft.add) for (let x = 0; x < h; x++) r[x].apply(e, d, m, f, o, i, Dt.mixOut);
        else {
          let x = s.timelineMode, w = s.timelineHoldMix, v = s.timelinesRotation.length != h << 1;
          v && (s.timelinesRotation.length = h << 1), s.totalAlpha = 0;
          for (let g = 0; g < h; g++) {
            let p = r[g], b = Dt.mixOut, y, T = 0;
            switch (x[g]) {
              case we:
                if (!n && p instanceof Jt) continue;
                y = i, T = o;
                break;
              case ai:
                y = ft.setup, T = o;
                break;
              case ni:
                y = i, T = l;
                break;
              case ve:
                y = ft.setup, T = l;
                break;
              default:
                y = ft.setup;
                let A = w[g];
                T = l * Math.max(0, 1 - A.mixTime / A.mixDuration);
                break;
            }
            s.totalAlpha += T, p instanceof de ? this.applyRotateTimeline(p, e, m, T, y, s.timelinesRotation, g << 1, v) : p instanceof Zt ? this.applyAttachmentTimeline(p, e, m, y, c) : (n && p instanceof Jt && y == ft.setup && (b = Dt.mixIn), p.apply(e, d, m, f, T, y, b));
          }
        }
        return t.mixDuration > 0 && this.queueEvents(s, u), this.events.length = 0, s.nextAnimationLast = u, s.nextTrackLast = s.trackTime, a;
      }
      applyAttachmentTimeline(t, e, i, s, a) {
        var c = e.slots[t.slotIndex];
        !c.bone.active || (i < t.frames[0] ? (s == ft.setup || s == ft.first) && this.setAttachment(e, c, c.data.attachmentName, a) : this.setAttachment(e, c, t.attachmentNames[mt.search1(t.frames, i)], a), c.attachmentState <= this.unkeyedState && (c.attachmentState = this.unkeyedState + li));
      }
      setAttachment(t, e, i, s) {
        e.setAttachment(i ? t.getAttachment(e.data.index, i) : null), s && (e.attachmentState = this.unkeyedState + qi);
      }
      applyRotateTimeline(t, e, i, s, a, c, n, r) {
        if (r && (c[n] = 0), s == 1) {
          t.apply(e, 0, i, null, 1, a, Dt.mixIn);
          return;
        }
        let h = e.bones[t.boneIndex];
        if (!h.active) return;
        let l = t.frames, o = 0, d = 0;
        if (i < l[0]) switch (a) {
          case ft.setup:
            h.rotation = h.data.rotation;
          default:
            return;
          case ft.first:
            o = h.rotation, d = h.data.rotation;
        }
        else o = a == ft.setup ? h.data.rotation : h.rotation, d = h.data.rotation + t.getCurveValue(i);
        let u = 0, m = d - o;
        if (m -= (16384 - (16384.499999999996 - m / 360 | 0)) * 360, m == 0) u = c[n];
        else {
          let f = 0, x = 0;
          r ? (f = 0, x = m) : (f = c[n], x = c[n + 1]);
          let w = m > 0, v = f >= 0;
          F.signum(x) != F.signum(m) && Math.abs(x) <= 90 && (Math.abs(f) > 180 && (f += 360 * F.signum(f)), v = w), u = m + f - f % 360, v != w && (u += 360 * F.signum(f)), c[n] = u;
        }
        c[n + 1] = m, h.rotation = o + u * s;
      }
      queueEvents(t, e) {
        let i = t.animationStart, s = t.animationEnd, a = s - i, c = t.trackLast % a, n = this.events, r = 0, h = n.length;
        for (; r < h; r++) {
          let o = n[r];
          if (o.time < c) break;
          o.time > s || this.queue.event(t, o);
        }
        let l = false;
        for (t.loop ? l = a == 0 || c > t.trackTime % a : l = e >= s && t.animationLast < s, l && this.queue.complete(t); r < h; r++) {
          let o = n[r];
          o.time < i || this.queue.event(t, o);
        }
      }
      clearTracks() {
        let t = this.queue.drainDisabled;
        this.queue.drainDisabled = true;
        for (let e = 0, i = this.tracks.length; e < i; e++) this.clearTrack(e);
        this.tracks.length = 0, this.queue.drainDisabled = t, this.queue.drain();
      }
      clearTrack(t) {
        if (t >= this.tracks.length) return;
        let e = this.tracks[t];
        if (!e) return;
        this.queue.end(e), this.clearNext(e);
        let i = e;
        for (; ; ) {
          let s = i.mixingFrom;
          if (!s) break;
          this.queue.end(s), i.mixingFrom = null, i.mixingTo = null, i = s;
        }
        this.tracks[e.trackIndex] = null, this.queue.drain();
      }
      setCurrent(t, e, i) {
        let s = this.expandToIndex(t);
        this.tracks[t] = e, e.previous = null, s && (i && this.queue.interrupt(s), e.mixingFrom = s, s.mixingTo = e, e.mixTime = 0, s.mixingFrom && s.mixDuration > 0 && (e.interruptAlpha *= Math.min(1, s.mixTime / s.mixDuration)), s.timelinesRotation.length = 0), this.queue.start(e);
      }
      setAnimation(t, e, i = false) {
        let s = this.data.skeletonData.findAnimation(e);
        if (!s) throw new Error("Animation not found: " + e);
        return this.setAnimationWith(t, s, i);
      }
      setAnimationWith(t, e, i = false) {
        if (!e) throw new Error("animation cannot be null.");
        let s = true, a = this.expandToIndex(t);
        a && (a.nextTrackLast == -1 ? (this.tracks[t] = a.mixingFrom, this.queue.interrupt(a), this.queue.end(a), this.clearNext(a), a = a.mixingFrom, s = false) : this.clearNext(a));
        let c = this.trackEntry(t, e, i, a);
        return this.setCurrent(t, c, s), this.queue.drain(), c;
      }
      addAnimation(t, e, i = false, s = 0) {
        let a = this.data.skeletonData.findAnimation(e);
        if (!a) throw new Error("Animation not found: " + e);
        return this.addAnimationWith(t, a, i, s);
      }
      addAnimationWith(t, e, i = false, s = 0) {
        if (!e) throw new Error("animation cannot be null.");
        let a = this.expandToIndex(t);
        if (a) for (; a.next; ) a = a.next;
        let c = this.trackEntry(t, e, i, a);
        return a ? (a.next = c, c.previous = a, s <= 0 && (s += a.getTrackComplete() - c.mixDuration)) : (this.setCurrent(t, c, true), this.queue.drain()), c.delay = s, c;
      }
      setEmptyAnimation(t, e = 0) {
        let i = this.setAnimationWith(t, ri.emptyAnimation(), false);
        return i.mixDuration = e, i.trackEnd = e, i;
      }
      addEmptyAnimation(t, e = 0, i = 0) {
        let s = this.addAnimationWith(t, ri.emptyAnimation(), false, i);
        return i <= 0 && (s.delay += s.mixDuration - e), s.mixDuration = e, s.trackEnd = e, s;
      }
      setEmptyAnimations(t = 0) {
        let e = this.queue.drainDisabled;
        this.queue.drainDisabled = true;
        for (let i = 0, s = this.tracks.length; i < s; i++) {
          let a = this.tracks[i];
          a && this.setEmptyAnimation(a.trackIndex, t);
        }
        this.queue.drainDisabled = e, this.queue.drain();
      }
      expandToIndex(t) {
        return t < this.tracks.length ? this.tracks[t] : (O.ensureArrayCapacity(this.tracks, t + 1, null), this.tracks.length = t + 1, null);
      }
      trackEntry(t, e, i, s) {
        let a = this.trackEntryPool.obtain();
        return a.reset(), a.trackIndex = t, a.animation = e, a.loop = i, a.holdPrevious = false, a.eventThreshold = 0, a.attachmentThreshold = 0, a.drawOrderThreshold = 0, a.animationStart = 0, a.animationEnd = e.duration, a.animationLast = -1, a.nextAnimationLast = -1, a.delay = 0, a.trackTime = 0, a.trackLast = -1, a.nextTrackLast = -1, a.trackEnd = Number.MAX_VALUE, a.timeScale = 1, a.alpha = 1, a.interruptAlpha = 1, a.mixTime = 0, a.mixDuration = s ? this.data.getMix(s.animation, e) : 0, a.mixBlend = ft.replace, a;
      }
      clearNext(t) {
        let e = t.next;
        for (; e; ) this.queue.dispose(e), e = e.next;
        t.next = null;
      }
      _animationsChanged() {
        this.animationsChanged = false, this.propertyIDs.clear();
        let t = this.tracks;
        for (let e = 0, i = t.length; e < i; e++) {
          let s = t[e];
          if (!!s) {
            for (; s.mixingFrom; ) s = s.mixingFrom;
            do
              (!s.mixingTo || s.mixBlend != ft.add) && this.computeHold(s), s = s.mixingTo;
            while (s);
          }
        }
      }
      computeHold(t) {
        let e = t.mixingTo, i = t.animation.timelines, s = t.animation.timelines.length, a = t.timelineMode;
        a.length = s;
        let c = t.timelineHoldMix;
        c.length = 0;
        let n = this.propertyIDs;
        if (e && e.holdPrevious) {
          for (let r = 0; r < s; r++) a[r] = n.addAll(i[r].getPropertyIds()) ? ve : ni;
          return;
        }
        t: for (let r = 0; r < s; r++) {
          let h = i[r], l = h.getPropertyIds();
          if (!n.addAll(l)) a[r] = we;
          else if (!e || h instanceof Zt || h instanceof Jt || h instanceof ue || !e.animation.hasTimeline(l)) a[r] = ai;
          else {
            for (let o = e.mixingTo; o; o = o.mixingTo) if (!o.animation.hasTimeline(l)) {
              if (t.mixDuration > 0) {
                a[r] = _i, c[r] = o;
                continue t;
              }
              break;
            }
            a[r] = ve;
          }
        }
      }
      getCurrent(t) {
        return t >= this.tracks.length ? null : this.tracks[t];
      }
      addListener(t) {
        if (!t) throw new Error("listener cannot be null.");
        this.listeners.push(t);
      }
      removeListener(t) {
        let e = this.listeners.indexOf(t);
        e >= 0 && this.listeners.splice(e, 1);
      }
      clearListeners() {
        this.listeners.length = 0;
      }
      clearListenerNotifications() {
        this.queue.clear();
      }
    }, zi = class {
      constructor() {
        this.animation = null, this.previous = null, this.next = null, this.mixingFrom = null, this.mixingTo = null, this.listener = null, this.trackIndex = 0, this.loop = false, this.holdPrevious = false, this.reverse = false, this.eventThreshold = 0, this.attachmentThreshold = 0, this.drawOrderThreshold = 0, this.animationStart = 0, this.animationEnd = 0, this.animationLast = 0, this.nextAnimationLast = 0, this.delay = 0, this.trackTime = 0, this.trackLast = 0, this.nextTrackLast = 0, this.trackEnd = 0, this.timeScale = 0, this.alpha = 0, this.mixTime = 0, this.mixDuration = 0, this.interruptAlpha = 0, this.totalAlpha = 0, this.mixBlend = ft.replace, this.timelineMode = new Array(), this.timelineHoldMix = new Array(), this.timelinesRotation = new Array();
      }
      reset() {
        this.next = null, this.previous = null, this.mixingFrom = null, this.mixingTo = null, this.animation = null, this.listener = null, this.timelineMode.length = 0, this.timelineHoldMix.length = 0, this.timelinesRotation.length = 0;
      }
      getAnimationTime() {
        if (this.loop) {
          let t = this.animationEnd - this.animationStart;
          return t == 0 ? this.animationStart : this.trackTime % t + this.animationStart;
        }
        return Math.min(this.trackTime + this.animationStart, this.animationEnd);
      }
      setAnimationLast(t) {
        this.animationLast = t, this.nextAnimationLast = t;
      }
      isComplete() {
        return this.trackTime >= this.animationEnd - this.animationStart;
      }
      resetRotationDirections() {
        this.timelinesRotation.length = 0;
      }
      getTrackComplete() {
        let t = this.animationEnd - this.animationStart;
        if (t != 0) {
          if (this.loop) return t * (1 + (this.trackTime / t | 0));
          if (this.trackTime < t) return t;
        }
        return this.trackTime;
      }
    }, Wi = class {
      constructor(t) {
        this.objects = [], this.drainDisabled = false, this.animState = null, this.animState = t;
      }
      start(t) {
        this.objects.push(St.start), this.objects.push(t), this.animState.animationsChanged = true;
      }
      interrupt(t) {
        this.objects.push(St.interrupt), this.objects.push(t);
      }
      end(t) {
        this.objects.push(St.end), this.objects.push(t), this.animState.animationsChanged = true;
      }
      dispose(t) {
        this.objects.push(St.dispose), this.objects.push(t);
      }
      complete(t) {
        this.objects.push(St.complete), this.objects.push(t);
      }
      event(t, e) {
        this.objects.push(St.event), this.objects.push(t), this.objects.push(e);
      }
      drain() {
        if (this.drainDisabled) return;
        this.drainDisabled = true;
        let t = this.objects, e = this.animState.listeners;
        for (let i = 0; i < t.length; i += 2) {
          let s = t[i], a = t[i + 1];
          switch (s) {
            case St.start:
              a.listener && a.listener.start && a.listener.start(a);
              for (let n = 0; n < e.length; n++) e[n].start && e[n].start(a);
              break;
            case St.interrupt:
              a.listener && a.listener.interrupt && a.listener.interrupt(a);
              for (let n = 0; n < e.length; n++) e[n].interrupt && e[n].interrupt(a);
              break;
            case St.end:
              a.listener && a.listener.end && a.listener.end(a);
              for (let n = 0; n < e.length; n++) e[n].end && e[n].end(a);
            case St.dispose:
              a.listener && a.listener.dispose && a.listener.dispose(a);
              for (let n = 0; n < e.length; n++) e[n].dispose && e[n].dispose(a);
              this.animState.trackEntryPool.free(a);
              break;
            case St.complete:
              a.listener && a.listener.complete && a.listener.complete(a);
              for (let n = 0; n < e.length; n++) e[n].complete && e[n].complete(a);
              break;
            case St.event:
              let c = t[i++ + 2];
              a.listener && a.listener.event && a.listener.event(a, c);
              for (let n = 0; n < e.length; n++) e[n].event && e[n].event(a, c);
              break;
          }
        }
        this.clear(), this.drainDisabled = false;
      }
      clear() {
        this.objects.length = 0;
      }
    }, St;
    (function(t) {
      t[t.start = 0] = "start", t[t.interrupt = 1] = "interrupt", t[t.end = 2] = "end", t[t.dispose = 3] = "dispose", t[t.complete = 4] = "complete", t[t.event = 5] = "event";
    })(St || (St = {}));
    var Ts = class {
      start(t) {
      }
      interrupt(t) {
      }
      end(t) {
      }
      dispose(t) {
      }
      complete(t) {
      }
      event(t, e) {
      }
    }, we = 0, ai = 1, ni = 2, ve = 3, _i = 4, li = 1, qi = 2, hi = null, Ms = class {
      constructor(t) {
        if (this.skeletonData = null, this.animationToMixTime = {}, this.defaultMix = 0, !t) throw new Error("skeletonData cannot be null.");
        this.skeletonData = t;
      }
      setMix(t, e, i) {
        let s = this.skeletonData.findAnimation(t);
        if (!s) throw new Error("Animation not found: " + t);
        let a = this.skeletonData.findAnimation(e);
        if (!a) throw new Error("Animation not found: " + e);
        this.setMixWith(s, a, i);
      }
      setMixWith(t, e, i) {
        if (!t) throw new Error("from cannot be null.");
        if (!e) throw new Error("to cannot be null.");
        let s = t.name + "." + e.name;
        this.animationToMixTime[s] = i;
      }
      getMix(t, e) {
        let i = t.name + "." + e.name, s = this.animationToMixTime[i];
        return s === void 0 ? this.defaultMix : s;
      }
    }, ye = class extends Pt {
      constructor(t) {
        super(t);
        this.color = new D(1, 1, 1, 1);
      }
      copy() {
        let t = new ye(this.name);
        return this.copyTo(t), t.color.setFromColor(this.color), t;
      }
    }, fe = class extends Pt {
      constructor(t) {
        super(t);
        this.endSlot = null, this.color = new D(0.2275, 0.2275, 0.8078, 1);
      }
      copy() {
        let t = new fe(this.name);
        return this.copyTo(t), t.endSlot = this.endSlot, t.color.setFromColor(this.color), t;
      }
    }, oi = class {
      constructor(t) {
        this._image = t;
      }
      getImage() {
        return this._image;
      }
    }, Mt;
    (function(t) {
      t[t.Nearest = 9728] = "Nearest", t[t.Linear = 9729] = "Linear", t[t.MipMap = 9987] = "MipMap", t[t.MipMapNearestNearest = 9984] = "MipMapNearestNearest", t[t.MipMapLinearNearest = 9985] = "MipMapLinearNearest", t[t.MipMapNearestLinear = 9986] = "MipMapNearestLinear", t[t.MipMapLinearLinear = 9987] = "MipMapLinearLinear";
    })(Mt || (Mt = {}));
    var Kt;
    (function(t) {
      t[t.MirroredRepeat = 33648] = "MirroredRepeat", t[t.ClampToEdge = 33071] = "ClampToEdge", t[t.Repeat = 10497] = "Repeat";
    })(Kt || (Kt = {}));
    var Gi = class {
      constructor() {
        this.u = 0, this.v = 0, this.u2 = 0, this.v2 = 0, this.width = 0, this.height = 0, this.degrees = 0, this.offsetX = 0, this.offsetY = 0, this.originalWidth = 0, this.originalHeight = 0;
      }
    }, Ys = class extends oi {
      setFilters(t, e) {
      }
      setWraps(t, e) {
      }
      dispose() {
      }
    }, ji = class {
      constructor(t) {
        this.pages = new Array(), this.regions = new Array();
        let e = new Is(t), i = new Array(4), s = null, a = null, c = {};
        c.size = () => {
          s.width = parseInt(i[1]), s.height = parseInt(i[2]);
        }, c.format = () => {
        }, c.filter = () => {
          s.minFilter = O.enumValue(Mt, i[1]), s.magFilter = O.enumValue(Mt, i[2]);
        }, c.repeat = () => {
          i[1].indexOf("x") != -1 && (s.uWrap = Kt.Repeat), i[1].indexOf("y") != -1 && (s.vWrap = Kt.Repeat);
        }, c.pma = () => {
          s.pma = i[1] == "true";
        };
        var n = {};
        n.xy = () => {
          a.x = parseInt(i[1]), a.y = parseInt(i[2]);
        }, n.size = () => {
          a.width = parseInt(i[1]), a.height = parseInt(i[2]);
        }, n.bounds = () => {
          a.x = parseInt(i[1]), a.y = parseInt(i[2]), a.width = parseInt(i[3]), a.height = parseInt(i[4]);
        }, n.offset = () => {
          a.offsetX = parseInt(i[1]), a.offsetY = parseInt(i[2]);
        }, n.orig = () => {
          a.originalWidth = parseInt(i[1]), a.originalHeight = parseInt(i[2]);
        }, n.offsets = () => {
          a.offsetX = parseInt(i[1]), a.offsetY = parseInt(i[2]), a.originalWidth = parseInt(i[3]), a.originalHeight = parseInt(i[4]);
        }, n.rotate = () => {
          let o = i[1];
          o == "true" ? a.degrees = 90 : o != "false" && (a.degrees = parseInt(o));
        }, n.index = () => {
          a.index = parseInt(i[1]);
        };
        let r = e.readLine();
        for (; r && r.trim().length == 0; ) r = e.readLine();
        for (; !(!r || r.trim().length == 0 || e.readEntry(i, r) == 0); ) r = e.readLine();
        let h = null, l = null;
        for (; r !== null; ) if (r.trim().length == 0) s = null, r = e.readLine();
        else if (s) {
          for (a = new ci(), a.page = s, a.name = r; ; ) {
            let o = e.readEntry(i, r = e.readLine());
            if (o == 0) break;
            let d = n[i[0]];
            if (d) d();
            else {
              h || (h = [], l = []), h.push(i[0]);
              let u = [];
              for (let m = 0; m < o; m++) u.push(parseInt(i[m + 1]));
              l.push(u);
            }
          }
          a.originalWidth == 0 && a.originalHeight == 0 && (a.originalWidth = a.width, a.originalHeight = a.height), h && h.length > 0 && (a.names = h, a.values = l, h = null, l = null), a.u = a.x / s.width, a.v = a.y / s.height, a.degrees == 90 ? (a.u2 = (a.x + a.height) / s.width, a.v2 = (a.y + a.width) / s.height) : (a.u2 = (a.x + a.width) / s.width, a.v2 = (a.y + a.height) / s.height), this.regions.push(a);
        } else {
          for (s = new Hi(), s.name = r.trim(); e.readEntry(i, r = e.readLine()) != 0; ) {
            let o = c[i[0]];
            o && o();
          }
          this.pages.push(s);
        }
      }
      findRegion(t) {
        for (let e = 0; e < this.regions.length; e++) if (this.regions[e].name == t) return this.regions[e];
        return null;
      }
      setTextures(t, e = "") {
        for (let i of this.pages) i.setTexture(t.get(e + i.name));
      }
      dispose() {
        for (let t = 0; t < this.pages.length; t++) this.pages[t].texture.dispose();
      }
    }, Is = class {
      constructor(t) {
        this.lines = null, this.index = 0, this.lines = t.split(/\r\n|\r|\n/);
      }
      readLine() {
        return this.index >= this.lines.length ? null : this.lines[this.index++];
      }
      readEntry(t, e) {
        if (!e || (e = e.trim(), e.length == 0)) return 0;
        let i = e.indexOf(":");
        if (i == -1) return 0;
        t[0] = e.substr(0, i).trim();
        for (let s = 1, a = i + 1; ; s++) {
          let c = e.indexOf(",", a);
          if (c == -1) return t[s] = e.substr(a).trim(), s;
          if (t[s] = e.substr(a, c - a).trim(), a = c + 1, s == 4) return 4;
        }
      }
    }, Hi = class {
      constructor() {
        this.name = null, this.minFilter = Mt.Nearest, this.magFilter = Mt.Nearest, this.uWrap = Kt.ClampToEdge, this.vWrap = Kt.ClampToEdge, this.texture = null, this.width = 0, this.height = 0, this.pma = false;
      }
      setTexture(t) {
        this.texture = t, t.setFilters(this.minFilter, this.magFilter), t.setWraps(this.uWrap, this.vWrap);
      }
    }, ci = class extends Gi {
      constructor() {
        super(...arguments);
        this.page = null, this.name = null, this.x = 0, this.y = 0, this.offsetX = 0, this.offsetY = 0, this.originalWidth = 0, this.originalHeight = 0, this.index = 0, this.degrees = 0, this.names = null, this.values = null;
      }
    }, _t = class extends Pt {
      constructor(t) {
        super(t);
        this.region = null, this.path = null, this.regionUVs = null, this.uvs = null, this.triangles = null, this.color = new D(1, 1, 1, 1), this.width = 0, this.height = 0, this.hullLength = 0, this.edges = null, this.parentMesh = null, this.tempColor = new D(0, 0, 0, 0);
      }
      updateUVs() {
        let t = this.regionUVs;
        (!this.uvs || this.uvs.length != t.length) && (this.uvs = O.newFloatArray(t.length));
        let e = this.uvs, i = this.uvs.length, s = this.region.u, a = this.region.v, c = 0, n = 0;
        if (this.region instanceof ci) {
          let r = this.region, h = r.page.texture.getImage(), l = h.width, o = h.height;
          switch (r.degrees) {
            case 90:
              s -= (r.originalHeight - r.offsetY - r.height) / l, a -= (r.originalWidth - r.offsetX - r.width) / o, c = r.originalHeight / l, n = r.originalWidth / o;
              for (let d = 0; d < i; d += 2) e[d] = s + t[d + 1] * c, e[d + 1] = a + (1 - t[d]) * n;
              return;
            case 180:
              s -= (r.originalWidth - r.offsetX - r.width) / l, a -= r.offsetY / o, c = r.originalWidth / l, n = r.originalHeight / o;
              for (let d = 0; d < i; d += 2) e[d] = s + (1 - t[d]) * c, e[d + 1] = a + (1 - t[d + 1]) * n;
              return;
            case 270:
              s -= r.offsetY / l, a -= r.offsetX / o, c = r.originalHeight / l, n = r.originalWidth / o;
              for (let d = 0; d < i; d += 2) e[d] = s + (1 - t[d + 1]) * c, e[d + 1] = a + t[d] * n;
              return;
          }
          s -= r.offsetX / l, a -= (r.originalHeight - r.offsetY - r.height) / o, c = r.originalWidth / l, n = r.originalHeight / o;
        } else this.region ? (c = this.region.u2 - s, n = this.region.v2 - a) : (s = a = 0, c = n = 1);
        for (let r = 0; r < i; r += 2) e[r] = s + t[r] * c, e[r + 1] = a + t[r + 1] * n;
      }
      getParentMesh() {
        return this.parentMesh;
      }
      setParentMesh(t) {
        this.parentMesh = t, t && (this.bones = t.bones, this.vertices = t.vertices, this.worldVerticesLength = t.worldVerticesLength, this.regionUVs = t.regionUVs, this.triangles = t.triangles, this.hullLength = t.hullLength, this.worldVerticesLength = t.worldVerticesLength);
      }
      copy() {
        if (this.parentMesh) return this.newLinkedMesh();
        let t = new _t(this.name);
        return t.region = this.region, t.path = this.path, t.color.setFromColor(this.color), this.copyTo(t), t.regionUVs = new Array(this.regionUVs.length), O.arrayCopy(this.regionUVs, 0, t.regionUVs, 0, this.regionUVs.length), t.uvs = new Array(this.uvs.length), O.arrayCopy(this.uvs, 0, t.uvs, 0, this.uvs.length), t.triangles = new Array(this.triangles.length), O.arrayCopy(this.triangles, 0, t.triangles, 0, this.triangles.length), t.hullLength = this.hullLength, this.edges && (t.edges = new Array(this.edges.length), O.arrayCopy(this.edges, 0, t.edges, 0, this.edges.length)), t.width = this.width, t.height = this.height, t;
      }
      newLinkedMesh() {
        let t = new _t(this.name);
        return t.region = this.region, t.path = this.path, t.color.setFromColor(this.color), t.deformAttachment = this.deformAttachment, t.setParentMesh(this.parentMesh ? this.parentMesh : this), t.updateUVs(), t;
      }
    }, Qt = class extends Pt {
      constructor(t) {
        super(t);
        this.lengths = null, this.closed = false, this.constantSpeed = false, this.color = new D(1, 1, 1, 1);
      }
      copy() {
        let t = new Qt(this.name);
        return this.copyTo(t), t.lengths = new Array(this.lengths.length), O.arrayCopy(this.lengths, 0, t.lengths, 0, this.lengths.length), t.closed = closed, t.constantSpeed = this.constantSpeed, t.color.setFromColor(this.color), t;
      }
    }, di = class extends Pt {
      constructor(t) {
        super(t);
        this.x = 0, this.y = 0, this.rotation = 0, this.color = new D(0.38, 0.94, 0, 1);
      }
      computeWorldPosition(t, e) {
        return e.x = this.x * t.a + this.y * t.b + t.worldX, e.y = this.x * t.c + this.y * t.d + t.worldY, e;
      }
      computeWorldRotation(t) {
        let e = F.cosDeg(this.rotation), i = F.sinDeg(this.rotation), s = e * t.a + i * t.b, a = e * t.c + i * t.d;
        return Math.atan2(a, s) * F.radDeg;
      }
      copy() {
        let t = new di(this.name);
        return t.x = this.x, t.y = this.y, t.rotation = this.rotation, t.color.setFromColor(this.color), t;
      }
    }, Zi = class extends Oe {
      constructor(t) {
        super(t);
        this.x = 0, this.y = 0, this.scaleX = 1, this.scaleY = 1, this.rotation = 0, this.width = 0, this.height = 0, this.color = new D(1, 1, 1, 1), this.path = null, this.rendererObject = null, this.region = null, this.offset = O.newFloatArray(8), this.uvs = O.newFloatArray(8), this.tempColor = new D(1, 1, 1, 1);
      }
      updateOffset() {
        this.region; let e = this.width / this.region.originalWidth * this.scaleX, i = this.height / this.region.originalHeight * this.scaleY, s = -this.width / 2 * this.scaleX + this.region.offsetX * e, a = -this.height / 2 * this.scaleY + this.region.offsetY * i, c = s + this.region.width * e, n = a + this.region.height * i, r = this.rotation * Math.PI / 180, h = Math.cos(r), l = Math.sin(r), o = this.x, d = this.y, u = s * h + o, m = s * l, f = a * h + d, x = a * l, w = c * h + o, v = c * l, g = n * h + d, p = n * l, b = this.offset;
        b[0] = u - x, b[1] = f + m, b[2] = u - p, b[3] = g + m, b[4] = w - p, b[5] = g + v, b[6] = w - x, b[7] = f + v;
      }
      setRegion(t) {
        this.region = t;
        let e = this.uvs;
        t.degrees == 90 ? (e[2] = t.u, e[3] = t.v2, e[4] = t.u, e[5] = t.v, e[6] = t.u2, e[7] = t.v, e[0] = t.u2, e[1] = t.v2) : (e[0] = t.u, e[1] = t.v2, e[2] = t.u, e[3] = t.v, e[4] = t.u2, e[5] = t.v, e[6] = t.u2, e[7] = t.v2);
      }
      computeWorldVertices(t, e, i, s) {
        let a = this.offset, c = t.worldX, n = t.worldY, r = t.a, h = t.b, l = t.c, o = t.d, d = 0, u = 0;
        d = a[0], u = a[1], e[i] = d * r + u * h + c, e[i + 1] = d * l + u * o + n, i += s, d = a[2], u = a[3], e[i] = d * r + u * h + c, e[i + 1] = d * l + u * o + n, i += s, d = a[4], u = a[5], e[i] = d * r + u * h + c, e[i + 1] = d * l + u * o + n, i += s, d = a[6], u = a[7], e[i] = d * r + u * h + c, e[i + 1] = d * l + u * o + n;
      }
      copy() {
        let t = new Zi(this.name);
        return t.region = this.region, t.rendererObject = this.rendererObject, t.path = this.path, t.x = this.x, t.y = this.y, t.scaleX = this.scaleX, t.scaleY = this.scaleY, t.rotation = this.rotation, t.width = this.width, t.height = this.height, O.arrayCopy(this.uvs, 0, t.uvs, 0, 8), O.arrayCopy(this.offset, 0, t.offset, 0, 8), t.color.setFromColor(this.color), t;
      }
    }, at = Zi;
    at.X1 = 0, at.Y1 = 1, at.C1R = 2, at.C1G = 3, at.C1B = 4, at.C1A = 5, at.U1 = 6, at.V1 = 7, at.X2 = 8, at.Y2 = 9, at.C2R = 10, at.C2G = 11, at.C2B = 12, at.C2A = 13, at.U2 = 14, at.V2 = 15, at.X3 = 16, at.Y3 = 17, at.C3R = 18, at.C3G = 19, at.C3B = 20, at.C3A = 21, at.U3 = 22, at.V3 = 23, at.X4 = 24, at.Y4 = 25, at.C4R = 26, at.C4G = 27, at.C4B = 28, at.C4A = 29, at.U4 = 30, at.V4 = 31;
    var ks = class {
      constructor(t) {
        this.atlas = null, this.atlas = t;
      }
      newRegionAttachment(t, e, i) {
        let s = this.atlas.findRegion(i);
        if (!s) throw new Error("Region not found in atlas: " + i + " (region attachment: " + e + ")");
        s.renderObject = s;
        let a = new at(e);
        return a.setRegion(s), a;
      }
      newMeshAttachment(t, e, i) {
        let s = this.atlas.findRegion(i);
        if (!s) throw new Error("Region not found in atlas: " + i + " (mesh attachment: " + e + ")");
        s.renderObject = s;
        let a = new _t(e);
        return a.region = s, a;
      }
      newBoundingBoxAttachment(t, e) {
        return new ye(e);
      }
      newPathAttachment(t, e) {
        return new Qt(e);
      }
      newPointAttachment(t, e) {
        return new di(e);
      }
      newClippingAttachment(t, e) {
        return new fe(e);
      }
    }, ui = class {
      constructor(t, e, i) {
        if (this.index = 0, this.name = null, this.parent = null, this.length = 0, this.x = 0, this.y = 0, this.rotation = 0, this.scaleX = 1, this.scaleY = 1, this.shearX = 0, this.shearY = 0, this.transformMode = Ct.Normal, this.skinRequired = false, this.color = new D(), t < 0) throw new Error("index must be >= 0.");
        if (!e) throw new Error("name cannot be null.");
        this.index = t, this.name = e, this.parent = i;
      }
    }, Ct;
    (function(t) {
      t[t.Normal = 0] = "Normal", t[t.OnlyTranslation = 1] = "OnlyTranslation", t[t.NoRotationOrReflection = 2] = "NoRotationOrReflection", t[t.NoScale = 3] = "NoScale", t[t.NoScaleOrReflection = 4] = "NoScaleOrReflection";
    })(Ct || (Ct = {}));
    var fi = class {
      constructor(t, e, i) {
        if (this.data = null, this.skeleton = null, this.parent = null, this.children = new Array(), this.x = 0, this.y = 0, this.rotation = 0, this.scaleX = 0, this.scaleY = 0, this.shearX = 0, this.shearY = 0, this.ax = 0, this.ay = 0, this.arotation = 0, this.ascaleX = 0, this.ascaleY = 0, this.ashearX = 0, this.ashearY = 0, this.a = 0, this.b = 0, this.c = 0, this.d = 0, this.worldY = 0, this.worldX = 0, this.sorted = false, this.active = false, !t) throw new Error("data cannot be null.");
        if (!e) throw new Error("skeleton cannot be null.");
        this.data = t, this.skeleton = e, this.parent = i, this.setToSetupPose();
      }
      isActive() {
        return this.active;
      }
      update() {
        this.updateWorldTransformWith(this.ax, this.ay, this.arotation, this.ascaleX, this.ascaleY, this.ashearX, this.ashearY);
      }
      updateWorldTransform() {
        this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
      }
      updateWorldTransformWith(t, e, i, s, a, c, n) {
        this.ax = t, this.ay = e, this.arotation = i, this.ascaleX = s, this.ascaleY = a, this.ashearX = c, this.ashearY = n;
        let r = this.parent;
        if (!r) {
          let u = this.skeleton, m = i + 90 + n, f = u.scaleX, x = u.scaleY;
          this.a = F.cosDeg(i + c) * s * f, this.b = F.cosDeg(m) * a * f, this.c = F.sinDeg(i + c) * s * x, this.d = F.sinDeg(m) * a * x, this.worldX = t * f + u.x, this.worldY = e * x + u.y;
          return;
        }
        let h = r.a, l = r.b, o = r.c, d = r.d;
        switch (this.worldX = h * t + l * e + r.worldX, this.worldY = o * t + d * e + r.worldY, this.data.transformMode) {
          case Ct.Normal: {
            let u = i + 90 + n, m = F.cosDeg(i + c) * s, f = F.cosDeg(u) * a, x = F.sinDeg(i + c) * s, w = F.sinDeg(u) * a;
            this.a = h * m + l * x, this.b = h * f + l * w, this.c = o * m + d * x, this.d = o * f + d * w;
            return;
          }
          case Ct.OnlyTranslation: {
            let u = i + 90 + n;
            this.a = F.cosDeg(i + c) * s, this.b = F.cosDeg(u) * a, this.c = F.sinDeg(i + c) * s, this.d = F.sinDeg(u) * a;
            break;
          }
          case Ct.NoRotationOrReflection: {
            let u = h * h + o * o, m = 0;
            u > 1e-4 ? (u = Math.abs(h * d - l * o) / u, h /= this.skeleton.scaleX, o /= this.skeleton.scaleY, l = o * u, d = h * u, m = Math.atan2(o, h) * F.radDeg) : (h = 0, o = 0, m = 90 - Math.atan2(d, l) * F.radDeg);
            let f = i + c - m, x = i + n - m + 90, w = F.cosDeg(f) * s, v = F.cosDeg(x) * a, g = F.sinDeg(f) * s, p = F.sinDeg(x) * a;
            this.a = h * w - l * g, this.b = h * v - l * p, this.c = o * w + d * g, this.d = o * v + d * p;
            break;
          }
          case Ct.NoScale:
          case Ct.NoScaleOrReflection: {
            let u = F.cosDeg(i), m = F.sinDeg(i), f = (h * u + l * m) / this.skeleton.scaleX, x = (o * u + d * m) / this.skeleton.scaleY, w = Math.sqrt(f * f + x * x);
            w > 1e-5 && (w = 1 / w), f *= w, x *= w, w = Math.sqrt(f * f + x * x), this.data.transformMode == Ct.NoScale && h * d - l * o < 0 != (this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0) && (w = -w);
            let v = Math.PI / 2 + Math.atan2(x, f), g = Math.cos(v) * w, p = Math.sin(v) * w, b = F.cosDeg(c) * s, y = F.cosDeg(90 + n) * a, T = F.sinDeg(c) * s, A = F.sinDeg(90 + n) * a;
            this.a = f * b + g * T, this.b = f * y + g * A, this.c = x * b + p * T, this.d = x * y + p * A;
            break;
          }
        }
        this.a *= this.skeleton.scaleX, this.b *= this.skeleton.scaleX, this.c *= this.skeleton.scaleY, this.d *= this.skeleton.scaleY;
      }
      setToSetupPose() {
        let t = this.data;
        this.x = t.x, this.y = t.y, this.rotation = t.rotation, this.scaleX = t.scaleX, this.scaleY = t.scaleY, this.shearX = t.shearX, this.shearY = t.shearY;
      }
      getWorldRotationX() {
        return Math.atan2(this.c, this.a) * F.radDeg;
      }
      getWorldRotationY() {
        return Math.atan2(this.d, this.b) * F.radDeg;
      }
      getWorldScaleX() {
        return Math.sqrt(this.a * this.a + this.c * this.c);
      }
      getWorldScaleY() {
        return Math.sqrt(this.b * this.b + this.d * this.d);
      }
      updateAppliedTransform() {
        let t = this.parent;
        if (!t) {
          this.ax = this.worldX - this.skeleton.x, this.ay = this.worldY - this.skeleton.y, this.arotation = Math.atan2(this.c, this.a) * F.radDeg, this.ascaleX = Math.sqrt(this.a * this.a + this.c * this.c), this.ascaleY = Math.sqrt(this.b * this.b + this.d * this.d), this.ashearX = 0, this.ashearY = Math.atan2(this.a * this.b + this.c * this.d, this.a * this.d - this.b * this.c) * F.radDeg;
          return;
        }
        let e = t.a, i = t.b, s = t.c, a = t.d, c = 1 / (e * a - i * s), n = this.worldX - t.worldX, r = this.worldY - t.worldY;
        this.ax = n * a * c - r * i * c, this.ay = r * e * c - n * s * c;
        let h = c * a, l = c * e, o = c * i, d = c * s, u = h * this.a - o * this.c, m = h * this.b - o * this.d, f = l * this.c - d * this.a, x = l * this.d - d * this.b;
        if (this.ashearX = 0, this.ascaleX = Math.sqrt(u * u + f * f), this.ascaleX > 1e-4) {
          let w = u * x - m * f;
          this.ascaleY = w / this.ascaleX, this.ashearY = Math.atan2(u * m + f * x, w) * F.radDeg, this.arotation = Math.atan2(f, u) * F.radDeg;
        } else this.ascaleX = 0, this.ascaleY = Math.sqrt(m * m + x * x), this.ashearY = 0, this.arotation = 90 - Math.atan2(x, m) * F.radDeg;
      }
      worldToLocal(t) {
        let e = 1 / (this.a * this.d - this.b * this.c), i = t.x - this.worldX, s = t.y - this.worldY;
        return t.x = i * this.d * e - s * this.b * e, t.y = s * this.a * e - i * this.c * e, t;
      }
      localToWorld(t) {
        let e = t.x, i = t.y;
        return t.x = e * this.a + i * this.b + this.worldX, t.y = e * this.c + i * this.d + this.worldY, t;
      }
      worldToLocalRotation(t) {
        let e = F.sinDeg(t), i = F.cosDeg(t);
        return Math.atan2(this.a * e - this.c * i, this.d * i - this.b * e) * F.radDeg + this.rotation - this.shearX;
      }
      localToWorldRotation(t) {
        t -= this.rotation - this.shearX;
        let e = F.sinDeg(t), i = F.cosDeg(t);
        return Math.atan2(i * this.c + e * this.d, i * this.a + e * this.b) * F.radDeg;
      }
      rotateWorld(t) {
        let e = this.a, i = this.b, s = this.c, a = this.d, c = F.cosDeg(t), n = F.sinDeg(t);
        this.a = c * e - n * s, this.b = c * i - n * a, this.c = n * e + c * s, this.d = n * i + c * a;
      }
    }, Ae = class {
      constructor(t, e, i) {
        this.name = t, this.order = e, this.skinRequired = i;
      }
    }, Ji = class {
      constructor(t, e = "", i = null) {
        this.pathPrefix = null, this.assets = {}, this.errors = {}, this.toLoad = 0, this.loaded = 0, this.textureLoader = t, this.pathPrefix = e, this.downloader = i || new Ki();
      }
      start(t) {
        return this.toLoad++, this.pathPrefix + t;
      }
      success(t, e, i) {
        this.toLoad--, this.loaded++, this.assets[e] = i, t && t(e, i);
      }
      error(t, e, i) {
        this.toLoad--, this.loaded++, this.errors[e] = i, t && t(e, i);
      }
      loadAll() {
        return new Promise((e, i) => {
          let s = () => {
            if (this.isLoadingComplete()) {
              this.hasErrors() ? i(this.errors) : e(this);
              return;
            }
            requestAnimationFrame(s);
          };
          requestAnimationFrame(s);
        });
      }
      setRawDataURI(t, e) {
        this.downloader.rawDataUris[this.pathPrefix + t] = e;
      }
      loadBinary(t, e = null, i = null) {
        t = this.start(t), this.downloader.downloadBinary(t, (s) => {
          this.success(e, t, s);
        }, (s, a) => {
          this.error(i, t, `Couldn't load binary ${t}: status ${s}, ${a}`);
        });
      }
      loadText(t, e = null, i = null) {
        t = this.start(t), this.downloader.downloadText(t, (s) => {
          this.success(e, t, s);
        }, (s, a) => {
          this.error(i, t, `Couldn't load text ${t}: status ${s}, ${a}`);
        });
      }
      loadJson(t, e = null, i = null) {
        t = this.start(t), this.downloader.downloadJson(t, (s) => {
          this.success(e, t, s);
        }, (s, a) => {
          this.error(i, t, `Couldn't load JSON ${t}: status ${s}, ${a}`);
        });
      }
      loadTexture(t, e = null, i = null) {
        if (t = this.start(t), !!!(typeof window != "undefined" && typeof navigator != "undefined" && window.document)) fetch(t, { mode: "cors" }).then((c) => c.ok ? c.blob() : (this.error(i, t, `Couldn't load image: ${t}`), null)).then((c) => c ? createImageBitmap(c, { premultiplyAlpha: "none", colorSpaceConversion: "none" }) : null).then((c) => {
          c && this.success(e, t, this.textureLoader(c));
        });
        else {
          let c = new Image();
          c.crossOrigin = "anonymous", c.onload = () => {
            this.success(e, t, this.textureLoader(c));
          }, c.onerror = () => {
            this.error(i, t, `Couldn't load image: ${t}`);
          }, this.downloader.rawDataUris[t] && (t = this.downloader.rawDataUris[t]), c.src = t;
        }
      }
      loadTextureAtlas(t, e = null, i = null, s = null) {
        let a = t.lastIndexOf("/"), c = a >= 0 ? t.substring(0, a + 1) : "";
        t = this.start(t), this.downloader.downloadText(t, (n) => {
          try {
            let r = new ji(n), h = r.pages.length, l = false;
            for (let o of r.pages) this.loadTexture(s == null ? c + o.name : s[o.name], (d, u) => {
              l || (o.setTexture(u), --h == 0 && this.success(e, t, r));
            }, (d, u) => {
              l || this.error(i, t, `Couldn't load texture atlas ${t} page image: ${d}`), l = true;
            });
          } catch (r) {
            this.error(i, t, `Couldn't parse texture atlas ${t}: ${r.message}`);
          }
        }, (n, r) => {
          this.error(i, t, `Couldn't load texture atlas ${t}: status ${n}, ${r}`);
        });
      }
      get(t) {
        return this.assets[this.pathPrefix + t];
      }
      require(t) {
        t = this.pathPrefix + t;
        let e = this.assets[t];
        if (e) return e;
        let i = this.errors[t];
        throw Error("Asset not found: " + t + (i ? `
` + i : ""));
      }
      remove(t) {
        t = this.pathPrefix + t;
        let e = this.assets[t];
        return e.dispose && e.dispose(), delete this.assets[t], e;
      }
      removeAll() {
        for (let t in this.assets) {
          let e = this.assets[t];
          e.dispose && e.dispose();
        }
        this.assets = {};
      }
      isLoadingComplete() {
        return this.toLoad == 0;
      }
      getToLoad() {
        return this.toLoad;
      }
      getLoaded() {
        return this.loaded;
      }
      dispose() {
        this.removeAll();
      }
      hasErrors() {
        return Object.keys(this.errors).length > 0;
      }
      getErrors() {
        return this.errors;
      }
    }, Ki = class {
      constructor() {
        this.callbacks = {}, this.rawDataUris = {};
      }
      dataUriToString(t) {
        if (!t.startsWith("data:")) throw new Error("Not a data URI.");
        let e = t.indexOf("base64,");
        return e != -1 ? (e += "base64,".length, atob(t.substr(e))) : t.substr(t.indexOf(",") + 1);
      }
      base64ToUint8Array(t) {
        for (var e = window.atob(t), i = e.length, s = new Uint8Array(i), a = 0; a < i; a++) s[a] = e.charCodeAt(a);
        return s;
      }
      dataUriToUint8Array(t) {
        if (!t.startsWith("data:")) throw new Error("Not a data URI.");
        let e = t.indexOf("base64,");
        if (e == -1) throw new Error("Not a binary data URI.");
        return e += "base64,".length, this.base64ToUint8Array(t.substr(e));
      }
      downloadText(t, e, i) {
        if (this.start(t, e, i)) return;
        if (this.rawDataUris[t]) {
          try {
            let c = this.rawDataUris[t];
            this.finish(t, 200, this.dataUriToString(c));
          } catch (c) {
            this.finish(t, 400, JSON.stringify(c));
          }
          return;
        }
        let s = new XMLHttpRequest();
        s.overrideMimeType("text/html"), s.open("GET", t, true);
        let a = () => {
          this.finish(t, s.status, s.responseText);
        };
        s.onload = a, s.onerror = a, s.send();
      }
      downloadJson(t, e, i) {
        this.downloadText(t, (s) => {
          e(JSON.parse(s));
        }, i);
      }
      downloadBinary(t, e, i) {
        if (this.start(t, e, i)) return;
        if (this.rawDataUris[t]) {
          try {
            let c = this.rawDataUris[t];
            this.finish(t, 200, this.dataUriToUint8Array(c));
          } catch (c) {
            this.finish(t, 400, JSON.stringify(c));
          }
          return;
        }
        let s = new XMLHttpRequest();
        s.open("GET", t, true), s.responseType = "arraybuffer";
        let a = () => {
          this.finish(t, s.status, s.response);
        };
        s.onload = () => {
          s.status == 200 || s.status == 0 ? this.finish(t, 200, new Uint8Array(s.response)) : a();
        }, s.onerror = a, s.send();
      }
      start(t, e, i) {
        let s = this.callbacks[t];
        try {
          if (s) return true;
          this.callbacks[t] = s = [];
        } finally {
          s.push(e, i);
        }
      }
      finish(t, e, i) {
        let s = this.callbacks[t];
        delete this.callbacks[t];
        let a = e == 200 || e == 0 ? [i] : [e, i];
        for (let c = a.length - 1, n = s.length; c < n; c += 2) s[c].apply(null, a);
      }
    }, mi = class {
      constructor(t, e) {
        if (this.data = null, this.intValue = 0, this.floatValue = 0, this.stringValue = null, this.time = 0, this.volume = 0, this.balance = 0, !e) throw new Error("data cannot be null.");
        this.time = t, this.data = e;
      }
    }, gi = class {
      constructor(t) {
        this.name = null, this.intValue = 0, this.floatValue = 0, this.stringValue = null, this.audioPath = null, this.volume = 0, this.balance = 0, this.name = t;
      }
    }, Qi = class {
      constructor(t, e) {
        if (this.data = null, this.bones = null, this.target = null, this.bendDirection = 0, this.compress = false, this.stretch = false, this.mix = 1, this.softness = 0, this.active = false, !t) throw new Error("data cannot be null.");
        if (!e) throw new Error("skeleton cannot be null.");
        this.data = t, this.mix = t.mix, this.softness = t.softness, this.bendDirection = t.bendDirection, this.compress = t.compress, this.stretch = t.stretch, this.bones = new Array();
        for (let i = 0; i < t.bones.length; i++) this.bones.push(e.findBone(t.bones[i].name));
        this.target = e.findBone(t.target.name);
      }
      isActive() {
        return this.active;
      }
      update() {
        if (this.mix == 0) return;
        let t = this.target, e = this.bones;
        switch (e.length) {
          case 1:
            this.apply1(e[0], t.worldX, t.worldY, this.compress, this.stretch, this.data.uniform, this.mix);
            break;
          case 2:
            this.apply2(e[0], e[1], t.worldX, t.worldY, this.bendDirection, this.stretch, this.data.uniform, this.softness, this.mix);
            break;
        }
      }
      apply1(t, e, i, s, a, c, n) {
        let r = t.parent, h = r.a, l = r.b, o = r.c, d = r.d, u = -t.ashearX - t.arotation, m = 0, f = 0;
        switch (t.data.transformMode) {
          case Ct.OnlyTranslation:
            m = e - t.worldX, f = i - t.worldY;
            break;
          case Ct.NoRotationOrReflection:
            let v = Math.abs(h * d - l * o) / (h * h + o * o), g = h / t.skeleton.scaleX, p = o / t.skeleton.scaleY;
            l = -p * v * t.skeleton.scaleX, d = g * v * t.skeleton.scaleY, u += Math.atan2(p, g) * F.radDeg;
          default:
            let b = e - r.worldX, y = i - r.worldY, T = h * d - l * o;
            m = (b * d - y * l) / T - t.ax, f = (y * h - b * o) / T - t.ay;
        }
        u += Math.atan2(f, m) * F.radDeg, t.ascaleX < 0 && (u += 180), u > 180 ? u -= 360 : u < -180 && (u += 360);
        let x = t.ascaleX, w = t.ascaleY;
        if (s || a) {
          switch (t.data.transformMode) {
            case Ct.NoScale:
            case Ct.NoScaleOrReflection:
              m = e - t.worldX, f = i - t.worldY;
          }
          let v = t.data.length * x, g = Math.sqrt(m * m + f * f);
          if (s && g < v || a && g > v && v > 1e-4) {
            let p = (g / v - 1) * n + 1;
            x *= p, c && (w *= p);
          }
        }
        t.updateWorldTransformWith(t.ax, t.ay, t.arotation + u * n, x, w, t.ashearX, t.ashearY);
      }
      apply2(t, e, i, s, a, c, n, r, h) {
        let l = t.ax, o = t.ay, d = t.ascaleX, u = t.ascaleY, m = d, f = u, x = e.ascaleX, w = 0, v = 0, g = 0;
        d < 0 ? (d = -d, w = 180, g = -1) : (w = 0, g = 1), u < 0 && (u = -u, g = -g), x < 0 ? (x = -x, v = 180) : v = 0;
        let p = e.ax, b = 0, y = 0, T = 0, A = t.a, I = t.b, k = t.c, X = t.d, B = Math.abs(d - u) <= 1e-4;
        !B || c ? (b = 0, y = A * p + t.worldX, T = k * p + t.worldY) : (b = e.ay, y = A * p + I * b + t.worldX, T = k * p + X * b + t.worldY);
        let L = t.parent;
        A = L.a, I = L.b, k = L.c, X = L.d;
        let P = 1 / (A * X - I * k), C = y - L.worldX, M = T - L.worldY, V = (C * X - M * I) * P - l, R = (M * A - C * k) * P - o, E = Math.sqrt(V * V + R * R), st = e.data.length * x, dt, ot;
        if (E < 1e-4) {
          this.apply1(t, i, s, false, c, false, h), e.updateWorldTransformWith(p, b, 0, e.ascaleX, e.ascaleY, e.ashearX, e.ashearY);
          return;
        }
        C = i - L.worldX, M = s - L.worldY;
        let rt = (C * X - M * I) * P - l, it = (M * A - C * k) * P - o, ct = rt * rt + it * it;
        if (r != 0) {
          r *= d * (x + 1) * 0.5;
          let pt = Math.sqrt(ct), It = pt - E - st * d + r;
          if (It > 0) {
            let kt = Math.min(1, It / (r * 2)) - 1;
            kt = (It - r * (1 - kt * kt)) / pt, rt -= kt * rt, it -= kt * it, ct = rt * rt + it * it;
          }
        }
        t: if (B) {
          st *= d;
          let pt = (ct - E * E - st * st) / (2 * E * st);
          pt < -1 ? (pt = -1, ot = Math.PI * a) : pt > 1 ? (pt = 1, ot = 0, c && (A = (Math.sqrt(ct) / (E + st) - 1) * h + 1, m *= A, n && (f *= A))) : ot = Math.acos(pt) * a, A = E + st * pt, I = st * Math.sin(ot), dt = Math.atan2(it * A - rt * I, rt * A + it * I);
        } else {
          A = d * st, I = u * st;
          let pt = A * A, It = I * I, kt = Math.atan2(it, rt);
          k = It * E * E + pt * ct - pt * It;
          let Gt = -2 * It * E, le = It - pt;
          if (X = Gt * Gt - 4 * le * k, X >= 0) {
            let he = Math.sqrt(X);
            Gt < 0 && (he = -he), he = -(Gt + he) * 0.5;
            let ps = he / le, ws = k / he, oe = Math.abs(ps) < Math.abs(ws) ? ps : ws;
            if (oe * oe <= ct) {
              M = Math.sqrt(ct - oe * oe) * a, dt = kt - Math.atan2(M, oe), ot = Math.atan2(M / u, (oe - E) / d);
              break t;
            }
          }
          let xe = F.PI, Fe = E - A, Ei = Fe * Fe, gs = 0, xs = 0, Le = E + A, Fi = Le * Le, bs = 0;
          k = -A * E / (pt - It), k >= -1 && k <= 1 && (k = Math.acos(k), C = A * Math.cos(k) + E, M = I * Math.sin(k), X = C * C + M * M, X < Ei && (xe = k, Ei = X, Fe = C, gs = M), X > Fi && (xs = k, Fi = X, Le = C, bs = M)), ct <= (Ei + Fi) * 0.5 ? (dt = kt - Math.atan2(gs * a, Fe), ot = xe * a) : (dt = kt - Math.atan2(bs * a, Le), ot = xs * a);
        }
        let At = Math.atan2(b, p) * g, Lt = t.arotation;
        dt = (dt - At) * F.radDeg + w - Lt, dt > 180 ? dt -= 360 : dt < -180 && (dt += 360), t.updateWorldTransformWith(l, o, Lt + dt * h, m, f, 0, 0), Lt = e.arotation, ot = ((ot + At) * F.radDeg - e.ashearX) * g + v - Lt, ot > 180 ? ot -= 360 : ot < -180 && (ot += 360), e.updateWorldTransformWith(p, b, Lt + ot * h, e.ascaleX, e.ascaleY, e.ashearX, e.ashearY);
      }
    }, xi = class extends Ae {
      constructor(t) {
        super(t, 0, false);
        this.bones = new Array(), this.target = null, this.bendDirection = 1, this.compress = false, this.stretch = false, this.uniform = false, this.mix = 1, this.softness = 0;
      }
    }, bi = class extends Ae {
      constructor(t) {
        super(t, 0, false);
        this.bones = new Array(), this.target = null, this.positionMode = null, this.spacingMode = null, this.rotateMode = null, this.offsetRotation = 0, this.position = 0, this.spacing = 0, this.mixRotate = 0, this.mixX = 0, this.mixY = 0;
      }
    }, Bt;
    (function(t) {
      t[t.Fixed = 0] = "Fixed", t[t.Percent = 1] = "Percent";
    })(Bt || (Bt = {}));
    var gt;
    (function(t) {
      t[t.Length = 0] = "Length", t[t.Fixed = 1] = "Fixed", t[t.Percent = 2] = "Percent", t[t.Proportional = 3] = "Proportional";
    })(gt || (gt = {}));
    var $t;
    (function(t) {
      t[t.Tangent = 0] = "Tangent", t[t.Chain = 1] = "Chain", t[t.ChainScale = 2] = "ChainScale";
    })($t || ($t = {}));
    var Nt = class {
      constructor(t, e) {
        if (this.data = null, this.bones = null, this.target = null, this.position = 0, this.spacing = 0, this.mixRotate = 0, this.mixX = 0, this.mixY = 0, this.spaces = new Array(), this.positions = new Array(), this.world = new Array(), this.curves = new Array(), this.lengths = new Array(), this.segments = new Array(), this.active = false, !t) throw new Error("data cannot be null.");
        if (!e) throw new Error("skeleton cannot be null.");
        this.data = t, this.bones = new Array();
        for (let i = 0, s = t.bones.length; i < s; i++) this.bones.push(e.findBone(t.bones[i].name));
        this.target = e.findSlot(t.target.name), this.position = t.position, this.spacing = t.spacing, this.mixRotate = t.mixRotate, this.mixX = t.mixX, this.mixY = t.mixY;
      }
      isActive() {
        return this.active;
      }
      update() {
        let t = this.target.getAttachment();
        if (!(t instanceof Qt)) return;
        let e = this.mixRotate, i = this.mixX, s = this.mixY;
        if (e == 0 && i == 0 && s == 0) return;
        let a = this.data, c = a.rotateMode == $t.Tangent, n = a.rotateMode == $t.ChainScale, r = this.bones, h = r.length, l = c ? h : h + 1, o = O.setArraySize(this.spaces, l), d = n ? this.lengths = O.setArraySize(this.lengths, h) : null, u = this.spacing;
        switch (a.spacingMode) {
          case gt.Percent:
            if (n) for (let b = 0, y = l - 1; b < y; b++) {
              let T = r[b], A = T.data.length;
              if (A < Nt.epsilon) d[b] = 0;
              else {
                let I = A * T.a, k = A * T.c;
                d[b] = Math.sqrt(I * I + k * k);
              }
            }
            O.arrayFill(o, 1, l, u);
            break;
          case gt.Proportional:
            let g = 0;
            for (let b = 0, y = l - 1; b < y; ) {
              let T = r[b], A = T.data.length;
              if (A < Nt.epsilon) n && (d[b] = 0), o[++b] = u;
              else {
                let I = A * T.a, k = A * T.c, X = Math.sqrt(I * I + k * k);
                n && (d[b] = X), o[++b] = X, g += X;
              }
            }
            if (g > 0) {
              g = l / g * u;
              for (let b = 1; b < l; b++) o[b] *= g;
            }
            break;
          default:
            let p = a.spacingMode == gt.Length;
            for (let b = 0, y = l - 1; b < y; ) {
              let T = r[b], A = T.data.length;
              if (A < Nt.epsilon) n && (d[b] = 0), o[++b] = u;
              else {
                let I = A * T.a, k = A * T.c, X = Math.sqrt(I * I + k * k);
                n && (d[b] = X), o[++b] = (p ? A + u : u) * X / A;
              }
            }
        }
        let m = this.computeWorldPositions(t, l, c), f = m[0], x = m[1], w = a.offsetRotation, v = false;
        if (w == 0) v = a.rotateMode == $t.Chain;
        else {
          v = false;
          let g = this.target.bone;
          w *= g.a * g.d - g.b * g.c > 0 ? F.degRad : -F.degRad;
        }
        for (let g = 0, p = 3; g < h; g++, p += 3) {
          let b = r[g];
          b.worldX += (f - b.worldX) * i, b.worldY += (x - b.worldY) * s;
          let y = m[p], T = m[p + 1], A = y - f, I = T - x;
          if (n) {
            let k = d[g];
            if (k != 0) {
              let X = (Math.sqrt(A * A + I * I) / k - 1) * e + 1;
              b.a *= X, b.c *= X;
            }
          }
          if (f = y, x = T, e > 0) {
            let k = b.a, X = b.b, B = b.c, L = b.d, P = 0, C = 0, M = 0;
            if (c ? P = m[p - 1] : o[g + 1] == 0 ? P = m[p + 2] : P = Math.atan2(I, A), P -= Math.atan2(B, k), v) {
              C = Math.cos(P), M = Math.sin(P);
              let V = b.data.length;
              f += (V * (C * k - M * B) - A) * e, x += (V * (M * k + C * B) - I) * e;
            } else P += w;
            P > F.PI ? P -= F.PI2 : P < -F.PI && (P += F.PI2), P *= e, C = Math.cos(P), M = Math.sin(P), b.a = C * k - M * B, b.b = C * X - M * L, b.c = M * k + C * B, b.d = M * X + C * L;
          }
          b.updateAppliedTransform();
        }
      }
      computeWorldPositions(t, e, i) {
        let s = this.target, a = this.position, c = this.spaces, n = O.setArraySize(this.positions, e * 3 + 2), r = null, h = t.closed, l = t.worldVerticesLength, o = l / 6, d = Nt.NONE;
        if (!t.constantSpeed) {
          let R = t.lengths;
          o -= h ? 1 : 2;
          let E = R[o];
          this.data.positionMode == Bt.Percent && (a *= E);
          let st;
          switch (this.data.spacingMode) {
            case gt.Percent:
              st = E;
              break;
            case gt.Proportional:
              st = E / e;
              break;
            default:
              st = 1;
          }
          r = O.setArraySize(this.world, 8);
          for (let dt = 0, ot = 0, rt = 0; dt < e; dt++, ot += 3) {
            let it = c[dt] * st;
            a += it;
            let ct = a;
            if (h) ct %= E, ct < 0 && (ct += E), rt = 0;
            else if (ct < 0) {
              d != Nt.BEFORE && (d = Nt.BEFORE, t.computeWorldVertices(s, 2, 4, r, 0, 2)), this.addBeforePosition(ct, r, 0, n, ot);
              continue;
            } else if (ct > E) {
              d != Nt.AFTER && (d = Nt.AFTER, t.computeWorldVertices(s, l - 6, 4, r, 0, 2)), this.addAfterPosition(ct - E, r, 0, n, ot);
              continue;
            }
            for (; ; rt++) {
              let At = R[rt];
              if (!(ct > At)) {
                if (rt == 0) ct /= At;
                else {
                  let Lt = R[rt - 1];
                  ct = (ct - Lt) / (At - Lt);
                }
                break;
              }
            }
            rt != d && (d = rt, h && rt == o ? (t.computeWorldVertices(s, l - 4, 4, r, 0, 2), t.computeWorldVertices(s, 0, 4, r, 4, 2)) : t.computeWorldVertices(s, rt * 6 + 2, 8, r, 0, 2)), this.addCurvePosition(ct, r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], n, ot, i || dt > 0 && it == 0);
          }
          return n;
        }
        h ? (l += 2, r = O.setArraySize(this.world, l), t.computeWorldVertices(s, 2, l - 4, r, 0, 2), t.computeWorldVertices(s, 0, 2, r, l - 4, 2), r[l - 2] = r[0], r[l - 1] = r[1]) : (o--, l -= 4, r = O.setArraySize(this.world, l), t.computeWorldVertices(s, 2, l, r, 0, 2));
        let u = O.setArraySize(this.curves, o), m = 0, f = r[0], x = r[1], w = 0, v = 0, g = 0, p = 0, b = 0, y = 0, T = 0, A = 0, I = 0, k = 0, X = 0, B = 0, L = 0, P = 0;
        for (let R = 0, E = 2; R < o; R++, E += 6) w = r[E], v = r[E + 1], g = r[E + 2], p = r[E + 3], b = r[E + 4], y = r[E + 5], T = (f - w * 2 + g) * 0.1875, A = (x - v * 2 + p) * 0.1875, I = ((w - g) * 3 - f + b) * 0.09375, k = ((v - p) * 3 - x + y) * 0.09375, X = T * 2 + I, B = A * 2 + k, L = (w - f) * 0.75 + T + I * 0.16666667, P = (v - x) * 0.75 + A + k * 0.16666667, m += Math.sqrt(L * L + P * P), L += X, P += B, X += I, B += k, m += Math.sqrt(L * L + P * P), L += X, P += B, m += Math.sqrt(L * L + P * P), L += X + I, P += B + k, m += Math.sqrt(L * L + P * P), u[R] = m, f = b, x = y;
        this.data.positionMode == Bt.Percent && (a *= m);
        let C;
        switch (this.data.spacingMode) {
          case gt.Percent:
            C = m;
            break;
          case gt.Proportional:
            C = m / e;
            break;
          default:
            C = 1;
        }
        let M = this.segments, V = 0;
        for (let R = 0, E = 0, st = 0, dt = 0; R < e; R++, E += 3) {
          let ot = c[R] * C;
          a += ot;
          let rt = a;
          if (h) rt %= m, rt < 0 && (rt += m), st = 0;
          else if (rt < 0) {
            this.addBeforePosition(rt, r, 0, n, E);
            continue;
          } else if (rt > m) {
            this.addAfterPosition(rt - m, r, l - 4, n, E);
            continue;
          }
          for (; ; st++) {
            let it = u[st];
            if (!(rt > it)) {
              if (st == 0) rt /= it;
              else {
                let ct = u[st - 1];
                rt = (rt - ct) / (it - ct);
              }
              break;
            }
          }
          if (st != d) {
            d = st;
            let it = st * 6;
            for (f = r[it], x = r[it + 1], w = r[it + 2], v = r[it + 3], g = r[it + 4], p = r[it + 5], b = r[it + 6], y = r[it + 7], T = (f - w * 2 + g) * 0.03, A = (x - v * 2 + p) * 0.03, I = ((w - g) * 3 - f + b) * 6e-3, k = ((v - p) * 3 - x + y) * 6e-3, X = T * 2 + I, B = A * 2 + k, L = (w - f) * 0.3 + T + I * 0.16666667, P = (v - x) * 0.3 + A + k * 0.16666667, V = Math.sqrt(L * L + P * P), M[0] = V, it = 1; it < 8; it++) L += X, P += B, X += I, B += k, V += Math.sqrt(L * L + P * P), M[it] = V;
            L += X, P += B, V += Math.sqrt(L * L + P * P), M[8] = V, L += X + I, P += B + k, V += Math.sqrt(L * L + P * P), M[9] = V, dt = 0;
          }
          for (rt *= V; ; dt++) {
            let it = M[dt];
            if (!(rt > it)) {
              if (dt == 0) rt /= it;
              else {
                let ct = M[dt - 1];
                rt = dt + (rt - ct) / (it - ct);
              }
              break;
            }
          }
          this.addCurvePosition(rt * 0.1, f, x, w, v, g, p, b, y, n, E, i || R > 0 && ot == 0);
        }
        return n;
      }
      addBeforePosition(t, e, i, s, a) {
        let c = e[i], n = e[i + 1], r = e[i + 2] - c, h = e[i + 3] - n, l = Math.atan2(h, r);
        s[a] = c + t * Math.cos(l), s[a + 1] = n + t * Math.sin(l), s[a + 2] = l;
      }
      addAfterPosition(t, e, i, s, a) {
        let c = e[i + 2], n = e[i + 3], r = c - e[i], h = n - e[i + 1], l = Math.atan2(h, r);
        s[a] = c + t * Math.cos(l), s[a + 1] = n + t * Math.sin(l), s[a + 2] = l;
      }
      addCurvePosition(t, e, i, s, a, c, n, r, h, l, o, d) {
        if (t == 0 || isNaN(t)) {
          l[o] = e, l[o + 1] = i, l[o + 2] = Math.atan2(a - i, s - e);
          return;
        }
        let u = t * t, m = u * t, f = 1 - t, x = f * f, w = x * f, v = f * t, g = v * 3, p = f * g, b = g * t, y = e * w + s * p + c * b + r * m, T = i * w + a * p + n * b + h * m;
        l[o] = y, l[o + 1] = T, d && (t < 1e-3 ? l[o + 2] = Math.atan2(a - i, s - e) : l[o + 2] = Math.atan2(T - (i * x + a * v * 2 + n * u), y - (e * x + s * v * 2 + c * u)));
      }
    }, ie = Nt;
    ie.NONE = -1, ie.BEFORE = -2, ie.AFTER = -3, ie.epsilon = 1e-5;
    var $i = class {
      constructor(t, e) {
        if (this.data = null, this.bone = null, this.color = null, this.darkColor = null, this.attachment = null, this.attachmentTime = 0, this.attachmentState = 0, this.deform = new Array(), !t) throw new Error("data cannot be null.");
        if (!e) throw new Error("bone cannot be null.");
        this.data = t, this.bone = e, this.color = new D(), this.darkColor = t.darkColor ? new D() : null, this.setToSetupPose();
      }
      getSkeleton() {
        return this.bone.skeleton;
      }
      getAttachment() {
        return this.attachment;
      }
      setAttachment(t) {
        this.attachment != t && ((!(t instanceof Pt) || !(this.attachment instanceof Pt) || t.deformAttachment != this.attachment.deformAttachment) && (this.deform.length = 0), this.attachment = t, this.attachmentTime = this.bone.skeleton.time);
      }
      setAttachmentTime(t) {
        this.attachmentTime = this.bone.skeleton.time - t;
      }
      getAttachmentTime() {
        return this.bone.skeleton.time - this.attachmentTime;
      }
      setToSetupPose() {
        this.color.setFromColor(this.data.color), this.darkColor && this.darkColor.setFromColor(this.data.darkColor), this.data.attachmentName ? (this.attachment = null, this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName))) : this.attachment = null;
      }
    }, ts = class {
      constructor(t, e) {
        if (this.data = null, this.bones = null, this.target = null, this.mixRotate = 0, this.mixX = 0, this.mixY = 0, this.mixScaleX = 0, this.mixScaleY = 0, this.mixShearY = 0, this.temp = new Ht(), this.active = false, !t) throw new Error("data cannot be null.");
        if (!e) throw new Error("skeleton cannot be null.");
        this.data = t, this.mixRotate = t.mixRotate, this.mixX = t.mixX, this.mixY = t.mixY, this.mixScaleX = t.mixScaleX, this.mixScaleY = t.mixScaleY, this.mixShearY = t.mixShearY, this.bones = new Array();
        for (let i = 0; i < t.bones.length; i++) this.bones.push(e.findBone(t.bones[i].name));
        this.target = e.findBone(t.target.name);
      }
      isActive() {
        return this.active;
      }
      update() {
        this.mixRotate == 0 && this.mixX == 0 && this.mixY == 0 && this.mixScaleX == 0 && this.mixScaleX == 0 && this.mixShearY == 0 || (this.data.local ? this.data.relative ? this.applyRelativeLocal() : this.applyAbsoluteLocal() : this.data.relative ? this.applyRelativeWorld() : this.applyAbsoluteWorld());
      }
      applyAbsoluteWorld() {
        let t = this.mixRotate, e = this.mixX, i = this.mixY, s = this.mixScaleX, a = this.mixScaleY, c = this.mixShearY, n = e != 0 || i != 0, r = this.target, h = r.a, l = r.b, o = r.c, d = r.d, u = h * d - l * o > 0 ? F.degRad : -F.degRad, m = this.data.offsetRotation * u, f = this.data.offsetShearY * u, x = this.bones;
        for (let w = 0, v = x.length; w < v; w++) {
          let g = x[w];
          if (t != 0) {
            let p = g.a, b = g.b, y = g.c, T = g.d, A = Math.atan2(o, h) - Math.atan2(y, p) + m;
            A > F.PI ? A -= F.PI2 : A < -F.PI && (A += F.PI2), A *= t;
            let I = Math.cos(A), k = Math.sin(A);
            g.a = I * p - k * y, g.b = I * b - k * T, g.c = k * p + I * y, g.d = k * b + I * T;
          }
          if (n) {
            let p = this.temp;
            r.localToWorld(p.set(this.data.offsetX, this.data.offsetY)), g.worldX += (p.x - g.worldX) * e, g.worldY += (p.y - g.worldY) * i;
          }
          if (s != 0) {
            let p = Math.sqrt(g.a * g.a + g.c * g.c);
            p != 0 && (p = (p + (Math.sqrt(h * h + o * o) - p + this.data.offsetScaleX) * s) / p), g.a *= p, g.c *= p;
          }
          if (a != 0) {
            let p = Math.sqrt(g.b * g.b + g.d * g.d);
            p != 0 && (p = (p + (Math.sqrt(l * l + d * d) - p + this.data.offsetScaleY) * a) / p), g.b *= p, g.d *= p;
          }
          if (c > 0) {
            let p = g.b, b = g.d, y = Math.atan2(b, p), T = Math.atan2(d, l) - Math.atan2(o, h) - (y - Math.atan2(g.c, g.a));
            T > F.PI ? T -= F.PI2 : T < -F.PI && (T += F.PI2), T = y + (T + f) * c;
            let A = Math.sqrt(p * p + b * b);
            g.b = Math.cos(T) * A, g.d = Math.sin(T) * A;
          }
          g.updateAppliedTransform();
        }
      }
      applyRelativeWorld() {
        let t = this.mixRotate, e = this.mixX, i = this.mixY, s = this.mixScaleX, a = this.mixScaleY, c = this.mixShearY, n = e != 0 || i != 0, r = this.target, h = r.a, l = r.b, o = r.c, d = r.d, u = h * d - l * o > 0 ? F.degRad : -F.degRad, m = this.data.offsetRotation * u, f = this.data.offsetShearY * u, x = this.bones;
        for (let w = 0, v = x.length; w < v; w++) {
          let g = x[w];
          if (t != 0) {
            let p = g.a, b = g.b, y = g.c, T = g.d, A = Math.atan2(o, h) + m;
            A > F.PI ? A -= F.PI2 : A < -F.PI && (A += F.PI2), A *= t;
            let I = Math.cos(A), k = Math.sin(A);
            g.a = I * p - k * y, g.b = I * b - k * T, g.c = k * p + I * y, g.d = k * b + I * T;
          }
          if (n) {
            let p = this.temp;
            r.localToWorld(p.set(this.data.offsetX, this.data.offsetY)), g.worldX += p.x * e, g.worldY += p.y * i;
          }
          if (s != 0) {
            let p = (Math.sqrt(h * h + o * o) - 1 + this.data.offsetScaleX) * s + 1;
            g.a *= p, g.c *= p;
          }
          if (a != 0) {
            let p = (Math.sqrt(l * l + d * d) - 1 + this.data.offsetScaleY) * a + 1;
            g.b *= p, g.d *= p;
          }
          if (c > 0) {
            let p = Math.atan2(d, l) - Math.atan2(o, h);
            p > F.PI ? p -= F.PI2 : p < -F.PI && (p += F.PI2);
            let b = g.b, y = g.d;
            p = Math.atan2(y, b) + (p - F.PI / 2 + f) * c;
            let T = Math.sqrt(b * b + y * y);
            g.b = Math.cos(p) * T, g.d = Math.sin(p) * T;
          }
          g.updateAppliedTransform();
        }
      }
      applyAbsoluteLocal() {
        let t = this.mixRotate, e = this.mixX, i = this.mixY, s = this.mixScaleX, a = this.mixScaleY, c = this.mixShearY, n = this.target, r = this.bones;
        for (let h = 0, l = r.length; h < l; h++) {
          let o = r[h], d = o.arotation;
          if (t != 0) {
            let v = n.arotation - d + this.data.offsetRotation;
            v -= (16384 - (16384.499999999996 - v / 360 | 0)) * 360, d += v * t;
          }
          let u = o.ax, m = o.ay;
          u += (n.ax - u + this.data.offsetX) * e, m += (n.ay - m + this.data.offsetY) * i;
          let f = o.ascaleX, x = o.ascaleY;
          s != 0 && f != 0 && (f = (f + (n.ascaleX - f + this.data.offsetScaleX) * s) / f), a != 0 && x != 0 && (x = (x + (n.ascaleY - x + this.data.offsetScaleY) * a) / x);
          let w = o.ashearY;
          if (c != 0) {
            let v = n.ashearY - w + this.data.offsetShearY;
            v -= (16384 - (16384.499999999996 - v / 360 | 0)) * 360, w += v * c;
          }
          o.updateWorldTransformWith(u, m, d, f, x, o.ashearX, w);
        }
      }
      applyRelativeLocal() {
        let t = this.mixRotate, e = this.mixX, i = this.mixY, s = this.mixScaleX, a = this.mixScaleY, c = this.mixShearY, n = this.target, r = this.bones;
        for (let h = 0, l = r.length; h < l; h++) {
          let o = r[h], d = o.arotation + (n.arotation + this.data.offsetRotation) * t, u = o.ax + (n.ax + this.data.offsetX) * e, m = o.ay + (n.ay + this.data.offsetY) * i, f = o.ascaleX * ((n.ascaleX - 1 + this.data.offsetScaleX) * s + 1), x = o.ascaleY * ((n.ascaleY - 1 + this.data.offsetScaleY) * a + 1), w = o.ashearY + (n.ashearY + this.data.offsetShearY) * c;
          o.updateWorldTransformWith(u, m, d, f, x, o.ashearX, w);
        }
      }
    }, Xs = class {
      constructor(t) {
        if (this.data = null, this.bones = null, this.slots = null, this.drawOrder = null, this.ikConstraints = null, this.transformConstraints = null, this.pathConstraints = null, this._updateCache = new Array(), this.skin = null, this.color = null, this.time = 0, this.scaleX = 1, this.scaleY = 1, this.x = 0, this.y = 0, !t) throw new Error("data cannot be null.");
        this.data = t, this.bones = new Array();
        for (let e = 0; e < t.bones.length; e++) {
          let i = t.bones[e], s;
          if (!i.parent) s = new fi(i, this, null);
          else {
            let a = this.bones[i.parent.index];
            s = new fi(i, this, a), a.children.push(s);
          }
          this.bones.push(s);
        }
        this.slots = new Array(), this.drawOrder = new Array();
        for (let e = 0; e < t.slots.length; e++) {
          let i = t.slots[e], s = this.bones[i.boneData.index], a = new $i(i, s);
          this.slots.push(a), this.drawOrder.push(a);
        }
        this.ikConstraints = new Array();
        for (let e = 0; e < t.ikConstraints.length; e++) {
          let i = t.ikConstraints[e];
          this.ikConstraints.push(new Qi(i, this));
        }
        this.transformConstraints = new Array();
        for (let e = 0; e < t.transformConstraints.length; e++) {
          let i = t.transformConstraints[e];
          this.transformConstraints.push(new ts(i, this));
        }
        this.pathConstraints = new Array();
        for (let e = 0; e < t.pathConstraints.length; e++) {
          let i = t.pathConstraints[e];
          this.pathConstraints.push(new ie(i, this));
        }
        this.color = new D(1, 1, 1, 1), this.updateCache();
      }
      updateCache() {
        let t = this._updateCache;
        t.length = 0;
        let e = this.bones;
        for (let l = 0, o = e.length; l < o; l++) {
          let d = e[l];
          d.sorted = d.data.skinRequired, d.active = !d.sorted;
        }
        if (this.skin) {
          let l = this.skin.bones;
          for (let o = 0, d = this.skin.bones.length; o < d; o++) {
            let u = this.bones[l[o].index];
            do
              u.sorted = false, u.active = true, u = u.parent;
            while (u);
          }
        }
        let i = this.ikConstraints, s = this.transformConstraints, a = this.pathConstraints, c = i.length, n = s.length, r = a.length, h = c + n + r;
        t: for (let l = 0; l < h; l++) {
          for (let o = 0; o < c; o++) {
            let d = i[o];
            if (d.data.order == l) {
              this.sortIkConstraint(d);
              continue t;
            }
          }
          for (let o = 0; o < n; o++) {
            let d = s[o];
            if (d.data.order == l) {
              this.sortTransformConstraint(d);
              continue t;
            }
          }
          for (let o = 0; o < r; o++) {
            let d = a[o];
            if (d.data.order == l) {
              this.sortPathConstraint(d);
              continue t;
            }
          }
        }
        for (let l = 0, o = e.length; l < o; l++) this.sortBone(e[l]);
      }
      sortIkConstraint(t) {
        if (t.active = t.target.isActive() && (!t.data.skinRequired || this.skin && O.contains(this.skin.constraints, t.data, true)), !t.active) return;
        let e = t.target;
        this.sortBone(e);
        let i = t.bones, s = i[0];
        if (this.sortBone(s), i.length == 1) this._updateCache.push(t), this.sortReset(s.children);
        else {
          let a = i[i.length - 1];
          this.sortBone(a), this._updateCache.push(t), this.sortReset(s.children), a.sorted = true;
        }
      }
      sortPathConstraint(t) {
        if (t.active = t.target.bone.isActive() && (!t.data.skinRequired || this.skin && O.contains(this.skin.constraints, t.data, true)), !t.active) return;
        let e = t.target, i = e.data.index, s = e.bone;
        this.skin && this.sortPathConstraintAttachment(this.skin, i, s), this.data.defaultSkin && this.data.defaultSkin != this.skin && this.sortPathConstraintAttachment(this.data.defaultSkin, i, s);
        for (let r = 0, h = this.data.skins.length; r < h; r++) this.sortPathConstraintAttachment(this.data.skins[r], i, s);
        let a = e.getAttachment();
        a instanceof Qt && this.sortPathConstraintAttachmentWith(a, s);
        let c = t.bones, n = c.length;
        for (let r = 0; r < n; r++) this.sortBone(c[r]);
        this._updateCache.push(t);
        for (let r = 0; r < n; r++) this.sortReset(c[r].children);
        for (let r = 0; r < n; r++) c[r].sorted = true;
      }
      sortTransformConstraint(t) {
        if (t.active = t.target.isActive() && (!t.data.skinRequired || this.skin && O.contains(this.skin.constraints, t.data, true)), !t.active) return;
        this.sortBone(t.target);
        let e = t.bones, i = e.length;
        if (t.data.local) for (let s = 0; s < i; s++) {
          let a = e[s];
          this.sortBone(a.parent), this.sortBone(a);
        }
        else for (let s = 0; s < i; s++) this.sortBone(e[s]);
        this._updateCache.push(t);
        for (let s = 0; s < i; s++) this.sortReset(e[s].children);
        for (let s = 0; s < i; s++) e[s].sorted = true;
      }
      sortPathConstraintAttachment(t, e, i) {
        let s = t.attachments[e];
        if (!!s) for (let a in s) this.sortPathConstraintAttachmentWith(s[a], i);
      }
      sortPathConstraintAttachmentWith(t, e) {
        if (!(t instanceof Qt)) return;
        let i = t.bones;
        if (!i) this.sortBone(e);
        else {
          let s = this.bones;
          for (let a = 0, c = i.length; a < c; ) {
            let n = i[a++];
            for (n += a; a < n; ) this.sortBone(s[i[a++]]);
          }
        }
      }
      sortBone(t) {
        if (t.sorted) return;
        let e = t.parent;
        e && this.sortBone(e), t.sorted = true, this._updateCache.push(t);
      }
      sortReset(t) {
        for (let e = 0, i = t.length; e < i; e++) {
          let s = t[e];
          !s.active || (s.sorted && this.sortReset(s.children), s.sorted = false);
        }
      }
      updateWorldTransform() {
        let t = this.bones;
        for (let i = 0, s = t.length; i < s; i++) {
          let a = t[i];
          a.ax = a.x, a.ay = a.y, a.arotation = a.rotation, a.ascaleX = a.scaleX, a.ascaleY = a.scaleY, a.ashearX = a.shearX, a.ashearY = a.shearY;
        }
        let e = this._updateCache;
        for (let i = 0, s = e.length; i < s; i++) e[i].update();
      }
      updateWorldTransformWith(t) {
        let e = this.getRootBone(), i = t.a, s = t.b, a = t.c, c = t.d;
        e.worldX = i * this.x + s * this.y + t.worldX, e.worldY = a * this.x + c * this.y + t.worldY;
        let n = e.rotation + 90 + e.shearY, r = F.cosDeg(e.rotation + e.shearX) * e.scaleX, h = F.cosDeg(n) * e.scaleY, l = F.sinDeg(e.rotation + e.shearX) * e.scaleX, o = F.sinDeg(n) * e.scaleY;
        e.a = (i * r + s * l) * this.scaleX, e.b = (i * h + s * o) * this.scaleX, e.c = (a * r + c * l) * this.scaleY, e.d = (a * h + c * o) * this.scaleY;
        let d = this._updateCache;
        for (let u = 0, m = d.length; u < m; u++) {
          let f = d[u];
          f != e && f.update();
        }
      }
      setToSetupPose() {
        this.setBonesToSetupPose(), this.setSlotsToSetupPose();
      }
      setBonesToSetupPose() {
        let t = this.bones;
        for (let a = 0, c = t.length; a < c; a++) t[a].setToSetupPose();
        let e = this.ikConstraints;
        for (let a = 0, c = e.length; a < c; a++) {
          let n = e[a];
          n.mix = n.data.mix, n.softness = n.data.softness, n.bendDirection = n.data.bendDirection, n.compress = n.data.compress, n.stretch = n.data.stretch;
        }
        let i = this.transformConstraints;
        for (let a = 0, c = i.length; a < c; a++) {
          let n = i[a], r = n.data;
          n.mixRotate = r.mixRotate, n.mixX = r.mixX, n.mixY = r.mixY, n.mixScaleX = r.mixScaleX, n.mixScaleY = r.mixScaleY, n.mixShearY = r.mixShearY;
        }
        let s = this.pathConstraints;
        for (let a = 0, c = s.length; a < c; a++) {
          let n = s[a], r = n.data;
          n.position = r.position, n.spacing = r.spacing, n.mixRotate = r.mixRotate, n.mixX = r.mixX, n.mixY = r.mixY;
        }
      }
      setSlotsToSetupPose() {
        let t = this.slots;
        O.arrayCopy(t, 0, this.drawOrder, 0, t.length);
        for (let e = 0, i = t.length; e < i; e++) t[e].setToSetupPose();
      }
      getRootBone() {
        return this.bones.length == 0 ? null : this.bones[0];
      }
      findBone(t) {
        if (!t) throw new Error("boneName cannot be null.");
        let e = this.bones;
        for (let i = 0, s = e.length; i < s; i++) {
          let a = e[i];
          if (a.data.name == t) return a;
        }
        return null;
      }
      findSlot(t) {
        if (!t) throw new Error("slotName cannot be null.");
        let e = this.slots;
        for (let i = 0, s = e.length; i < s; i++) {
          let a = e[i];
          if (a.data.name == t) return a;
        }
        return null;
      }
      setSkinByName(t) {
        let e = this.data.findSkin(t);
        if (!e) throw new Error("Skin not found: " + t);
        this.setSkin(e);
      }
      setSkin(t) {
        if (t != this.skin) {
          if (t) if (this.skin) t.attachAll(this, this.skin);
          else {
            let e = this.slots;
            for (let i = 0, s = e.length; i < s; i++) {
              let a = e[i], c = a.data.attachmentName;
              if (c) {
                let n = t.getAttachment(i, c);
                n && a.setAttachment(n);
              }
            }
          }
          this.skin = t, this.updateCache();
        }
      }
      getAttachmentByName(t, e) {
        return this.getAttachment(this.data.findSlot(t).index, e);
      }
      getAttachment(t, e) {
        if (!e) throw new Error("attachmentName cannot be null.");
        if (this.skin) {
          let i = this.skin.getAttachment(t, e);
          if (i) return i;
        }
        return this.data.defaultSkin ? this.data.defaultSkin.getAttachment(t, e) : null;
      }
      setAttachment(t, e) {
        if (!t) throw new Error("slotName cannot be null.");
        let i = this.slots;
        for (let s = 0, a = i.length; s < a; s++) {
          let c = i[s];
          if (c.data.name == t) {
            let n = null;
            if (e && (n = this.getAttachment(s, e), !n)) throw new Error("Attachment not found: " + e + ", for slot: " + t);
            c.setAttachment(n);
            return;
          }
        }
        throw new Error("Slot not found: " + t);
      }
      findIkConstraint(t) {
        if (!t) throw new Error("constraintName cannot be null.");
        let e = this.ikConstraints;
        for (let i = 0, s = e.length; i < s; i++) {
          let a = e[i];
          if (a.data.name == t) return a;
        }
        return null;
      }
      findTransformConstraint(t) {
        if (!t) throw new Error("constraintName cannot be null.");
        let e = this.transformConstraints;
        for (let i = 0, s = e.length; i < s; i++) {
          let a = e[i];
          if (a.data.name == t) return a;
        }
        return null;
      }
      findPathConstraint(t) {
        if (!t) throw new Error("constraintName cannot be null.");
        let e = this.pathConstraints;
        for (let i = 0, s = e.length; i < s; i++) {
          let a = e[i];
          if (a.data.name == t) return a;
        }
        return null;
      }
      getBoundsRect() {
        let t = new Ht(), e = new Ht();
        return this.getBounds(t, e), { x: t.x, y: t.y, width: e.x, height: e.y };
      }
      getBounds(t, e, i = new Array(2)) {
        if (!t) throw new Error("offset cannot be null.");
        if (!e) throw new Error("size cannot be null.");
        let s = this.drawOrder, a = Number.POSITIVE_INFINITY, c = Number.POSITIVE_INFINITY, n = Number.NEGATIVE_INFINITY, r = Number.NEGATIVE_INFINITY;
        for (let h = 0, l = s.length; h < l; h++) {
          let o = s[h];
          if (!o.bone.active) continue;
          let d = 0, u = null, m = o.getAttachment();
          if (m instanceof at) d = 8, u = O.setArraySize(i, d, 0), m.computeWorldVertices(o.bone, u, 0, 2);
          else if (m instanceof _t) {
            let f = m;
            d = f.worldVerticesLength, u = O.setArraySize(i, d, 0), f.computeWorldVertices(o, 0, d, u, 0, 2);
          }
          if (u) for (let f = 0, x = u.length; f < x; f += 2) {
            let w = u[f], v = u[f + 1];
            a = Math.min(a, w), c = Math.min(c, v), n = Math.max(n, w), r = Math.max(r, v);
          }
        }
        t.set(a, c), e.set(n - a, r - c);
      }
      update(t) {
        this.time += t;
      }
    }, pi = class {
      constructor() {
        this.name = null, this.bones = new Array(), this.slots = new Array(), this.skins = new Array(), this.defaultSkin = null, this.events = new Array(), this.animations = new Array(), this.ikConstraints = new Array(), this.transformConstraints = new Array(), this.pathConstraints = new Array(), this.x = 0, this.y = 0, this.width = 0, this.height = 0, this.version = null, this.hash = null, this.fps = 0, this.imagesPath = null, this.audioPath = null;
      }
      findBone(t) {
        if (!t) throw new Error("boneName cannot be null.");
        let e = this.bones;
        for (let i = 0, s = e.length; i < s; i++) {
          let a = e[i];
          if (a.name == t) return a;
        }
        return null;
      }
      findSlot(t) {
        if (!t) throw new Error("slotName cannot be null.");
        let e = this.slots;
        for (let i = 0, s = e.length; i < s; i++) {
          let a = e[i];
          if (a.name == t) return a;
        }
        return null;
      }
      findSkin(t) {
        if (!t) throw new Error("skinName cannot be null.");
        let e = this.skins;
        for (let i = 0, s = e.length; i < s; i++) {
          let a = e[i];
          if (a.name == t) return a;
        }
        return null;
      }
      findEvent(t) {
        if (!t) throw new Error("eventDataName cannot be null.");
        let e = this.events;
        for (let i = 0, s = e.length; i < s; i++) {
          let a = e[i];
          if (a.name == t) return a;
        }
        return null;
      }
      findAnimation(t) {
        if (!t) throw new Error("animationName cannot be null.");
        let e = this.animations;
        for (let i = 0, s = e.length; i < s; i++) {
          let a = e[i];
          if (a.name == t) return a;
        }
        return null;
      }
      findIkConstraint(t) {
        if (!t) throw new Error("constraintName cannot be null.");
        let e = this.ikConstraints;
        for (let i = 0, s = e.length; i < s; i++) {
          let a = e[i];
          if (a.name == t) return a;
        }
        return null;
      }
      findTransformConstraint(t) {
        if (!t) throw new Error("constraintName cannot be null.");
        let e = this.transformConstraints;
        for (let i = 0, s = e.length; i < s; i++) {
          let a = e[i];
          if (a.name == t) return a;
        }
        return null;
      }
      findPathConstraint(t) {
        if (!t) throw new Error("constraintName cannot be null.");
        let e = this.pathConstraints;
        for (let i = 0, s = e.length; i < s; i++) {
          let a = e[i];
          if (a.name == t) return a;
        }
        return null;
      }
    }, wi = class {
      constructor(t = 0, e = null, i = null) {
        this.slotIndex = t, this.name = e, this.attachment = i;
      }
    }, Se = class {
      constructor(t) {
        if (this.name = null, this.attachments = new Array(), this.bones = Array(), this.constraints = new Array(), !t) throw new Error("name cannot be null.");
        this.name = t;
      }
      setAttachment(t, e, i) {
        if (!i) throw new Error("attachment cannot be null.");
        let s = this.attachments;
        t >= s.length && (s.length = t + 1), s[t] || (s[t] = {}), s[t][e] = i;
      }
      addSkin(t) {
        for (let s = 0; s < t.bones.length; s++) {
          let a = t.bones[s], c = false;
          for (let n = 0; n < this.bones.length; n++) if (this.bones[n] == a) {
            c = true;
            break;
          }
          c || this.bones.push(a);
        }
        for (let s = 0; s < t.constraints.length; s++) {
          let a = t.constraints[s], c = false;
          for (let n = 0; n < this.constraints.length; n++) if (this.constraints[n] == a) {
            c = true;
            break;
          }
          c || this.constraints.push(a);
        }
        let e = t.getAttachments();
        for (let s = 0; s < e.length; s++) {
          var i = e[s];
          this.setAttachment(i.slotIndex, i.name, i.attachment);
        }
      }
      copySkin(t) {
        for (let s = 0; s < t.bones.length; s++) {
          let a = t.bones[s], c = false;
          for (let n = 0; n < this.bones.length; n++) if (this.bones[n] == a) {
            c = true;
            break;
          }
          c || this.bones.push(a);
        }
        for (let s = 0; s < t.constraints.length; s++) {
          let a = t.constraints[s], c = false;
          for (let n = 0; n < this.constraints.length; n++) if (this.constraints[n] == a) {
            c = true;
            break;
          }
          c || this.constraints.push(a);
        }
        let e = t.getAttachments();
        for (let s = 0; s < e.length; s++) {
          var i = e[s];
          !i.attachment || (i.attachment instanceof _t ? (i.attachment = i.attachment.newLinkedMesh(), this.setAttachment(i.slotIndex, i.name, i.attachment)) : (i.attachment = i.attachment.copy(), this.setAttachment(i.slotIndex, i.name, i.attachment)));
        }
      }
      getAttachment(t, e) {
        let i = this.attachments[t];
        return i ? i[e] : null;
      }
      removeAttachment(t, e) {
        let i = this.attachments[t];
        i && (i[e] = null);
      }
      getAttachments() {
        let t = new Array();
        for (var e = 0; e < this.attachments.length; e++) {
          let i = this.attachments[e];
          if (i) for (let s in i) {
            let a = i[s];
            a && t.push(new wi(e, s, a));
          }
        }
        return t;
      }
      getAttachmentsForSlot(t, e) {
        let i = this.attachments[t];
        if (i) for (let s in i) {
          let a = i[s];
          a && e.push(new wi(t, s, a));
        }
      }
      clear() {
        this.attachments.length = 0, this.bones.length = 0, this.constraints.length = 0;
      }
      attachAll(t, e) {
        let i = 0;
        for (let s = 0; s < t.slots.length; s++) {
          let a = t.slots[s], c = a.getAttachment();
          if (c && i < e.attachments.length) {
            let n = e.attachments[i];
            for (let r in n) {
              let h = n[r];
              if (c == h) {
                let l = this.getAttachment(i, r);
                l && a.setAttachment(l);
                break;
              }
            }
          }
          i++;
        }
      }
    }, vi = class {
      constructor(t, e, i) {
        if (this.index = 0, this.name = null, this.boneData = null, this.color = new D(1, 1, 1, 1), this.darkColor = null, this.attachmentName = null, this.blendMode = null, t < 0) throw new Error("index must be >= 0.");
        if (!e) throw new Error("name cannot be null.");
        if (!i) throw new Error("boneData cannot be null.");
        this.index = t, this.name = e, this.boneData = i;
      }
    }, wt;
    (function(t) {
      t[t.Normal = 0] = "Normal", t[t.Additive = 1] = "Additive", t[t.Multiply = 2] = "Multiply", t[t.Screen = 3] = "Screen";
    })(wt || (wt = {}));
    var yi = class extends Ae {
      constructor(t) {
        super(t, 0, false);
        this.bones = new Array(), this.target = null, this.mixRotate = 0, this.mixX = 0, this.mixY = 0, this.mixScaleX = 0, this.mixScaleY = 0, this.mixShearY = 0, this.offsetRotation = 0, this.offsetX = 0, this.offsetY = 0, this.offsetScaleX = 0, this.offsetScaleY = 0, this.offsetShearY = 0, this.relative = false, this.local = false;
      }
    }, Rs = class {
      constructor(t) {
        this.scale = 1, this.attachmentLoader = null, this.linkedMeshes = new Array(), this.attachmentLoader = t;
      }
      readSkeletonData(t) {
        let e = this.scale, i = new pi();
        i.name = "";
        let s = new es(t), a = s.readInt32(), c = s.readInt32();
        i.hash = c == 0 && a == 0 ? null : c.toString(16) + a.toString(16), i.version = s.readString(), i.x = s.readFloat(), i.y = s.readFloat(), i.width = s.readFloat(), i.height = s.readFloat();
        let n = s.readBoolean();
        n && (i.fps = s.readFloat(), i.imagesPath = s.readString(), i.audioPath = s.readString());
        let r = 0;
        r = s.readInt(true);
        for (let l = 0; l < r; l++) s.strings.push(s.readString());
        r = s.readInt(true);
        for (let l = 0; l < r; l++) {
          let o = s.readString(), d = l == 0 ? null : i.bones[s.readInt(true)], u = new ui(l, o, d);
          u.rotation = s.readFloat(), u.x = s.readFloat() * e, u.y = s.readFloat() * e, u.scaleX = s.readFloat(), u.scaleY = s.readFloat(), u.shearX = s.readFloat(), u.shearY = s.readFloat(), u.length = s.readFloat() * e, u.transformMode = s.readInt(true), u.skinRequired = s.readBoolean(), n && D.rgba8888ToColor(u.color, s.readInt32()), i.bones.push(u);
        }
        r = s.readInt(true);
        for (let l = 0; l < r; l++) {
          let o = s.readString(), d = i.bones[s.readInt(true)], u = new vi(l, o, d);
          D.rgba8888ToColor(u.color, s.readInt32());
          let m = s.readInt32();
          m != -1 && D.rgb888ToColor(u.darkColor = new D(), m), u.attachmentName = s.readStringRef(), u.blendMode = s.readInt(true), i.slots.push(u);
        }
        r = s.readInt(true);
        for (let l = 0, o; l < r; l++) {
          let d = new xi(s.readString());
          d.order = s.readInt(true), d.skinRequired = s.readBoolean(), o = s.readInt(true);
          for (let u = 0; u < o; u++) d.bones.push(i.bones[s.readInt(true)]);
          d.target = i.bones[s.readInt(true)], d.mix = s.readFloat(), d.softness = s.readFloat() * e, d.bendDirection = s.readByte(), d.compress = s.readBoolean(), d.stretch = s.readBoolean(), d.uniform = s.readBoolean(), i.ikConstraints.push(d);
        }
        r = s.readInt(true);
        for (let l = 0, o; l < r; l++) {
          let d = new yi(s.readString());
          d.order = s.readInt(true), d.skinRequired = s.readBoolean(), o = s.readInt(true);
          for (let u = 0; u < o; u++) d.bones.push(i.bones[s.readInt(true)]);
          d.target = i.bones[s.readInt(true)], d.local = s.readBoolean(), d.relative = s.readBoolean(), d.offsetRotation = s.readFloat(), d.offsetX = s.readFloat() * e, d.offsetY = s.readFloat() * e, d.offsetScaleX = s.readFloat(), d.offsetScaleY = s.readFloat(), d.offsetShearY = s.readFloat(), d.mixRotate = s.readFloat(), d.mixX = s.readFloat(), d.mixY = s.readFloat(), d.mixScaleX = s.readFloat(), d.mixScaleY = s.readFloat(), d.mixShearY = s.readFloat(), i.transformConstraints.push(d);
        }
        r = s.readInt(true);
        for (let l = 0, o; l < r; l++) {
          let d = new bi(s.readString());
          d.order = s.readInt(true), d.skinRequired = s.readBoolean(), o = s.readInt(true);
          for (let u = 0; u < o; u++) d.bones.push(i.bones[s.readInt(true)]);
          d.target = i.slots[s.readInt(true)], d.positionMode = s.readInt(true), d.spacingMode = s.readInt(true), d.rotateMode = s.readInt(true), d.offsetRotation = s.readFloat(), d.position = s.readFloat(), d.positionMode == Bt.Fixed && (d.position *= e), d.spacing = s.readFloat(), (d.spacingMode == gt.Length || d.spacingMode == gt.Fixed) && (d.spacing *= e), d.mixRotate = s.readFloat(), d.mixX = s.readFloat(), d.mixY = s.readFloat(), i.pathConstraints.push(d);
        }
        let h = this.readSkin(s, i, true, n);
        h && (i.defaultSkin = h, i.skins.push(h));
        {
          let l = i.skins.length;
          for (O.setArraySize(i.skins, r = l + s.readInt(true)); l < r; l++) i.skins[l] = this.readSkin(s, i, false, n);
        }
        r = this.linkedMeshes.length;
        for (let l = 0; l < r; l++) {
          let o = this.linkedMeshes[l], u = (o.skin ? i.findSkin(o.skin) : i.defaultSkin).getAttachment(o.slotIndex, o.parent);
          o.mesh.deformAttachment = o.inheritDeform ? u : o.mesh, o.mesh.setParentMesh(u), o.mesh.updateUVs();
        }
        this.linkedMeshes.length = 0, r = s.readInt(true);
        for (let l = 0; l < r; l++) {
          let o = new gi(s.readStringRef());
          o.intValue = s.readInt(false), o.floatValue = s.readFloat(), o.stringValue = s.readString(), o.audioPath = s.readString(), o.audioPath && (o.volume = s.readFloat(), o.balance = s.readFloat()), i.events.push(o);
        }
        r = s.readInt(true);
        for (let l = 0; l < r; l++) i.animations.push(this.readAnimation(s, s.readString(), i));
        return i;
      }
      readSkin(t, e, i, s) {
        let a = null, c = 0;
        if (i) {
          if (c = t.readInt(true), c == 0) return null;
          a = new Se("default");
        } else {
          a = new Se(t.readStringRef()), a.bones.length = t.readInt(true);
          for (let n = 0, r = a.bones.length; n < r; n++) a.bones[n] = e.bones[t.readInt(true)];
          for (let n = 0, r = t.readInt(true); n < r; n++) a.constraints.push(e.ikConstraints[t.readInt(true)]);
          for (let n = 0, r = t.readInt(true); n < r; n++) a.constraints.push(e.transformConstraints[t.readInt(true)]);
          for (let n = 0, r = t.readInt(true); n < r; n++) a.constraints.push(e.pathConstraints[t.readInt(true)]);
          c = t.readInt(true);
        }
        for (let n = 0; n < c; n++) {
          let r = t.readInt(true);
          for (let h = 0, l = t.readInt(true); h < l; h++) {
            let o = t.readStringRef(), d = this.readAttachment(t, e, a, r, o, s);
            d && a.setAttachment(r, o, d);
          }
        }
        return a;
      }
      readAttachment(t, e, i, s, a, c) {
        let n = this.scale, r = t.readStringRef();
        switch (r || (r = a), t.readByte()) {
          case Ut.Region: {
            let h = t.readStringRef(), l = t.readFloat(), o = t.readFloat(), d = t.readFloat(), u = t.readFloat(), m = t.readFloat(), f = t.readFloat(), x = t.readFloat(), w = t.readInt32();
            h || (h = r);
            let v = this.attachmentLoader.newRegionAttachment(i, r, h);
            return v ? (v.path = h, v.x = o * n, v.y = d * n, v.scaleX = u, v.scaleY = m, v.rotation = l, v.width = f * n, v.height = x * n, D.rgba8888ToColor(v.color, w), v.updateOffset(), v) : null;
          }
          case Ut.BoundingBox: {
            let h = t.readInt(true), l = this.readVertices(t, h), o = c ? t.readInt32() : 0, d = this.attachmentLoader.newBoundingBoxAttachment(i, r);
            return d ? (d.worldVerticesLength = h << 1, d.vertices = l.vertices, d.bones = l.bones, c && D.rgba8888ToColor(d.color, o), d) : null;
          }
          case Ut.Mesh: {
            let h = t.readStringRef(), l = t.readInt32(), o = t.readInt(true), d = this.readFloatArray(t, o << 1, 1), u = this.readShortArray(t), m = this.readVertices(t, o), f = t.readInt(true), x = null, w = 0, v = 0;
            c && (x = this.readShortArray(t), w = t.readFloat(), v = t.readFloat()), h || (h = r);
            let g = this.attachmentLoader.newMeshAttachment(i, r, h);
            return g ? (g.path = h, D.rgba8888ToColor(g.color, l), g.bones = m.bones, g.vertices = m.vertices, g.worldVerticesLength = o << 1, g.triangles = u, g.regionUVs = d, g.updateUVs(), g.hullLength = f << 1, c && (g.edges = x, g.width = w * n, g.height = v * n), g) : null;
          }
          case Ut.LinkedMesh: {
            let h = t.readStringRef(), l = t.readInt32(), o = t.readStringRef(), d = t.readStringRef(), u = t.readBoolean(), m = 0, f = 0;
            c && (m = t.readFloat(), f = t.readFloat()), h || (h = r);
            let x = this.attachmentLoader.newMeshAttachment(i, r, h);
            return x ? (x.path = h, D.rgba8888ToColor(x.color, l), c && (x.width = m * n, x.height = f * n), this.linkedMeshes.push(new Es(x, o, s, d, u)), x) : null;
          }
          case Ut.Path: {
            let h = t.readBoolean(), l = t.readBoolean(), o = t.readInt(true), d = this.readVertices(t, o), u = O.newArray(o / 3, 0);
            for (let x = 0, w = u.length; x < w; x++) u[x] = t.readFloat() * n;
            let m = c ? t.readInt32() : 0, f = this.attachmentLoader.newPathAttachment(i, r);
            return f ? (f.closed = h, f.constantSpeed = l, f.worldVerticesLength = o << 1, f.vertices = d.vertices, f.bones = d.bones, f.lengths = u, c && D.rgba8888ToColor(f.color, m), f) : null;
          }
          case Ut.Point: {
            let h = t.readFloat(), l = t.readFloat(), o = t.readFloat(), d = c ? t.readInt32() : 0, u = this.attachmentLoader.newPointAttachment(i, r);
            return u ? (u.x = l * n, u.y = o * n, u.rotation = h, c && D.rgba8888ToColor(u.color, d), u) : null;
          }
          case Ut.Clipping: {
            let h = t.readInt(true), l = t.readInt(true), o = this.readVertices(t, l), d = c ? t.readInt32() : 0, u = this.attachmentLoader.newClippingAttachment(i, r);
            return u ? (u.endSlot = e.slots[h], u.worldVerticesLength = l << 1, u.vertices = o.vertices, u.bones = o.bones, c && D.rgba8888ToColor(u.color, d), u) : null;
          }
        }
        return null;
      }
      readVertices(t, e) {
        let i = this.scale, s = e << 1, a = new Fs();
        if (!t.readBoolean()) return a.vertices = this.readFloatArray(t, s, i), a;
        let c = new Array(), n = new Array();
        for (let r = 0; r < e; r++) {
          let h = t.readInt(true);
          n.push(h);
          for (let l = 0; l < h; l++) n.push(t.readInt(true)), c.push(t.readFloat() * i), c.push(t.readFloat() * i), c.push(t.readFloat());
        }
        return a.vertices = O.toFloatArray(c), a.bones = n, a;
      }
      readFloatArray(t, e, i) {
        let s = new Array(e);
        if (i == 1) for (let a = 0; a < e; a++) s[a] = t.readFloat();
        else for (let a = 0; a < e; a++) s[a] = t.readFloat() * i;
        return s;
      }
      readShortArray(t) {
        let e = t.readInt(true), i = new Array(e);
        for (let s = 0; s < e; s++) i[s] = t.readShort();
        return i;
      }
      readAnimation(t, e, i) {
        t.readInt(true);
        let s = new Array(), a = this.scale;
        for (let o = 0, d = t.readInt(true); o < d; o++) {
          let u = t.readInt(true);
          for (let m = 0, f = t.readInt(true); m < f; m++) {
            let x = t.readByte(), w = t.readInt(true), v = w - 1;
            switch (x) {
              case _s: {
                let g = new Zt(w, u);
                for (let p = 0; p < w; p++) g.setFrame(p, t.readFloat(), t.readStringRef());
                s.push(g);
                break;
              }
              case qs: {
                let g = t.readInt(true), p = new je(w, g, u), b = t.readFloat(), y = t.readUnsignedByte() / 255, T = t.readUnsignedByte() / 255, A = t.readUnsignedByte() / 255, I = t.readUnsignedByte() / 255;
                for (let k = 0, X = 0; p.setFrame(k, b, y, T, A, I), k != v; k++) {
                  let B = t.readFloat(), L = t.readUnsignedByte() / 255, P = t.readUnsignedByte() / 255, C = t.readUnsignedByte() / 255, M = t.readUnsignedByte() / 255;
                  switch (t.readByte()) {
                    case Et:
                      p.setStepped(k);
                      break;
                    case Ft:
                      nt(t, p, X++, k, 0, b, B, y, L, 1), nt(t, p, X++, k, 1, b, B, T, P, 1), nt(t, p, X++, k, 2, b, B, A, C, 1), nt(t, p, X++, k, 3, b, B, I, M, 1);
                  }
                  b = B, y = L, T = P, A = C, I = M;
                }
                s.push(p);
                break;
              }
              case Gs: {
                let g = t.readInt(true), p = new He(w, g, u), b = t.readFloat(), y = t.readUnsignedByte() / 255, T = t.readUnsignedByte() / 255, A = t.readUnsignedByte() / 255;
                for (let I = 0, k = 0; p.setFrame(I, b, y, T, A), I != v; I++) {
                  let X = t.readFloat(), B = t.readUnsignedByte() / 255, L = t.readUnsignedByte() / 255, P = t.readUnsignedByte() / 255;
                  switch (t.readByte()) {
                    case Et:
                      p.setStepped(I);
                      break;
                    case Ft:
                      nt(t, p, k++, I, 0, b, X, y, B, 1), nt(t, p, k++, I, 1, b, X, T, L, 1), nt(t, p, k++, I, 2, b, X, A, P, 1);
                  }
                  b = X, y = B, T = L, A = P;
                }
                s.push(p);
                break;
              }
              case js: {
                let g = t.readInt(true), p = new Je(w, g, u), b = t.readFloat(), y = t.readUnsignedByte() / 255, T = t.readUnsignedByte() / 255, A = t.readUnsignedByte() / 255, I = t.readUnsignedByte() / 255, k = t.readUnsignedByte() / 255, X = t.readUnsignedByte() / 255, B = t.readUnsignedByte() / 255;
                for (let L = 0, P = 0; p.setFrame(L, b, y, T, A, I, k, X, B), L != v; L++) {
                  let C = t.readFloat(), M = t.readUnsignedByte() / 255, V = t.readUnsignedByte() / 255, R = t.readUnsignedByte() / 255, E = t.readUnsignedByte() / 255, st = t.readUnsignedByte() / 255, dt = t.readUnsignedByte() / 255, ot = t.readUnsignedByte() / 255;
                  switch (t.readByte()) {
                    case Et:
                      p.setStepped(L);
                      break;
                    case Ft:
                      nt(t, p, P++, L, 0, b, C, y, M, 1), nt(t, p, P++, L, 1, b, C, T, V, 1), nt(t, p, P++, L, 2, b, C, A, R, 1), nt(t, p, P++, L, 3, b, C, I, E, 1), nt(t, p, P++, L, 4, b, C, k, st, 1), nt(t, p, P++, L, 5, b, C, X, dt, 1), nt(t, p, P++, L, 6, b, C, B, ot, 1);
                  }
                  b = C, y = M, T = V, A = R, I = E, k = st, X = dt, B = ot;
                }
                s.push(p);
                break;
              }
              case Hs: {
                let g = t.readInt(true), p = new Ke(w, g, u), b = t.readFloat(), y = t.readUnsignedByte() / 255, T = t.readUnsignedByte() / 255, A = t.readUnsignedByte() / 255, I = t.readUnsignedByte() / 255, k = t.readUnsignedByte() / 255, X = t.readUnsignedByte() / 255;
                for (let B = 0, L = 0; p.setFrame(B, b, y, T, A, I, k, X), B != v; B++) {
                  let P = t.readFloat(), C = t.readUnsignedByte() / 255, M = t.readUnsignedByte() / 255, V = t.readUnsignedByte() / 255, R = t.readUnsignedByte() / 255, E = t.readUnsignedByte() / 255, st = t.readUnsignedByte() / 255;
                  switch (t.readByte()) {
                    case Et:
                      p.setStepped(B);
                      break;
                    case Ft:
                      nt(t, p, L++, B, 0, b, P, y, C, 1), nt(t, p, L++, B, 1, b, P, T, M, 1), nt(t, p, L++, B, 2, b, P, A, V, 1), nt(t, p, L++, B, 3, b, P, I, R, 1), nt(t, p, L++, B, 4, b, P, k, E, 1), nt(t, p, L++, B, 5, b, P, X, st, 1);
                  }
                  b = P, y = C, T = M, A = V, I = R, k = E, X = st;
                }
                s.push(p);
                break;
              }
              case Zs: {
                let g = new Ze(w, t.readInt(true), u), p = t.readFloat(), b = t.readUnsignedByte() / 255;
                for (let y = 0, T = 0; g.setFrame(y, p, b), y != v; y++) {
                  let A = t.readFloat(), I = t.readUnsignedByte() / 255;
                  switch (t.readByte()) {
                    case Et:
                      g.setStepped(y);
                      break;
                    case Ft:
                      nt(t, g, T++, y, 0, p, A, b, I, 1);
                  }
                  p = A, b = I;
                }
                s.push(g);
                break;
              }
            }
          }
        }
        for (let o = 0, d = t.readInt(true); o < d; o++) {
          let u = t.readInt(true);
          for (let m = 0, f = t.readInt(true); m < f; m++) {
            let x = t.readByte(), w = t.readInt(true), v = t.readInt(true);
            switch (x) {
              case Ls:
                s.push(zt(t, new de(w, v, u), 1));
                break;
              case Ps:
                s.push(Ai(t, new Ve(w, v, u), a));
                break;
              case Bs:
                s.push(zt(t, new De(w, v, u), a));
                break;
              case Os:
                s.push(zt(t, new Ne(w, v, u), a));
                break;
              case Vs:
                s.push(Ai(t, new Ue(w, v, u), 1));
                break;
              case Ds:
                s.push(zt(t, new ze(w, v, u), 1));
                break;
              case Ns:
                s.push(zt(t, new We(w, v, u), 1));
                break;
              case Us:
                s.push(Ai(t, new _e(w, v, u), 1));
                break;
              case zs:
                s.push(zt(t, new qe(w, v, u), 1));
                break;
              case Ws:
                s.push(zt(t, new Ge(w, v, u), 1));
            }
          }
        }
        for (let o = 0, d = t.readInt(true); o < d; o++) {
          let u = t.readInt(true), m = t.readInt(true), f = m - 1, x = new $e(m, t.readInt(true), u), w = t.readFloat(), v = t.readFloat(), g = t.readFloat() * a;
          for (let p = 0, b = 0; x.setFrame(p, w, v, g, t.readByte(), t.readBoolean(), t.readBoolean()), p != f; p++) {
            let y = t.readFloat(), T = t.readFloat(), A = t.readFloat() * a;
            switch (t.readByte()) {
              case Et:
                x.setStepped(p);
                break;
              case Ft:
                nt(t, x, b++, p, 0, w, y, v, T, 1), nt(t, x, b++, p, 1, w, y, g, A, a);
            }
            w = y, v = T, g = A;
          }
          s.push(x);
        }
        for (let o = 0, d = t.readInt(true); o < d; o++) {
          let u = t.readInt(true), m = t.readInt(true), f = m - 1, x = new ti(m, t.readInt(true), u), w = t.readFloat(), v = t.readFloat(), g = t.readFloat(), p = t.readFloat(), b = t.readFloat(), y = t.readFloat(), T = t.readFloat();
          for (let A = 0, I = 0; x.setFrame(A, w, v, g, p, b, y, T), A != f; A++) {
            let k = t.readFloat(), X = t.readFloat(), B = t.readFloat(), L = t.readFloat(), P = t.readFloat(), C = t.readFloat(), M = t.readFloat();
            switch (t.readByte()) {
              case Et:
                x.setStepped(A);
                break;
              case Ft:
                nt(t, x, I++, A, 0, w, k, v, X, 1), nt(t, x, I++, A, 1, w, k, g, B, 1), nt(t, x, I++, A, 2, w, k, p, L, 1), nt(t, x, I++, A, 3, w, k, b, P, 1), nt(t, x, I++, A, 4, w, k, y, C, 1), nt(t, x, I++, A, 5, w, k, T, M, 1);
            }
            w = k, v = X, g = B, p = L, b = P, y = C, T = M;
          }
          s.push(x);
        }
        for (let o = 0, d = t.readInt(true); o < d; o++) {
          let u = t.readInt(true), m = i.pathConstraints[u];
          for (let f = 0, x = t.readInt(true); f < x; f++) switch (t.readByte()) {
            case Js:
              s.push(zt(t, new ei(t.readInt(true), t.readInt(true), u), m.positionMode == Bt.Fixed ? a : 1));
              break;
            case Ks:
              s.push(zt(t, new ii(t.readInt(true), t.readInt(true), u), m.spacingMode == gt.Length || m.spacingMode == gt.Fixed ? a : 1));
              break;
            case Qs:
              let w = new si(t.readInt(true), t.readInt(true), u), v = t.readFloat(), g = t.readFloat(), p = t.readFloat(), b = t.readFloat();
              for (let y = 0, T = 0, A = w.getFrameCount() - 1; w.setFrame(y, v, g, p, b), y != A; y++) {
                let I = t.readFloat(), k = t.readFloat(), X = t.readFloat(), B = t.readFloat();
                switch (t.readByte()) {
                  case Et:
                    w.setStepped(y);
                    break;
                  case Ft:
                    nt(t, w, T++, y, 0, v, I, g, k, 1), nt(t, w, T++, y, 1, v, I, p, X, 1), nt(t, w, T++, y, 2, v, I, b, B, 1);
                }
                v = I, g = k, p = X, b = B;
              }
              s.push(w);
          }
        }
        for (let o = 0, d = t.readInt(true); o < d; o++) {
          let u = i.skins[t.readInt(true)];
          for (let m = 0, f = t.readInt(true); m < f; m++) {
            let x = t.readInt(true);
            for (let w = 0, v = t.readInt(true); w < v; w++) {
              let g = t.readStringRef(), p = u.getAttachment(x, g), b = p.bones, y = p.vertices, T = b ? y.length / 3 * 2 : y.length, A = t.readInt(true), I = A - 1, k = t.readInt(true), X = new Qe(A, k, x, p), B = t.readFloat();
              for (let L = 0, P = 0; ; L++) {
                let C, M = t.readInt(true);
                if (M == 0) C = b ? O.newFloatArray(T) : y;
                else {
                  C = O.newFloatArray(T);
                  let R = t.readInt(true);
                  if (M += R, a == 1) for (let E = R; E < M; E++) C[E] = t.readFloat();
                  else for (let E = R; E < M; E++) C[E] = t.readFloat() * a;
                  if (!b) for (let E = 0, st = C.length; E < st; E++) C[E] += y[E];
                }
                if (X.setFrame(L, B, C), L == I) break;
                let V = t.readFloat();
                switch (t.readByte()) {
                  case Et:
                    X.setStepped(L);
                    break;
                  case Ft:
                    nt(t, X, P++, L, 0, B, V, 0, 1, 1);
                }
                B = V;
              }
              s.push(X);
            }
          }
        }
        let r = t.readInt(true);
        if (r > 0) {
          let o = new Jt(r), d = i.slots.length;
          for (let u = 0; u < r; u++) {
            let m = t.readFloat(), f = t.readInt(true), x = O.newArray(d, 0);
            for (let p = d - 1; p >= 0; p--) x[p] = -1;
            let w = O.newArray(d - f, 0), v = 0, g = 0;
            for (let p = 0; p < f; p++) {
              let b = t.readInt(true);
              for (; v != b; ) w[g++] = v++;
              x[v + t.readInt(true)] = v++;
            }
            for (; v < d; ) w[g++] = v++;
            for (let p = d - 1; p >= 0; p--) x[p] == -1 && (x[p] = w[--g]);
            o.setFrame(u, m, x);
          }
          s.push(o);
        }
        let h = t.readInt(true);
        if (h > 0) {
          let o = new ue(h);
          for (let d = 0; d < h; d++) {
            let u = t.readFloat(), m = i.events[t.readInt(true)], f = new mi(u, m);
            f.intValue = t.readInt(false), f.floatValue = t.readFloat(), f.stringValue = t.readBoolean() ? t.readString() : m.stringValue, f.data.audioPath && (f.volume = t.readFloat(), f.balance = t.readFloat()), o.setFrame(d, f);
          }
          s.push(o);
        }
        let l = 0;
        for (let o = 0, d = s.length; o < d; o++) l = Math.max(l, s[o].getDuration());
        return new be(e, s, l);
      }
    }, es = class {
      constructor(t, e = new Array(), i = 0, s = new DataView(t.buffer)) {
        this.strings = e, this.index = i, this.buffer = s;
      }
      readByte() {
        return this.buffer.getInt8(this.index++);
      }
      readUnsignedByte() {
        return this.buffer.getUint8(this.index++);
      }
      readShort() {
        let t = this.buffer.getInt16(this.index);
        return this.index += 2, t;
      }
      readInt32() {
        let t = this.buffer.getInt32(this.index);
        return this.index += 4, t;
      }
      readInt(t) {
        let e = this.readByte(), i = e & 127;
        return (e & 128) != 0 && (e = this.readByte(), i |= (e & 127) << 7, (e & 128) != 0 && (e = this.readByte(), i |= (e & 127) << 14, (e & 128) != 0 && (e = this.readByte(), i |= (e & 127) << 21, (e & 128) != 0 && (e = this.readByte(), i |= (e & 127) << 28)))), t ? i : i >>> 1 ^ -(i & 1);
      }
      readStringRef() {
        let t = this.readInt(true);
        return t == 0 ? null : this.strings[t - 1];
      }
      readString() {
        let t = this.readInt(true);
        switch (t) {
          case 0:
            return null;
          case 1:
            return "";
        }
        t--;
        let e = "";
        for (let s = 0; s < t; ) {
          let a = this.readUnsignedByte();
          switch (a >> 4) {
            case 12:
            case 13:
              e += String.fromCharCode((a & 31) << 6 | this.readByte() & 63), s += 2;
              break;
            case 14:
              e += String.fromCharCode((a & 15) << 12 | (this.readByte() & 63) << 6 | this.readByte() & 63), s += 3;
              break;
            default:
              e += String.fromCharCode(a), s++;
          }
        }
        return e;
      }
      readFloat() {
        let t = this.buffer.getFloat32(this.index);
        return this.index += 4, t;
      }
      readBoolean() {
        return this.readByte() != 0;
      }
    }, Es = class {
      constructor(t, e, i, s, a) {
        this.mesh = t, this.skin = e, this.slotIndex = i, this.parent = s, this.inheritDeform = a;
      }
    }, Fs = class {
      constructor(t = null, e = null) {
        this.bones = t, this.vertices = e;
      }
    }, Ut;
    (function(t) {
      t[t.Region = 0] = "Region", t[t.BoundingBox = 1] = "BoundingBox", t[t.Mesh = 2] = "Mesh", t[t.LinkedMesh = 3] = "LinkedMesh", t[t.Path = 4] = "Path", t[t.Point = 5] = "Point", t[t.Clipping = 6] = "Clipping";
    })(Ut || (Ut = {}));
    function zt(t, e, i) {
      let s = t.readFloat(), a = t.readFloat() * i;
      for (let c = 0, n = 0, r = e.getFrameCount() - 1; e.setFrame(c, s, a), c != r; c++) {
        let h = t.readFloat(), l = t.readFloat() * i;
        switch (t.readByte()) {
          case Et:
            e.setStepped(c);
            break;
          case Ft:
            nt(t, e, n++, c, 0, s, h, a, l, i);
        }
        s = h, a = l;
      }
      return e;
    }
    function Ai(t, e, i) {
      let s = t.readFloat(), a = t.readFloat() * i, c = t.readFloat() * i;
      for (let n = 0, r = 0, h = e.getFrameCount() - 1; e.setFrame(n, s, a, c), n != h; n++) {
        let l = t.readFloat(), o = t.readFloat() * i, d = t.readFloat() * i;
        switch (t.readByte()) {
          case Et:
            e.setStepped(n);
            break;
          case Ft:
            nt(t, e, r++, n, 0, s, l, a, o, i), nt(t, e, r++, n, 1, s, l, c, d, i);
        }
        s = l, a = o, c = d;
      }
      return e;
    }
    function nt(t, e, i, s, a, c, n, r, h, l) {
      e.setBezier(i, s, a, c, r, t.readFloat(), t.readFloat() * l, t.readFloat(), t.readFloat() * l, n, h);
    }
    var Ls = 0, Ps = 1, Bs = 2, Os = 3, Vs = 4, Ds = 5, Ns = 6, Us = 7, zs = 8, Ws = 9, _s = 0, qs = 1, Gs = 2, js = 3, Hs = 4, Zs = 5, Js = 0, Ks = 1, Qs = 2, Et = 1, Ft = 2, is = class {
      constructor() {
        this.minX = 0, this.minY = 0, this.maxX = 0, this.maxY = 0, this.boundingBoxes = new Array(), this.polygons = new Array(), this.polygonPool = new ce(() => O.newFloatArray(16));
      }
      update(t, e) {
        if (!t) throw new Error("skeleton cannot be null.");
        let i = this.boundingBoxes, s = this.polygons, a = this.polygonPool, c = t.slots, n = c.length;
        i.length = 0, a.freeAll(s), s.length = 0;
        for (let r = 0; r < n; r++) {
          let h = c[r];
          if (!h.bone.active) continue;
          let l = h.getAttachment();
          if (l instanceof ye) {
            let o = l;
            i.push(o);
            let d = a.obtain();
            d.length != o.worldVerticesLength && (d = O.newFloatArray(o.worldVerticesLength)), s.push(d), o.computeWorldVertices(h, 0, o.worldVerticesLength, d, 0, 2);
          }
        }
        e ? this.aabbCompute() : (this.minX = Number.POSITIVE_INFINITY, this.minY = Number.POSITIVE_INFINITY, this.maxX = Number.NEGATIVE_INFINITY, this.maxY = Number.NEGATIVE_INFINITY);
      }
      aabbCompute() {
        let t = Number.POSITIVE_INFINITY, e = Number.POSITIVE_INFINITY, i = Number.NEGATIVE_INFINITY, s = Number.NEGATIVE_INFINITY, a = this.polygons;
        for (let c = 0, n = a.length; c < n; c++) {
          let r = a[c], h = r;
          for (let l = 0, o = r.length; l < o; l += 2) {
            let d = h[l], u = h[l + 1];
            t = Math.min(t, d), e = Math.min(e, u), i = Math.max(i, d), s = Math.max(s, u);
          }
        }
        this.minX = t, this.minY = e, this.maxX = i, this.maxY = s;
      }
      aabbContainsPoint(t, e) {
        return t >= this.minX && t <= this.maxX && e >= this.minY && e <= this.maxY;
      }
      aabbIntersectsSegment(t, e, i, s) {
        let a = this.minX, c = this.minY, n = this.maxX, r = this.maxY;
        if (t <= a && i <= a || e <= c && s <= c || t >= n && i >= n || e >= r && s >= r) return false;
        let h = (s - e) / (i - t), l = h * (a - t) + e;
        if (l > c && l < r || (l = h * (n - t) + e, l > c && l < r)) return true;
        let o = (c - e) / h + t;
        return !!(o > a && o < n || (o = (r - e) / h + t, o > a && o < n));
      }
      aabbIntersectsSkeleton(t) {
        return this.minX < t.maxX && this.maxX > t.minX && this.minY < t.maxY && this.maxY > t.minY;
      }
      containsPoint(t, e) {
        let i = this.polygons;
        for (let s = 0, a = i.length; s < a; s++) if (this.containsPointPolygon(i[s], t, e)) return this.boundingBoxes[s];
        return null;
      }
      containsPointPolygon(t, e, i) {
        let s = t, a = t.length, c = a - 2, n = false;
        for (let r = 0; r < a; r += 2) {
          let h = s[r + 1], l = s[c + 1];
          if (h < i && l >= i || l < i && h >= i) {
            let o = s[r];
            o + (i - h) / (l - h) * (s[c] - o) < e && (n = !n);
          }
          c = r;
        }
        return n;
      }
      intersectsSegment(t, e, i, s) {
        let a = this.polygons;
        for (let c = 0, n = a.length; c < n; c++) if (this.intersectsSegmentPolygon(a[c], t, e, i, s)) return this.boundingBoxes[c];
        return null;
      }
      intersectsSegmentPolygon(t, e, i, s, a) {
        let c = t, n = t.length, r = e - s, h = i - a, l = e * a - i * s, o = c[n - 2], d = c[n - 1];
        for (let u = 0; u < n; u += 2) {
          let m = c[u], f = c[u + 1], x = o * f - d * m, w = o - m, v = d - f, g = r * v - h * w, p = (l * w - r * x) / g;
          if ((p >= o && p <= m || p >= m && p <= o) && (p >= e && p <= s || p >= s && p <= e)) {
            let b = (l * v - h * x) / g;
            if ((b >= d && b <= f || b >= f && b <= d) && (b >= i && b <= a || b >= a && b <= i)) return true;
          }
          o = m, d = f;
        }
        return false;
      }
      getPolygon(t) {
        if (!t) throw new Error("boundingBox cannot be null.");
        let e = this.boundingBoxes.indexOf(t);
        return e == -1 ? null : this.polygons[e];
      }
      getWidth() {
        return this.maxX - this.minX;
      }
      getHeight() {
        return this.maxY - this.minY;
      }
    }, Tt = class {
      constructor() {
        this.convexPolygons = new Array(), this.convexPolygonsIndices = new Array(), this.indicesArray = new Array(), this.isConcaveArray = new Array(), this.triangles = new Array(), this.polygonPool = new ce(() => new Array()), this.polygonIndicesPool = new ce(() => new Array());
      }
      triangulate(t) {
        let e = t, i = t.length >> 1, s = this.indicesArray;
        s.length = 0;
        for (let n = 0; n < i; n++) s[n] = n;
        let a = this.isConcaveArray;
        a.length = 0;
        for (let n = 0, r = i; n < r; ++n) a[n] = Tt.isConcave(n, i, e, s);
        let c = this.triangles;
        for (c.length = 0; i > 3; ) {
          let n = i - 1, r = 0, h = 1;
          for (; ; ) {
            t: if (!a[r]) {
              let d = s[n] << 1, u = s[r] << 1, m = s[h] << 1, f = e[d], x = e[d + 1], w = e[u], v = e[u + 1], g = e[m], p = e[m + 1];
              for (let b = (h + 1) % i; b != n; b = (b + 1) % i) {
                if (!a[b]) continue;
                let y = s[b] << 1, T = e[y], A = e[y + 1];
                if (Tt.positiveArea(g, p, f, x, T, A) && Tt.positiveArea(f, x, w, v, T, A) && Tt.positiveArea(w, v, g, p, T, A)) break t;
              }
              break;
            }
            if (h == 0) {
              do {
                if (!a[r]) break;
                r--;
              } while (r > 0);
              break;
            }
            n = r, r = h, h = (h + 1) % i;
          }
          c.push(s[(i + r - 1) % i]), c.push(s[r]), c.push(s[(r + 1) % i]), s.splice(r, 1), a.splice(r, 1), i--;
          let l = (i + r - 1) % i, o = r == i ? 0 : r;
          a[l] = Tt.isConcave(l, i, e, s), a[o] = Tt.isConcave(o, i, e, s);
        }
        return i == 3 && (c.push(s[2]), c.push(s[0]), c.push(s[1])), c;
      }
      decompose(t, e) {
        let i = t, s = this.convexPolygons;
        this.polygonPool.freeAll(s), s.length = 0;
        let a = this.convexPolygonsIndices;
        this.polygonIndicesPool.freeAll(a), a.length = 0;
        let c = this.polygonIndicesPool.obtain();
        c.length = 0;
        let n = this.polygonPool.obtain();
        n.length = 0;
        let r = -1, h = 0;
        for (let l = 0, o = e.length; l < o; l += 3) {
          let d = e[l] << 1, u = e[l + 1] << 1, m = e[l + 2] << 1, f = i[d], x = i[d + 1], w = i[u], v = i[u + 1], g = i[m], p = i[m + 1], b = false;
          if (r == d) {
            let y = n.length - 4, T = Tt.winding(n[y], n[y + 1], n[y + 2], n[y + 3], g, p), A = Tt.winding(g, p, n[0], n[1], n[2], n[3]);
            T == h && A == h && (n.push(g), n.push(p), c.push(m), b = true);
          }
          b || (n.length > 0 ? (s.push(n), a.push(c)) : (this.polygonPool.free(n), this.polygonIndicesPool.free(c)), n = this.polygonPool.obtain(), n.length = 0, n.push(f), n.push(x), n.push(w), n.push(v), n.push(g), n.push(p), c = this.polygonIndicesPool.obtain(), c.length = 0, c.push(d), c.push(u), c.push(m), h = Tt.winding(f, x, w, v, g, p), r = d);
        }
        n.length > 0 && (s.push(n), a.push(c));
        for (let l = 0, o = s.length; l < o; l++) {
          if (c = a[l], c.length == 0) continue;
          let d = c[0], u = c[c.length - 1];
          n = s[l];
          let m = n.length - 4, f = n[m], x = n[m + 1], w = n[m + 2], v = n[m + 3], g = n[0], p = n[1], b = n[2], y = n[3], T = Tt.winding(f, x, w, v, g, p);
          for (let A = 0; A < o; A++) {
            if (A == l) continue;
            let I = a[A];
            if (I.length != 3) continue;
            let k = I[0], X = I[1], B = I[2], L = s[A], P = L[L.length - 2], C = L[L.length - 1];
            if (k != d || X != u) continue;
            let M = Tt.winding(f, x, w, v, P, C), V = Tt.winding(P, C, g, p, b, y);
            M == T && V == T && (L.length = 0, I.length = 0, n.push(P), n.push(C), c.push(B), f = w, x = v, w = P, v = C, A = 0);
          }
        }
        for (let l = s.length - 1; l >= 0; l--) n = s[l], n.length == 0 && (s.splice(l, 1), this.polygonPool.free(n), c = a[l], a.splice(l, 1), this.polygonIndicesPool.free(c));
        return s;
      }
      static isConcave(t, e, i, s) {
        let a = s[(e + t - 1) % e] << 1, c = s[t] << 1, n = s[(t + 1) % e] << 1;
        return !this.positiveArea(i[a], i[a + 1], i[c], i[c + 1], i[n], i[n + 1]);
      }
      static positiveArea(t, e, i, s, a, c) {
        return t * (c - s) + i * (e - c) + a * (s - e) >= 0;
      }
      static winding(t, e, i, s, a, c) {
        let n = i - t, r = s - e;
        return a * r - c * n + n * e - t * r >= 0 ? 1 : -1;
      }
    }, Ce = class {
      constructor() {
        this.triangulator = new Tt(), this.clippingPolygon = new Array(), this.clipOutput = new Array(), this.clippedVertices = new Array(), this.clippedTriangles = new Array(), this.scratch = new Array();
      }
      clipStart(t, e) {
        if (this.clipAttachment) return 0;
        this.clipAttachment = e;
        let i = e.worldVerticesLength, s = O.setArraySize(this.clippingPolygon, i);
        e.computeWorldVertices(t, 0, i, s, 0, 2);
        let a = this.clippingPolygon;
        Ce.makeClockwise(a);
        let c = this.clippingPolygons = this.triangulator.decompose(a, this.triangulator.triangulate(a));
        for (let n = 0, r = c.length; n < r; n++) {
          let h = c[n];
          Ce.makeClockwise(h), h.push(h[0]), h.push(h[1]);
        }
        return c.length;
      }
      clipEndWithSlot(t) {
        this.clipAttachment && this.clipAttachment.endSlot == t.data && this.clipEnd();
      }
      clipEnd() {
        !this.clipAttachment || (this.clipAttachment = null, this.clippingPolygons = null, this.clippedVertices.length = 0, this.clippedTriangles.length = 0, this.clippingPolygon.length = 0);
      }
      isClipping() {
        return this.clipAttachment != null;
      }
      clipTriangles(t, e, i, s, a, c, n, r) {
        let h = this.clipOutput, l = this.clippedVertices, o = this.clippedTriangles, d = this.clippingPolygons, u = this.clippingPolygons.length, m = r ? 12 : 8, f = 0;
        l.length = 0, o.length = 0;
        t: for (let x = 0; x < s; x += 3) {
          let w = i[x] << 1, v = t[w], g = t[w + 1], p = a[w], b = a[w + 1];
          w = i[x + 1] << 1;
          let y = t[w], T = t[w + 1], A = a[w], I = a[w + 1];
          w = i[x + 2] << 1;
          let k = t[w], X = t[w + 1], B = a[w], L = a[w + 1];
          for (let P = 0; P < u; P++) {
            let C = l.length;
            if (this.clip(v, g, y, T, k, X, d[P], h)) {
              let M = h.length;
              if (M == 0) continue;
              let V = T - X, R = k - y, E = v - k, st = X - g, dt = 1 / (V * E + R * (g - X)), ot = M >> 1, rt = this.clipOutput, it = O.setArraySize(l, C + ot * m);
              for (let At = 0; At < M; At += 2) {
                let Lt = rt[At], pt = rt[At + 1];
                it[C] = Lt, it[C + 1] = pt, it[C + 2] = c.r, it[C + 3] = c.g, it[C + 4] = c.b, it[C + 5] = c.a;
                let It = Lt - k, kt = pt - X, Gt = (V * It + R * kt) * dt, le = (st * It + E * kt) * dt, xe = 1 - Gt - le;
                it[C + 6] = p * Gt + A * le + B * xe, it[C + 7] = b * Gt + I * le + L * xe, r && (it[C + 8] = n.r, it[C + 9] = n.g, it[C + 10] = n.b, it[C + 11] = n.a), C += m;
              }
              C = o.length;
              let ct = O.setArraySize(o, C + 3 * (ot - 2));
              ot--;
              for (let At = 1; At < ot; At++) ct[C] = f, ct[C + 1] = f + At, ct[C + 2] = f + At + 1, C += 3;
              f += ot + 1;
            } else {
              let M = O.setArraySize(l, C + 3 * m);
              M[C] = v, M[C + 1] = g, M[C + 2] = c.r, M[C + 3] = c.g, M[C + 4] = c.b, M[C + 5] = c.a, r ? (M[C + 6] = p, M[C + 7] = b, M[C + 8] = n.r, M[C + 9] = n.g, M[C + 10] = n.b, M[C + 11] = n.a, M[C + 12] = y, M[C + 13] = T, M[C + 14] = c.r, M[C + 15] = c.g, M[C + 16] = c.b, M[C + 17] = c.a, M[C + 18] = A, M[C + 19] = I, M[C + 20] = n.r, M[C + 21] = n.g, M[C + 22] = n.b, M[C + 23] = n.a, M[C + 24] = k, M[C + 25] = X, M[C + 26] = c.r, M[C + 27] = c.g, M[C + 28] = c.b, M[C + 29] = c.a, M[C + 30] = B, M[C + 31] = L, M[C + 32] = n.r, M[C + 33] = n.g, M[C + 34] = n.b, M[C + 35] = n.a) : (M[C + 6] = p, M[C + 7] = b, M[C + 8] = y, M[C + 9] = T, M[C + 10] = c.r, M[C + 11] = c.g, M[C + 12] = c.b, M[C + 13] = c.a, M[C + 14] = A, M[C + 15] = I, M[C + 16] = k, M[C + 17] = X, M[C + 18] = c.r, M[C + 19] = c.g, M[C + 20] = c.b, M[C + 21] = c.a, M[C + 22] = B, M[C + 23] = L), C = o.length;
              let V = O.setArraySize(o, C + 3);
              V[C] = f, V[C + 1] = f + 1, V[C + 2] = f + 2, f += 3;
              continue t;
            }
          }
        }
      }
      clip(t, e, i, s, a, c, n, r) {
        let h = r, l = false, o = null;
        n.length % 4 >= 2 ? (o = r, r = this.scratch) : o = this.scratch, o.length = 0, o.push(t), o.push(e), o.push(i), o.push(s), o.push(a), o.push(c), o.push(t), o.push(e), r.length = 0;
        let d = n, u = n.length - 4;
        for (let m = 0; ; m += 2) {
          let f = d[m], x = d[m + 1], w = d[m + 2], v = d[m + 3], g = f - w, p = x - v, b = o, y = o.length - 2, T = r.length;
          for (let I = 0; I < y; I += 2) {
            let k = b[I], X = b[I + 1], B = b[I + 2], L = b[I + 3], P = g * (L - v) - p * (B - w) > 0;
            if (g * (X - v) - p * (k - w) > 0) {
              if (P) {
                r.push(B), r.push(L);
                continue;
              }
              let C = L - X, M = B - k, V = C * (w - f) - M * (v - x);
              if (Math.abs(V) > 1e-6) {
                let R = (M * (x - X) - C * (f - k)) / V;
                r.push(f + (w - f) * R), r.push(x + (v - x) * R);
              } else r.push(f), r.push(x);
            } else if (P) {
              let C = L - X, M = B - k, V = C * (w - f) - M * (v - x);
              if (Math.abs(V) > 1e-6) {
                let R = (M * (x - X) - C * (f - k)) / V;
                r.push(f + (w - f) * R), r.push(x + (v - x) * R);
              } else r.push(f), r.push(x);
              r.push(B), r.push(L);
            }
            l = true;
          }
          if (T == r.length) return h.length = 0, true;
          if (r.push(r[0]), r.push(r[1]), m == u) break;
          let A = r;
          r = o, r.length = 0, o = A;
        }
        if (h != r) {
          h.length = 0;
          for (let m = 0, f = r.length - 2; m < f; m++) h[m] = r[m];
        } else h.length = h.length - 2;
        return l;
      }
      static makeClockwise(t) {
        let e = t, i = t.length, s = e[i - 2] * e[1] - e[0] * e[i - 1], a = 0, c = 0, n = 0, r = 0;
        for (let h = 0, l = i - 3; h < l; h += 2) a = e[h], c = e[h + 1], n = e[h + 2], r = e[h + 3], s += a * r - n * c;
        if (!(s < 0)) for (let h = 0, l = i - 2, o = i >> 1; h < o; h += 2) {
          let d = e[h], u = e[h + 1], m = l - h;
          e[h] = e[m], e[h + 1] = e[m + 1], e[m] = d, e[m + 1] = u;
        }
      }
    }, $s = class {
      constructor(t) {
        this.attachmentLoader = null, this.scale = 1, this.linkedMeshes = new Array(), this.attachmentLoader = t;
      }
      readSkeletonData(t) {
        let e = this.scale, i = new pi(), s = typeof t == "string" ? JSON.parse(t) : t, a = s.skeleton;
        if (a && (i.hash = a.hash, i.version = a.spine, i.x = a.x, i.y = a.y, i.width = a.width, i.height = a.height, i.fps = a.fps, i.imagesPath = a.images), s.bones) for (let c = 0; c < s.bones.length; c++) {
          let n = s.bones[c], r = null, h = Y(n, "parent", null);
          h && (r = i.findBone(h));
          let l = new ui(i.bones.length, n.name, r);
          l.length = Y(n, "length", 0) * e, l.x = Y(n, "x", 0) * e, l.y = Y(n, "y", 0) * e, l.rotation = Y(n, "rotation", 0), l.scaleX = Y(n, "scaleX", 1), l.scaleY = Y(n, "scaleY", 1), l.shearX = Y(n, "shearX", 0), l.shearY = Y(n, "shearY", 0), l.transformMode = O.enumValue(Ct, Y(n, "transform", "Normal")), l.skinRequired = Y(n, "skin", false);
          let o = Y(n, "color", null);
          o && l.color.setFromString(o), i.bones.push(l);
        }
        if (s.slots) for (let c = 0; c < s.slots.length; c++) {
          let n = s.slots[c], r = i.findBone(n.bone), h = new vi(i.slots.length, n.name, r), l = Y(n, "color", null);
          l && h.color.setFromString(l);
          let o = Y(n, "dark", null);
          o && (h.darkColor = D.fromString(o)), h.attachmentName = Y(n, "attachment", null), h.blendMode = O.enumValue(wt, Y(n, "blend", "normal")), i.slots.push(h);
        }
        if (s.ik) for (let c = 0; c < s.ik.length; c++) {
          let n = s.ik[c], r = new xi(n.name);
          r.order = Y(n, "order", 0), r.skinRequired = Y(n, "skin", false);
          for (let h = 0; h < n.bones.length; h++) r.bones.push(i.findBone(n.bones[h]));
          r.target = i.findBone(n.target), r.mix = Y(n, "mix", 1), r.softness = Y(n, "softness", 0) * e, r.bendDirection = Y(n, "bendPositive", true) ? 1 : -1, r.compress = Y(n, "compress", false), r.stretch = Y(n, "stretch", false), r.uniform = Y(n, "uniform", false), i.ikConstraints.push(r);
        }
        if (s.transform) for (let c = 0; c < s.transform.length; c++) {
          let n = s.transform[c], r = new yi(n.name);
          r.order = Y(n, "order", 0), r.skinRequired = Y(n, "skin", false);
          for (let l = 0; l < n.bones.length; l++) r.bones.push(i.findBone(n.bones[l]));
          let h = n.target;
          r.target = i.findBone(h), r.local = Y(n, "local", false), r.relative = Y(n, "relative", false), r.offsetRotation = Y(n, "rotation", 0), r.offsetX = Y(n, "x", 0) * e, r.offsetY = Y(n, "y", 0) * e, r.offsetScaleX = Y(n, "scaleX", 0), r.offsetScaleY = Y(n, "scaleY", 0), r.offsetShearY = Y(n, "shearY", 0), r.mixRotate = Y(n, "mixRotate", 1), r.mixX = Y(n, "mixX", 1), r.mixY = Y(n, "mixY", r.mixX), r.mixScaleX = Y(n, "mixScaleX", 1), r.mixScaleY = Y(n, "mixScaleY", r.mixScaleX), r.mixShearY = Y(n, "mixShearY", 1), i.transformConstraints.push(r);
        }
        if (s.path) for (let c = 0; c < s.path.length; c++) {
          let n = s.path[c], r = new bi(n.name);
          r.order = Y(n, "order", 0), r.skinRequired = Y(n, "skin", false);
          for (let l = 0; l < n.bones.length; l++) r.bones.push(i.findBone(n.bones[l]));
          let h = n.target;
          r.target = i.findSlot(h), r.positionMode = O.enumValue(Bt, Y(n, "positionMode", "Percent")), r.spacingMode = O.enumValue(gt, Y(n, "spacingMode", "Length")), r.rotateMode = O.enumValue($t, Y(n, "rotateMode", "Tangent")), r.offsetRotation = Y(n, "rotation", 0), r.position = Y(n, "position", 0), r.positionMode == Bt.Fixed && (r.position *= e), r.spacing = Y(n, "spacing", 0), (r.spacingMode == gt.Length || r.spacingMode == gt.Fixed) && (r.spacing *= e), r.mixRotate = Y(n, "mixRotate", 1), r.mixX = Y(n, "mixX", 1), r.mixY = Y(n, "mixY", r.mixX), i.pathConstraints.push(r);
        }
        if (s.skins) for (let c = 0; c < s.skins.length; c++) {
          let n = s.skins[c], r = new Se(n.name);
          if (n.bones) for (let h = 0; h < n.bones.length; h++) r.bones.push(i.findBone(n.bones[h]));
          if (n.ik) for (let h = 0; h < n.ik.length; h++) r.constraints.push(i.findIkConstraint(n.ik[h]));
          if (n.transform) for (let h = 0; h < n.transform.length; h++) r.constraints.push(i.findTransformConstraint(n.transform[h]));
          if (n.path) for (let h = 0; h < n.path.length; h++) r.constraints.push(i.findPathConstraint(n.path[h]));
          for (let h in n.attachments) {
            let l = i.findSlot(h), o = n.attachments[h];
            for (let d in o) {
              let u = this.readAttachment(o[d], r, l.index, d, i);
              u && r.setAttachment(l.index, d, u);
            }
          }
          i.skins.push(r), r.name == "default" && (i.defaultSkin = r);
        }
        for (let c = 0, n = this.linkedMeshes.length; c < n; c++) {
          let r = this.linkedMeshes[c], l = (r.skin ? i.findSkin(r.skin) : i.defaultSkin).getAttachment(r.slotIndex, r.parent);
          r.mesh.deformAttachment = r.inheritDeform ? l : r.mesh, r.mesh.setParentMesh(l), r.mesh.updateUVs();
        }
        if (this.linkedMeshes.length = 0, s.events) for (let c in s.events) {
          let n = s.events[c], r = new gi(c);
          r.intValue = Y(n, "int", 0), r.floatValue = Y(n, "float", 0), r.stringValue = Y(n, "string", ""), r.audioPath = Y(n, "audio", null), r.audioPath && (r.volume = Y(n, "volume", 1), r.balance = Y(n, "balance", 0)), i.events.push(r);
        }
        if (s.animations) for (let c in s.animations) {
          let n = s.animations[c];
          this.readAnimation(n, c, i);
        }
        return i;
      }
      readAttachment(t, e, i, s, a) {
        let c = this.scale;
        switch (s = Y(t, "name", s), Y(t, "type", "region")) {
          case "region": {
            let n = Y(t, "path", s), r = this.attachmentLoader.newRegionAttachment(e, s, n);
            if (!r) return null;
            r.path = n, r.x = Y(t, "x", 0) * c, r.y = Y(t, "y", 0) * c, r.scaleX = Y(t, "scaleX", 1), r.scaleY = Y(t, "scaleY", 1), r.rotation = Y(t, "rotation", 0), r.width = t.width * c, r.height = t.height * c;
            let h = Y(t, "color", null);
            return h && r.color.setFromString(h), r.updateOffset(), r;
          }
          case "boundingbox": {
            let n = this.attachmentLoader.newBoundingBoxAttachment(e, s);
            if (!n) return null;
            this.readVertices(t, n, t.vertexCount << 1);
            let r = Y(t, "color", null);
            return r && n.color.setFromString(r), n;
          }
          case "mesh":
          case "linkedmesh": {
            let n = Y(t, "path", s), r = this.attachmentLoader.newMeshAttachment(e, s, n);
            if (!r) return null;
            r.path = n;
            let h = Y(t, "color", null);
            h && r.color.setFromString(h), r.width = Y(t, "width", 0) * c, r.height = Y(t, "height", 0) * c;
            let l = Y(t, "parent", null);
            if (l) return this.linkedMeshes.push(new tr(r, Y(t, "skin", null), i, l, Y(t, "deform", true))), r;
            let o = t.uvs;
            return this.readVertices(t, r, o.length), r.triangles = t.triangles, r.regionUVs = o, r.updateUVs(), r.edges = Y(t, "edges", null), r.hullLength = Y(t, "hull", 0) * 2, r;
          }
          case "path": {
            let n = this.attachmentLoader.newPathAttachment(e, s);
            if (!n) return null;
            n.closed = Y(t, "closed", false), n.constantSpeed = Y(t, "constantSpeed", true);
            let r = t.vertexCount;
            this.readVertices(t, n, r << 1);
            let h = O.newArray(r / 3, 0);
            for (let o = 0; o < t.lengths.length; o++) h[o] = t.lengths[o] * c;
            n.lengths = h;
            let l = Y(t, "color", null);
            return l && n.color.setFromString(l), n;
          }
          case "point": {
            let n = this.attachmentLoader.newPointAttachment(e, s);
            if (!n) return null;
            n.x = Y(t, "x", 0) * c, n.y = Y(t, "y", 0) * c, n.rotation = Y(t, "rotation", 0);
            let r = Y(t, "color", null);
            return r && n.color.setFromString(r), n;
          }
          case "clipping": {
            let n = this.attachmentLoader.newClippingAttachment(e, s);
            if (!n) return null;
            let r = Y(t, "end", null);
            r && (n.endSlot = a.findSlot(r));
            let h = t.vertexCount;
            this.readVertices(t, n, h << 1);
            let l = Y(t, "color", null);
            return l && n.color.setFromString(l), n;
          }
        }
        return null;
      }
      readVertices(t, e, i) {
        let s = this.scale;
        e.worldVerticesLength = i;
        let a = t.vertices;
        if (i == a.length) {
          let r = O.toFloatArray(a);
          if (s != 1) for (let h = 0, l = a.length; h < l; h++) r[h] *= s;
          e.vertices = r;
          return;
        }
        let c = new Array(), n = new Array();
        for (let r = 0, h = a.length; r < h; ) {
          let l = a[r++];
          n.push(l);
          for (let o = r + l * 4; r < o; r += 4) n.push(a[r]), c.push(a[r + 1] * s), c.push(a[r + 2] * s), c.push(a[r + 3]);
        }
        e.bones = n, e.vertices = O.toFloatArray(c);
      }
      readAnimation(t, e, i) {
        let s = this.scale, a = new Array();
        if (t.slots) for (let n in t.slots) {
          let r = t.slots[n], h = i.findSlot(n).index;
          for (let l in r) {
            let o = r[l];
            if (!o) continue;
            let d = o.length;
            if (l == "attachment") {
              let u = new Zt(d, h);
              for (let m = 0; m < d; m++) {
                let f = o[m];
                u.setFrame(m, Y(f, "time", 0), f.name);
              }
              a.push(u);
            } else if (l == "rgba") {
              let u = new je(d, d << 2, h), m = o[0], f = Y(m, "time", 0), x = D.fromString(m.color);
              for (let w = 0, v = 0; ; w++) {
                u.setFrame(w, f, x.r, x.g, x.b, x.a);
                let g = o[w + 1];
                if (!g) {
                  u.shrink(v);
                  break;
                }
                let p = Y(g, "time", 0), b = D.fromString(g.color), y = m.curve;
                y && (v = lt(y, u, v, w, 0, f, p, x.r, b.r, 1), v = lt(y, u, v, w, 1, f, p, x.g, b.g, 1), v = lt(y, u, v, w, 2, f, p, x.b, b.b, 1), v = lt(y, u, v, w, 3, f, p, x.a, b.a, 1)), f = p, x = b, m = g;
              }
              a.push(u);
            } else if (l == "rgb") {
              let u = new He(d, d * 3, h), m = o[0], f = Y(m, "time", 0), x = D.fromString(m.color);
              for (let w = 0, v = 0; ; w++) {
                u.setFrame(w, f, x.r, x.g, x.b);
                let g = o[w + 1];
                if (!g) {
                  u.shrink(v);
                  break;
                }
                let p = Y(g, "time", 0), b = D.fromString(g.color), y = m.curve;
                y && (v = lt(y, u, v, w, 0, f, p, x.r, b.r, 1), v = lt(y, u, v, w, 1, f, p, x.g, b.g, 1), v = lt(y, u, v, w, 2, f, p, x.b, b.b, 1)), f = p, x = b, m = g;
              }
              a.push(u);
            } else if (l == "alpha") a.push(Ot(o, new Ze(d, d, h), 0, 1));
            else if (l == "rgba2") {
              let u = new Je(d, d * 7, h), m = o[0], f = Y(m, "time", 0), x = D.fromString(m.light), w = D.fromString(m.dark);
              for (let v = 0, g = 0; ; v++) {
                u.setFrame(v, f, x.r, x.g, x.b, x.a, w.r, w.g, w.b);
                let p = o[v + 1];
                if (!p) {
                  u.shrink(g);
                  break;
                }
                let b = Y(p, "time", 0), y = D.fromString(p.light), T = D.fromString(p.dark), A = m.curve;
                A && (g = lt(A, u, g, v, 0, f, b, x.r, y.r, 1), g = lt(A, u, g, v, 1, f, b, x.g, y.g, 1), g = lt(A, u, g, v, 2, f, b, x.b, y.b, 1), g = lt(A, u, g, v, 3, f, b, x.a, y.a, 1), g = lt(A, u, g, v, 4, f, b, w.r, T.r, 1), g = lt(A, u, g, v, 5, f, b, w.g, T.g, 1), g = lt(A, u, g, v, 6, f, b, w.b, T.b, 1)), f = b, x = y, w = T, m = p;
              }
              a.push(u);
            } else if (l == "rgb2") {
              let u = new Ke(d, d * 6, h), m = o[0], f = Y(m, "time", 0), x = D.fromString(m.light), w = D.fromString(m.dark);
              for (let v = 0, g = 0; ; v++) {
                u.setFrame(v, f, x.r, x.g, x.b, w.r, w.g, w.b);
                let p = o[v + 1];
                if (!p) {
                  u.shrink(g);
                  break;
                }
                let b = Y(p, "time", 0), y = D.fromString(p.light), T = D.fromString(p.dark), A = m.curve;
                A && (g = lt(A, u, g, v, 0, f, b, x.r, y.r, 1), g = lt(A, u, g, v, 1, f, b, x.g, y.g, 1), g = lt(A, u, g, v, 2, f, b, x.b, y.b, 1), g = lt(A, u, g, v, 3, f, b, w.r, T.r, 1), g = lt(A, u, g, v, 4, f, b, w.g, T.g, 1), g = lt(A, u, g, v, 5, f, b, w.b, T.b, 1)), f = b, x = y, w = T, m = p;
              }
              a.push(u);
            }
          }
        }
        if (t.bones) for (let n in t.bones) {
          let r = t.bones[n], h = i.findBone(n).index;
          for (let l in r) {
            let o = r[l], d = o.length;
            if (d != 0) {
              if (l === "rotate") a.push(Ot(o, new de(d, d, h), 0, 1));
              else if (l === "translate") {
                let u = new Ve(d, d << 1, h);
                a.push(Si(o, u, "x", "y", 0, s));
              } else if (l === "translatex") {
                let u = new De(d, d, h);
                a.push(Ot(o, u, 0, s));
              } else if (l === "translatey") {
                let u = new Ne(d, d, h);
                a.push(Ot(o, u, 0, s));
              } else if (l === "scale") {
                let u = new Ue(d, d << 1, h);
                a.push(Si(o, u, "x", "y", 1, 1));
              } else if (l === "scalex") {
                let u = new ze(d, d, h);
                a.push(Ot(o, u, 1, 1));
              } else if (l === "scaley") {
                let u = new We(d, d, h);
                a.push(Ot(o, u, 1, 1));
              } else if (l === "shear") {
                let u = new _e(d, d << 1, h);
                a.push(Si(o, u, "x", "y", 0, 1));
              } else if (l === "shearx") {
                let u = new qe(d, d, h);
                a.push(Ot(o, u, 0, 1));
              } else if (l === "sheary") {
                let u = new Ge(d, d, h);
                a.push(Ot(o, u, 0, 1));
              }
            }
          }
        }
        if (t.ik) for (let n in t.ik) {
          let r = t.ik[n], h = r[0];
          if (!h) continue;
          let l = i.findIkConstraint(n), o = i.ikConstraints.indexOf(l), d = new $e(r.length, r.length << 1, o), u = Y(h, "time", 0), m = Y(h, "mix", 1), f = Y(h, "softness", 0) * s;
          for (let x = 0, w = 0; ; x++) {
            d.setFrame(x, u, m, f, Y(h, "bendPositive", true) ? 1 : -1, Y(h, "compress", false), Y(h, "stretch", false));
            let v = r[x + 1];
            if (!v) {
              d.shrink(w);
              break;
            }
            let g = Y(v, "time", 0), p = Y(v, "mix", 1), b = Y(v, "softness", 0) * s, y = h.curve;
            y && (w = lt(y, d, w, x, 0, u, g, m, p, 1), w = lt(y, d, w, x, 1, u, g, f, b, s)), u = g, m = p, f = b, h = v;
          }
          a.push(d);
        }
        if (t.transform) for (let n in t.transform) {
          let r = t.transform[n], h = r[0];
          if (!h) continue;
          let l = i.findTransformConstraint(n), o = i.transformConstraints.indexOf(l), d = new ti(r.length, r.length * 6, o), u = Y(h, "time", 0), m = Y(h, "mixRotate", 1), f = Y(h, "mixX", 1), x = Y(h, "mixY", f), w = Y(h, "mixScaleX", 1), v = Y(h, "mixScaleY", w), g = Y(h, "mixShearY", 1);
          for (let p = 0, b = 0; ; p++) {
            d.setFrame(p, u, m, f, x, w, v, g);
            let y = r[p + 1];
            if (!y) {
              d.shrink(b);
              break;
            }
            let T = Y(y, "time", 0), A = Y(y, "mixRotate", 1), I = Y(y, "mixX", 1), k = Y(y, "mixY", I), X = Y(y, "mixScaleX", 1), B = Y(y, "mixScaleY", X), L = Y(y, "mixShearY", 1), P = h.curve;
            P && (b = lt(P, d, b, p, 0, u, T, m, A, 1), b = lt(P, d, b, p, 1, u, T, f, I, 1), b = lt(P, d, b, p, 2, u, T, x, k, 1), b = lt(P, d, b, p, 3, u, T, w, X, 1), b = lt(P, d, b, p, 4, u, T, v, B, 1), b = lt(P, d, b, p, 5, u, T, g, L, 1)), u = T, m = A, f = I, x = k, w = X, v = B, w = X, h = y;
          }
          a.push(d);
        }
        if (t.path) for (let n in t.path) {
          let r = t.path[n], h = i.findPathConstraint(n), l = i.pathConstraints.indexOf(h);
          for (let o in r) {
            let d = r[o], u = d[0];
            if (!u) continue;
            let m = d.length;
            if (o === "position") {
              let f = new ei(m, m, l);
              a.push(Ot(d, f, 0, h.positionMode == Bt.Fixed ? s : 1));
            } else if (o === "spacing") {
              let f = new ii(m, m, l);
              a.push(Ot(d, f, 0, h.spacingMode == gt.Length || h.spacingMode == gt.Fixed ? s : 1));
            } else if (o === "mix") {
              let f = new si(m, m * 3, l), x = Y(u, "time", 0), w = Y(u, "mixRotate", 1), v = Y(u, "mixX", 1), g = Y(u, "mixY", v);
              for (let p = 0, b = 0; ; p++) {
                f.setFrame(p, x, w, v, g);
                let y = d[p + 1];
                if (!y) {
                  f.shrink(b);
                  break;
                }
                let T = Y(y, "time", 0), A = Y(y, "mixRotate", 1), I = Y(y, "mixX", 1), k = Y(y, "mixY", I), X = u.curve;
                X && (b = lt(X, f, b, p, 0, x, T, w, A, 1), b = lt(X, f, b, p, 1, x, T, v, I, 1), b = lt(X, f, b, p, 2, x, T, g, k, 1)), x = T, w = A, v = I, g = k, u = y;
              }
              a.push(f);
            }
          }
        }
        if (t.deform) for (let n in t.deform) {
          let r = t.deform[n], h = i.findSkin(n);
          for (let l in r) {
            let o = r[l], d = i.findSlot(l).index;
            for (let u in o) {
              let m = o[u], f = m[0];
              if (!f) continue;
              let x = h.getAttachment(d, u), w = x.bones, v = x.vertices, g = w ? v.length / 3 * 2 : v.length, p = new Qe(m.length, m.length, d, x), b = Y(f, "time", 0);
              for (let y = 0, T = 0; ; y++) {
                let A, I = Y(f, "vertices", null);
                if (!I) A = w ? O.newFloatArray(g) : v;
                else {
                  A = O.newFloatArray(g);
                  let L = Y(f, "offset", 0);
                  if (O.arrayCopy(I, 0, A, L, I.length), s != 1) for (let P = L, C = P + I.length; P < C; P++) A[P] *= s;
                  if (!w) for (let P = 0; P < g; P++) A[P] += v[P];
                }
                p.setFrame(y, b, A);
                let k = m[y + 1];
                if (!k) {
                  p.shrink(T);
                  break;
                }
                let X = Y(k, "time", 0), B = f.curve;
                B && (T = lt(B, p, T, y, 0, b, X, 0, 1, 1)), b = X, f = k;
              }
              a.push(p);
            }
          }
        }
        if (t.drawOrder) {
          let n = new Jt(t.drawOrder.length), r = i.slots.length, h = 0;
          for (let l = 0; l < t.drawOrder.length; l++, h++) {
            let o = t.drawOrder[l], d = null, u = Y(o, "offsets", null);
            if (u) {
              d = O.newArray(r, -1);
              let m = O.newArray(r - u.length, 0), f = 0, x = 0;
              for (let w = 0; w < u.length; w++) {
                let v = u[w], g = i.findSlot(v.slot).index;
                for (; f != g; ) m[x++] = f++;
                d[f + v.offset] = f++;
              }
              for (; f < r; ) m[x++] = f++;
              for (let w = r - 1; w >= 0; w--) d[w] == -1 && (d[w] = m[--x]);
            }
            n.setFrame(h, Y(o, "time", 0), d);
          }
          a.push(n);
        }
        if (t.events) {
          let n = new ue(t.events.length), r = 0;
          for (let h = 0; h < t.events.length; h++, r++) {
            let l = t.events[h], o = i.findEvent(l.name), d = new mi(O.toSinglePrecision(Y(l, "time", 0)), o);
            d.intValue = Y(l, "int", o.intValue), d.floatValue = Y(l, "float", o.floatValue), d.stringValue = Y(l, "string", o.stringValue), d.data.audioPath && (d.volume = Y(l, "volume", 1), d.balance = Y(l, "balance", 0)), n.setFrame(r, d);
          }
          a.push(n);
        }
        let c = 0;
        for (let n = 0, r = a.length; n < r; n++) c = Math.max(c, a[n].getDuration());
        i.animations.push(new be(e, a, c));
      }
    }, tr = class {
      constructor(t, e, i, s, a) {
        this.mesh = t, this.skin = e, this.slotIndex = i, this.parent = s, this.inheritDeform = a;
      }
    };
    function Ot(t, e, i, s) {
      let a = t[0], c = Y(a, "time", 0), n = Y(a, "value", i) * s, r = 0;
      for (let h = 0; ; h++) {
        e.setFrame(h, c, n);
        let l = t[h + 1];
        if (!l) return e.shrink(r), e;
        let o = Y(l, "time", 0), d = Y(l, "value", i) * s;
        a.curve && (r = lt(a.curve, e, r, h, 0, c, o, n, d, s)), c = o, n = d, a = l;
      }
    }
    function Si(t, e, i, s, a, c) {
      let n = t[0], r = Y(n, "time", 0), h = Y(n, i, a) * c, l = Y(n, s, a) * c, o = 0;
      for (let d = 0; ; d++) {
        e.setFrame(d, r, h, l);
        let u = t[d + 1];
        if (!u) return e.shrink(o), e;
        let m = Y(u, "time", 0), f = Y(u, i, a) * c, x = Y(u, s, a) * c, w = n.curve;
        w && (o = lt(w, e, o, d, 0, r, m, h, f, c), o = lt(w, e, o, d, 1, r, m, l, x, c)), r = m, h = f, l = x, n = u;
      }
    }
    function lt(t, e, i, s, a, c, n, r, h, l) {
      if (t == "stepped") return e.setStepped(s), i;
      let o = a << 2, d = t[o], u = t[o + 1] * l, m = t[o + 2], f = t[o + 3] * l;
      return e.setBezier(i, s, a, c, r, d, u, m, f, n, h), i + 1;
    }
    function Y(t, e, i) {
      return t[e] !== void 0 ? t[e] : i;
    }
    (() => {
      typeof Math.fround == "undefined" && (Math.fround = /* @__PURE__ */ (function(t) {
        return function(e) {
          return t[0] = e, t[0];
        };
      })(new Float32Array(1)));
    })();
    var er = class {
      constructor(t, e) {
        this.jitterX = 0, this.jitterY = 0, this.jitterX = t, this.jitterY = e;
      }
      begin(t) {
      }
      transform(t, e, i, s) {
        t.x += F.randomTriangular(-this.jitterX, this.jitterY), t.y += F.randomTriangular(-this.jitterX, this.jitterY);
      }
      end() {
      }
    }, ss = class {
      constructor(t) {
        this.centerX = 0, this.centerY = 0, this.radius = 0, this.angle = 0, this.worldX = 0, this.worldY = 0, this.radius = t;
      }
      begin(t) {
        this.worldX = t.x + this.centerX, this.worldY = t.y + this.centerY;
      }
      transform(t, e, i, s) {
        let a = this.angle * F.degreesToRadians, c = t.x - this.worldX, n = t.y - this.worldY, r = Math.sqrt(c * c + n * n);
        if (r < this.radius) {
          let h = ss.interpolation.apply(0, a, (this.radius - r) / this.radius), l = Math.cos(h), o = Math.sin(h);
          t.x = l * c - o * n + this.worldX, t.y = o * c + l * n + this.worldY;
        }
      }
      end() {
      }
    }, rs = ss;
    rs.interpolation = new Vi(2);
    var vt = class {
      constructor(t, e = { alpha: "true" }) {
        this.restorables = new Array(), t instanceof WebGLRenderingContext || typeof WebGL2RenderingContext != "undefined" && t instanceof WebGL2RenderingContext ? (this.gl = t, this.canvas = this.gl.canvas) : this.setupCanvas(t, e);
      }
      setupCanvas(t, e) {
        this.gl = t.getContext("webgl2", e) || t.getContext("webgl", e), this.canvas = t, t.addEventListener("webglcontextlost", (i) => {
          i && i.preventDefault();
        }), t.addEventListener("webglcontextrestored", (i) => {
          for (let s = 0, a = this.restorables.length; s < a; s++) this.restorables[s].restore();
        });
      }
      addRestorable(t) {
        this.restorables.push(t);
      }
      removeRestorable(t) {
        let e = this.restorables.indexOf(t);
        e > -1 && this.restorables.splice(e, 1);
      }
    }, se = 1, ir = 769, as = 770, Te = 771, sr = 774, Me = class {
      static getDestGLBlendMode(t) {
        switch (t) {
          case wt.Normal:
            return Te;
          case wt.Additive:
            return se;
          case wt.Multiply:
            return Te;
          case wt.Screen:
            return Te;
          default:
            throw new Error("Unknown blend mode: " + t);
        }
      }
      static getSourceColorGLBlendMode(t, e = false) {
        switch (t) {
          case wt.Normal:
            return e ? se : as;
          case wt.Additive:
            return e ? se : as;
          case wt.Multiply:
            return sr;
          case wt.Screen:
            return se;
          default:
            throw new Error("Unknown blend mode: " + t);
        }
      }
      static getSourceAlphaGLBlendMode(t) {
        switch (t) {
          case wt.Normal:
            return se;
          case wt.Additive:
            return se;
          case wt.Multiply:
            return Te;
          case wt.Screen:
            return ir;
          default:
            throw new Error("Unknown blend mode: " + t);
        }
      }
    }, Ci = class extends oi {
      constructor(t, e, i = false) {
        super(e);
        this.texture = null, this.boundUnit = 0, this.useMipMaps = false, this.context = t instanceof vt ? t : new vt(t), this.useMipMaps = i, this.restore(), this.context.addRestorable(this);
      }
      setFilters(t, e) {
        let i = this.context.gl;
        this.bind(), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, t), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, Ci.validateMagFilter(e));
      }
      static validateMagFilter(t) {
        switch (t) {
          case Mt.MipMap:
          case Mt.MipMapLinearLinear:
          case Mt.MipMapLinearNearest:
          case Mt.MipMapNearestLinear:
          case Mt.MipMapNearestNearest:
            return Mt.Linear;
          default:
            return t;
        }
      }
      setWraps(t, e) {
        let i = this.context.gl;
        this.bind(), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, t), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, e);
      }
      update(t) {
        let e = this.context.gl;
        this.texture || (this.texture = this.context.gl.createTexture()), this.bind(), Ci.DISABLE_UNPACK_PREMULTIPLIED_ALPHA_WEBGL && e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, this._image), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t ? e.LINEAR_MIPMAP_LINEAR : e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), t && e.generateMipmap(e.TEXTURE_2D);
      }
      restore() {
        this.texture = null, this.update(this.useMipMaps);
      }
      bind(t = 0) {
        let e = this.context.gl;
        this.boundUnit = t, e.activeTexture(e.TEXTURE0 + t), e.bindTexture(e.TEXTURE_2D, this.texture);
      }
      unbind() {
        let t = this.context.gl;
        t.activeTexture(t.TEXTURE0 + this.boundUnit), t.bindTexture(t.TEXTURE_2D, null);
      }
      dispose() {
        this.context.removeRestorable(this), this.context.gl.deleteTexture(this.texture);
      }
    }, me = Ci;
    me.DISABLE_UNPACK_PREMULTIPLIED_ALPHA_WEBGL = false;
    var ns = class extends Ji {
      constructor(t, e = "", i = null) {
        super((s) => new me(t, s), e, i);
      }
    }, Yt = class {
      constructor(t = 0, e = 0, i = 0) {
        this.x = 0, this.y = 0, this.z = 0, this.x = t, this.y = e, this.z = i;
      }
      setFrom(t) {
        return this.x = t.x, this.y = t.y, this.z = t.z, this;
      }
      set(t, e, i) {
        return this.x = t, this.y = e, this.z = i, this;
      }
      add(t) {
        return this.x += t.x, this.y += t.y, this.z += t.z, this;
      }
      sub(t) {
        return this.x -= t.x, this.y -= t.y, this.z -= t.z, this;
      }
      scale(t) {
        return this.x *= t, this.y *= t, this.z *= t, this;
      }
      normalize() {
        let t = this.length();
        return t == 0 ? this : (t = 1 / t, this.x *= t, this.y *= t, this.z *= t, this);
      }
      cross(t) {
        return this.set(this.y * t.z - this.z * t.y, this.z * t.x - this.x * t.z, this.x * t.y - this.y * t.x);
      }
      multiply(t) {
        let e = t.values;
        return this.set(this.x * e[N] + this.y * e[G] + this.z * e[j] + e[U], this.x * e[H] + this.y * e[z] + this.z * e[Z] + e[W], this.x * e[J] + this.y * e[K] + this.z * e[_] + e[q]);
      }
      project(t) {
        let e = t.values, i = 1 / (this.x * e[$] + this.y * e[tt] + this.z * e[et] + e[Q]);
        return this.set((this.x * e[N] + this.y * e[G] + this.z * e[j] + e[U]) * i, (this.x * e[H] + this.y * e[z] + this.z * e[Z] + e[W]) * i, (this.x * e[J] + this.y * e[K] + this.z * e[_] + e[q]) * i);
      }
      dot(t) {
        return this.x * t.x + this.y * t.y + this.z * t.z;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      }
      distance(t) {
        let e = t.x - this.x, i = t.y - this.y, s = t.z - this.z;
        return Math.sqrt(e * e + i * i + s * s);
      }
    }, N = 0, G = 4, j = 8, U = 12, H = 1, z = 5, Z = 9, W = 13, J = 2, K = 6, _ = 10, q = 14, $ = 3, tt = 7, et = 11, Q = 15, xt = class {
      constructor() {
        this.temp = new Float32Array(16), this.values = new Float32Array(16);
        let t = this.values;
        t[N] = 1, t[z] = 1, t[_] = 1, t[Q] = 1;
      }
      set(t) {
        return this.values.set(t), this;
      }
      transpose() {
        let t = this.temp, e = this.values;
        return t[N] = e[N], t[G] = e[H], t[j] = e[J], t[U] = e[$], t[H] = e[G], t[z] = e[z], t[Z] = e[K], t[W] = e[tt], t[J] = e[j], t[K] = e[Z], t[_] = e[_], t[q] = e[et], t[$] = e[U], t[tt] = e[W], t[et] = e[q], t[Q] = e[Q], this.set(t);
      }
      identity() {
        let t = this.values;
        return t[N] = 1, t[G] = 0, t[j] = 0, t[U] = 0, t[H] = 0, t[z] = 1, t[Z] = 0, t[W] = 0, t[J] = 0, t[K] = 0, t[_] = 1, t[q] = 0, t[$] = 0, t[tt] = 0, t[et] = 0, t[Q] = 1, this;
      }
      invert() {
        let t = this.values, e = this.temp, i = t[$] * t[K] * t[Z] * t[U] - t[J] * t[tt] * t[Z] * t[U] - t[$] * t[z] * t[_] * t[U] + t[H] * t[tt] * t[_] * t[U] + t[J] * t[z] * t[et] * t[U] - t[H] * t[K] * t[et] * t[U] - t[$] * t[K] * t[j] * t[W] + t[J] * t[tt] * t[j] * t[W] + t[$] * t[G] * t[_] * t[W] - t[N] * t[tt] * t[_] * t[W] - t[J] * t[G] * t[et] * t[W] + t[N] * t[K] * t[et] * t[W] + t[$] * t[z] * t[j] * t[q] - t[H] * t[tt] * t[j] * t[q] - t[$] * t[G] * t[Z] * t[q] + t[N] * t[tt] * t[Z] * t[q] + t[H] * t[G] * t[et] * t[q] - t[N] * t[z] * t[et] * t[q] - t[J] * t[z] * t[j] * t[Q] + t[H] * t[K] * t[j] * t[Q] + t[J] * t[G] * t[Z] * t[Q] - t[N] * t[K] * t[Z] * t[Q] - t[H] * t[G] * t[_] * t[Q] + t[N] * t[z] * t[_] * t[Q];
        if (i == 0) throw new Error("non-invertible matrix");
        let s = 1 / i;
        return e[N] = t[Z] * t[q] * t[tt] - t[W] * t[_] * t[tt] + t[W] * t[K] * t[et] - t[z] * t[q] * t[et] - t[Z] * t[K] * t[Q] + t[z] * t[_] * t[Q], e[G] = t[U] * t[_] * t[tt] - t[j] * t[q] * t[tt] - t[U] * t[K] * t[et] + t[G] * t[q] * t[et] + t[j] * t[K] * t[Q] - t[G] * t[_] * t[Q], e[j] = t[j] * t[W] * t[tt] - t[U] * t[Z] * t[tt] + t[U] * t[z] * t[et] - t[G] * t[W] * t[et] - t[j] * t[z] * t[Q] + t[G] * t[Z] * t[Q], e[U] = t[U] * t[Z] * t[K] - t[j] * t[W] * t[K] - t[U] * t[z] * t[_] + t[G] * t[W] * t[_] + t[j] * t[z] * t[q] - t[G] * t[Z] * t[q], e[H] = t[W] * t[_] * t[$] - t[Z] * t[q] * t[$] - t[W] * t[J] * t[et] + t[H] * t[q] * t[et] + t[Z] * t[J] * t[Q] - t[H] * t[_] * t[Q], e[z] = t[j] * t[q] * t[$] - t[U] * t[_] * t[$] + t[U] * t[J] * t[et] - t[N] * t[q] * t[et] - t[j] * t[J] * t[Q] + t[N] * t[_] * t[Q], e[Z] = t[U] * t[Z] * t[$] - t[j] * t[W] * t[$] - t[U] * t[H] * t[et] + t[N] * t[W] * t[et] + t[j] * t[H] * t[Q] - t[N] * t[Z] * t[Q], e[W] = t[j] * t[W] * t[J] - t[U] * t[Z] * t[J] + t[U] * t[H] * t[_] - t[N] * t[W] * t[_] - t[j] * t[H] * t[q] + t[N] * t[Z] * t[q], e[J] = t[z] * t[q] * t[$] - t[W] * t[K] * t[$] + t[W] * t[J] * t[tt] - t[H] * t[q] * t[tt] - t[z] * t[J] * t[Q] + t[H] * t[K] * t[Q], e[K] = t[U] * t[K] * t[$] - t[G] * t[q] * t[$] - t[U] * t[J] * t[tt] + t[N] * t[q] * t[tt] + t[G] * t[J] * t[Q] - t[N] * t[K] * t[Q], e[_] = t[G] * t[W] * t[$] - t[U] * t[z] * t[$] + t[U] * t[H] * t[tt] - t[N] * t[W] * t[tt] - t[G] * t[H] * t[Q] + t[N] * t[z] * t[Q], e[q] = t[U] * t[z] * t[J] - t[G] * t[W] * t[J] - t[U] * t[H] * t[K] + t[N] * t[W] * t[K] + t[G] * t[H] * t[q] - t[N] * t[z] * t[q], e[$] = t[Z] * t[K] * t[$] - t[z] * t[_] * t[$] - t[Z] * t[J] * t[tt] + t[H] * t[_] * t[tt] + t[z] * t[J] * t[et] - t[H] * t[K] * t[et], e[tt] = t[G] * t[_] * t[$] - t[j] * t[K] * t[$] + t[j] * t[J] * t[tt] - t[N] * t[_] * t[tt] - t[G] * t[J] * t[et] + t[N] * t[K] * t[et], e[et] = t[j] * t[z] * t[$] - t[G] * t[Z] * t[$] - t[j] * t[H] * t[tt] + t[N] * t[Z] * t[tt] + t[G] * t[H] * t[et] - t[N] * t[z] * t[et], e[Q] = t[G] * t[Z] * t[J] - t[j] * t[z] * t[J] + t[j] * t[H] * t[K] - t[N] * t[Z] * t[K] - t[G] * t[H] * t[_] + t[N] * t[z] * t[_], t[N] = e[N] * s, t[G] = e[G] * s, t[j] = e[j] * s, t[U] = e[U] * s, t[H] = e[H] * s, t[z] = e[z] * s, t[Z] = e[Z] * s, t[W] = e[W] * s, t[J] = e[J] * s, t[K] = e[K] * s, t[_] = e[_] * s, t[q] = e[q] * s, t[$] = e[$] * s, t[tt] = e[tt] * s, t[et] = e[et] * s, t[Q] = e[Q] * s, this;
      }
      determinant() {
        let t = this.values;
        return t[$] * t[K] * t[Z] * t[U] - t[J] * t[tt] * t[Z] * t[U] - t[$] * t[z] * t[_] * t[U] + t[H] * t[tt] * t[_] * t[U] + t[J] * t[z] * t[et] * t[U] - t[H] * t[K] * t[et] * t[U] - t[$] * t[K] * t[j] * t[W] + t[J] * t[tt] * t[j] * t[W] + t[$] * t[G] * t[_] * t[W] - t[N] * t[tt] * t[_] * t[W] - t[J] * t[G] * t[et] * t[W] + t[N] * t[K] * t[et] * t[W] + t[$] * t[z] * t[j] * t[q] - t[H] * t[tt] * t[j] * t[q] - t[$] * t[G] * t[Z] * t[q] + t[N] * t[tt] * t[Z] * t[q] + t[H] * t[G] * t[et] * t[q] - t[N] * t[z] * t[et] * t[q] - t[J] * t[z] * t[j] * t[Q] + t[H] * t[K] * t[j] * t[Q] + t[J] * t[G] * t[Z] * t[Q] - t[N] * t[K] * t[Z] * t[Q] - t[H] * t[G] * t[_] * t[Q] + t[N] * t[z] * t[_] * t[Q];
      }
      translate(t, e, i) {
        let s = this.values;
        return s[U] += t, s[W] += e, s[q] += i, this;
      }
      copy() {
        return new xt().set(this.values);
      }
      projection(t, e, i, s) {
        this.identity();
        let a = 1 / Math.tan(i * (Math.PI / 180) / 2), c = (e + t) / (t - e), n = 2 * e * t / (t - e), r = this.values;
        return r[N] = a / s, r[H] = 0, r[J] = 0, r[$] = 0, r[G] = 0, r[z] = a, r[K] = 0, r[tt] = 0, r[j] = 0, r[Z] = 0, r[_] = c, r[et] = -1, r[U] = 0, r[W] = 0, r[q] = n, r[Q] = 0, this;
      }
      ortho2d(t, e, i, s) {
        return this.ortho(t, t + i, e, e + s, 0, 1);
      }
      ortho(t, e, i, s, a, c) {
        this.identity();
        let n = 2 / (e - t), r = 2 / (s - i), h = -2 / (c - a), l = -(e + t) / (e - t), o = -(s + i) / (s - i), d = -(c + a) / (c - a), u = this.values;
        return u[N] = n, u[H] = 0, u[J] = 0, u[$] = 0, u[G] = 0, u[z] = r, u[K] = 0, u[tt] = 0, u[j] = 0, u[Z] = 0, u[_] = h, u[et] = 0, u[U] = l, u[W] = o, u[q] = d, u[Q] = 1, this;
      }
      multiply(t) {
        let e = this.temp, i = this.values, s = t.values;
        return e[N] = i[N] * s[N] + i[G] * s[H] + i[j] * s[J] + i[U] * s[$], e[G] = i[N] * s[G] + i[G] * s[z] + i[j] * s[K] + i[U] * s[tt], e[j] = i[N] * s[j] + i[G] * s[Z] + i[j] * s[_] + i[U] * s[et], e[U] = i[N] * s[U] + i[G] * s[W] + i[j] * s[q] + i[U] * s[Q], e[H] = i[H] * s[N] + i[z] * s[H] + i[Z] * s[J] + i[W] * s[$], e[z] = i[H] * s[G] + i[z] * s[z] + i[Z] * s[K] + i[W] * s[tt], e[Z] = i[H] * s[j] + i[z] * s[Z] + i[Z] * s[_] + i[W] * s[et], e[W] = i[H] * s[U] + i[z] * s[W] + i[Z] * s[q] + i[W] * s[Q], e[J] = i[J] * s[N] + i[K] * s[H] + i[_] * s[J] + i[q] * s[$], e[K] = i[J] * s[G] + i[K] * s[z] + i[_] * s[K] + i[q] * s[tt], e[_] = i[J] * s[j] + i[K] * s[Z] + i[_] * s[_] + i[q] * s[et], e[q] = i[J] * s[U] + i[K] * s[W] + i[_] * s[q] + i[q] * s[Q], e[$] = i[$] * s[N] + i[tt] * s[H] + i[et] * s[J] + i[Q] * s[$], e[tt] = i[$] * s[G] + i[tt] * s[z] + i[et] * s[K] + i[Q] * s[tt], e[et] = i[$] * s[j] + i[tt] * s[Z] + i[et] * s[_] + i[Q] * s[et], e[Q] = i[$] * s[U] + i[tt] * s[W] + i[et] * s[q] + i[Q] * s[Q], this.set(this.temp);
      }
      multiplyLeft(t) {
        let e = this.temp, i = this.values, s = t.values;
        return e[N] = s[N] * i[N] + s[G] * i[H] + s[j] * i[J] + s[U] * i[$], e[G] = s[N] * i[G] + s[G] * i[z] + s[j] * i[K] + s[U] * i[tt], e[j] = s[N] * i[j] + s[G] * i[Z] + s[j] * i[_] + s[U] * i[et], e[U] = s[N] * i[U] + s[G] * i[W] + s[j] * i[q] + s[U] * i[Q], e[H] = s[H] * i[N] + s[z] * i[H] + s[Z] * i[J] + s[W] * i[$], e[z] = s[H] * i[G] + s[z] * i[z] + s[Z] * i[K] + s[W] * i[tt], e[Z] = s[H] * i[j] + s[z] * i[Z] + s[Z] * i[_] + s[W] * i[et], e[W] = s[H] * i[U] + s[z] * i[W] + s[Z] * i[q] + s[W] * i[Q], e[J] = s[J] * i[N] + s[K] * i[H] + s[_] * i[J] + s[q] * i[$], e[K] = s[J] * i[G] + s[K] * i[z] + s[_] * i[K] + s[q] * i[tt], e[_] = s[J] * i[j] + s[K] * i[Z] + s[_] * i[_] + s[q] * i[et], e[q] = s[J] * i[U] + s[K] * i[W] + s[_] * i[q] + s[q] * i[Q], e[$] = s[$] * i[N] + s[tt] * i[H] + s[et] * i[J] + s[Q] * i[$], e[tt] = s[$] * i[G] + s[tt] * i[z] + s[et] * i[K] + s[Q] * i[tt], e[et] = s[$] * i[j] + s[tt] * i[Z] + s[et] * i[_] + s[Q] * i[et], e[Q] = s[$] * i[U] + s[tt] * i[W] + s[et] * i[q] + s[Q] * i[Q], this.set(this.temp);
      }
      lookAt(t, e, i) {
        xt.initTemps();
        let s = xt.xAxis, a = xt.yAxis, c = xt.zAxis;
        c.setFrom(e).normalize(), s.setFrom(e).normalize(), s.cross(i).normalize(), a.setFrom(s).cross(c).normalize(), this.identity();
        let n = this.values;
        return n[N] = s.x, n[G] = s.y, n[j] = s.z, n[H] = a.x, n[z] = a.y, n[Z] = a.z, n[J] = -c.x, n[K] = -c.y, n[_] = -c.z, xt.tmpMatrix.identity(), xt.tmpMatrix.values[U] = -t.x, xt.tmpMatrix.values[W] = -t.y, xt.tmpMatrix.values[q] = -t.z, this.multiply(xt.tmpMatrix), this;
      }
      static initTemps() {
        xt.xAxis === null && (xt.xAxis = new Yt()), xt.yAxis === null && (xt.yAxis = new Yt()), xt.zAxis === null && (xt.zAxis = new Yt());
      }
    }, Wt = xt;
    Wt.xAxis = null, Wt.yAxis = null, Wt.zAxis = null, Wt.tmpMatrix = new xt();
    var ls = class {
      constructor(t, e) {
        this.position = new Yt(0, 0, 0), this.direction = new Yt(0, 0, -1), this.up = new Yt(0, 1, 0), this.near = 0, this.far = 100, this.zoom = 1, this.viewportWidth = 0, this.viewportHeight = 0, this.projectionView = new Wt(), this.inverseProjectionView = new Wt(), this.projection = new Wt(), this.view = new Wt(), this.viewportWidth = t, this.viewportHeight = e, this.update();
      }
      update() {
        let t = this.projection, e = this.view, i = this.projectionView, s = this.inverseProjectionView, a = this.zoom, c = this.viewportWidth, n = this.viewportHeight;
        t.ortho(a * (-c / 2), a * (c / 2), a * (-n / 2), a * (n / 2), this.near, this.far), e.lookAt(this.position, this.direction, this.up), i.set(t.values), i.multiply(e), s.set(i.values).invert();
      }
      screenToWorld(t, e, i) {
        let s = t.x, a = i - t.y - 1;
        return t.x = 2 * s / e - 1, t.y = 2 * a / i - 1, t.z = 2 * t.z - 1, t.project(this.inverseProjectionView), t;
      }
      worldToScreen(t, e, i) {
        return t.project(this.projectionView), t.x = e * (t.x + 1) / 2, t.y = i * (t.y + 1) / 2, t.z = (t.z + 1) / 2, t;
      }
      setViewport(t, e) {
        this.viewportWidth = t, this.viewportHeight = e;
      }
    }, Ti = class {
      constructor(t) {
        this.mouseX = 0, this.mouseY = 0, this.buttonDown = false, this.touch0 = null, this.touch1 = null, this.initialPinchDistance = 0, this.listeners = new Array(), this.eventListeners = [], this.element = t, this.setupCallbacks(t);
      }
      setupCallbacks(t) {
        let e = (n) => {
          if (n instanceof MouseEvent) {
            let r = t.getBoundingClientRect();
            this.mouseX = n.clientX - r.left, this.mouseY = n.clientY - r.top, this.buttonDown = true, this.listeners.map((h) => {
              h.down && h.down(this.mouseX, this.mouseY);
            }), document.addEventListener("mousemove", i), document.addEventListener("mouseup", s);
          }
        }, i = (n) => {
          if (n instanceof MouseEvent) {
            let r = t.getBoundingClientRect();
            this.mouseX = n.clientX - r.left, this.mouseY = n.clientY - r.top, this.listeners.map((h) => {
              this.buttonDown ? h.dragged && h.dragged(this.mouseX, this.mouseY) : h.moved && h.moved(this.mouseX, this.mouseY);
            });
          }
        }, s = (n) => {
          if (n instanceof MouseEvent) {
            let r = t.getBoundingClientRect();
            this.mouseX = n.clientX - r.left, this.mouseY = n.clientY - r.top, this.buttonDown = false, this.listeners.map((h) => {
              h.up && h.up(this.mouseX, this.mouseY);
            }), document.removeEventListener("mousemove", i), document.removeEventListener("mouseup", s);
          }
        }, a = (n) => {
          n.preventDefault();
          let r = n.deltaY;
          n.deltaMode == WheelEvent.DOM_DELTA_LINE && (r *= 8), n.deltaMode == WheelEvent.DOM_DELTA_PAGE && (r *= 24), this.listeners.map((h) => {
            h.wheel && h.wheel(n.deltaY);
          });
        };
        t.addEventListener("mousedown", e, true), t.addEventListener("mousemove", i, true), t.addEventListener("mouseup", s, true), t.addEventListener("wheel", a, true), t.addEventListener("touchstart", (n) => {
          if (!this.touch0 || !this.touch1) {
            var r = n.changedTouches;
            let h = r.item(0), l = t.getBoundingClientRect(), o = h.clientX - l.left, d = h.clientY - l.top, u = new hs(h.identifier, o, d);
            if (this.mouseX = o, this.mouseY = d, this.buttonDown = true, !this.touch0) this.touch0 = u, this.listeners.map((m) => {
              m.down && m.down(u.x, u.y);
            });
            else if (!this.touch1) {
              this.touch1 = u;
              let m = this.touch1.x - this.touch0.x, f = this.touch1.x - this.touch0.x;
              this.initialPinchDistance = Math.sqrt(m * m + f * f), this.listeners.map((x) => {
                x.zoom && x.zoom(this.initialPinchDistance, this.initialPinchDistance);
              });
            }
          }
          n.preventDefault();
        }, false), t.addEventListener("touchmove", (n) => {
          if (this.touch0) {
            var r = n.changedTouches;
            let o = t.getBoundingClientRect();
            for (var h = 0; h < r.length; h++) {
              var l = r[h];
              let d = l.clientX - o.left, u = l.clientY - o.top;
              this.touch0.identifier === l.identifier && (this.touch0.x = this.mouseX = d, this.touch0.y = this.mouseY = u, this.listeners.map((m) => {
                m.dragged && m.dragged(d, u);
              })), this.touch1 && this.touch1.identifier === l.identifier && (this.touch1.x = this.mouseX = d, this.touch1.y = this.mouseY = u);
            }
            if (this.touch0 && this.touch1) {
              let d = this.touch1.x - this.touch0.x, u = this.touch1.x - this.touch0.x, m = Math.sqrt(d * d + u * u);
              this.listeners.map((f) => {
                f.zoom && f.zoom(this.initialPinchDistance, m);
              });
            }
          }
          n.preventDefault();
        }, false);
        let c = (n) => {
          if (this.touch0) {
            var r = n.changedTouches;
            let o = t.getBoundingClientRect();
            for (var h = 0; h < r.length; h++) {
              var l = r[h];
              let d = l.clientX - o.left, u = l.clientY - o.top;
              if (this.touch0.identifier === l.identifier) if (this.touch0 = null, this.mouseX = d, this.mouseY = u, this.listeners.map((m) => {
                m.up && m.up(d, u);
              }), this.touch1) this.touch0 = this.touch1, this.touch1 = null, this.mouseX = this.touch0.x, this.mouseX = this.touch0.x, this.buttonDown = true, this.listeners.map((m) => {
                m.down && m.down(this.touch0.x, this.touch0.y);
              });
              else {
                this.buttonDown = false;
                break;
              }
              this.touch1 && this.touch1.identifier && (this.touch1 = null);
            }
          }
          n.preventDefault();
        };
        t.addEventListener("touchend", c, false), t.addEventListener("touchcancel", c);
      }
      addListener(t) {
        this.listeners.push(t);
      }
      removeListener(t) {
        let e = this.listeners.indexOf(t);
        e > -1 && this.listeners.splice(e, 1);
      }
    }, hs = class {
      constructor(t, e, i) {
        this.identifier = t, this.x = e, this.y = i;
      }
    }, rr = class {
      constructor(t, e) {
        this.canvas = t, this.camera = e;
        let i = 0, s = 0, c = 0, n = 0, r = 0, h = 0, l = 0;
        new Ti(t).addListener({ down: (o, d) => {
          i = e.position.x, s = e.position.y, c = r = o, n = h = d, l = e.zoom;
        }, dragged: (o, d) => {
          let u = o - c, m = d - n, f = e.screenToWorld(new Yt(0, 0), t.clientWidth, t.clientHeight), x = e.screenToWorld(new Yt(u, m), t.clientWidth, t.clientHeight).sub(f);
          e.position.set(i - x.x, s - x.y, 0), e.update(), r = o, h = d;
        }, wheel: (o) => {
          let d = o / 200 * e.zoom, u = e.zoom + d;
          if (u > 0) {
            let m = 0, f = 0;
            if (o < 0) m = r, f = h;
            else {
              let v = new Yt(t.clientWidth / 2 + 15, t.clientHeight / 2), g = r - v.x, p = t.clientHeight - 1 - h - v.y;
              m = v.x - g, f = t.clientHeight - 1 - v.y + p;
            }
            let x = e.screenToWorld(new Yt(m, f), t.clientWidth, t.clientHeight);
            e.zoom = u, e.update();
            let w = e.screenToWorld(new Yt(m, f), t.clientWidth, t.clientHeight);
            e.position.add(x.sub(w)), e.update();
          }
        }, zoom: (o, d) => {
          let u = o / d;
          e.zoom = l * u;
        }, up: (o, d) => {
          r = o, h = d;
        }, moved: (o, d) => {
          r = o, h = d;
        } });
      }
    }, ut = class {
      constructor(t, e, i) {
        this.vertexShader = e, this.fragmentShader = i, this.vs = null, this.fs = null, this.program = null, this.tmp2x2 = new Float32Array(2 * 2), this.tmp3x3 = new Float32Array(3 * 3), this.tmp4x4 = new Float32Array(4 * 4), this.vsSource = e, this.fsSource = i, this.context = t instanceof vt ? t : new vt(t), this.context.addRestorable(this), this.compile();
      }
      getProgram() {
        return this.program;
      }
      getVertexShader() {
        return this.vertexShader;
      }
      getFragmentShader() {
        return this.fragmentShader;
      }
      getVertexShaderSource() {
        return this.vsSource;
      }
      getFragmentSource() {
        return this.fsSource;
      }
      compile() {
        let t = this.context.gl;
        try {
          this.vs = this.compileShader(t.VERTEX_SHADER, this.vertexShader), this.fs = this.compileShader(t.FRAGMENT_SHADER, this.fragmentShader), this.program = this.compileProgram(this.vs, this.fs);
        } catch (e) {
          throw this.dispose(), e;
        }
      }
      compileShader(t, e) {
        let i = this.context.gl, s = i.createShader(t);
        if (i.shaderSource(s, e), i.compileShader(s), !i.getShaderParameter(s, i.COMPILE_STATUS)) {
          let a = "Couldn't compile shader: " + i.getShaderInfoLog(s);
          if (i.deleteShader(s), !i.isContextLost()) throw new Error(a);
        }
        return s;
      }
      compileProgram(t, e) {
        let i = this.context.gl, s = i.createProgram();
        if (i.attachShader(s, t), i.attachShader(s, e), i.linkProgram(s), !i.getProgramParameter(s, i.LINK_STATUS)) {
          let a = "Couldn't compile shader program: " + i.getProgramInfoLog(s);
          if (i.deleteProgram(s), !i.isContextLost()) throw new Error(a);
        }
        return s;
      }
      restore() {
        this.compile();
      }
      bind() {
        this.context.gl.useProgram(this.program);
      }
      unbind() {
        this.context.gl.useProgram(null);
      }
      setUniformi(t, e) {
        this.context.gl.uniform1i(this.getUniformLocation(t), e);
      }
      setUniformf(t, e) {
        this.context.gl.uniform1f(this.getUniformLocation(t), e);
      }
      setUniform2f(t, e, i) {
        this.context.gl.uniform2f(this.getUniformLocation(t), e, i);
      }
      setUniform3f(t, e, i, s) {
        this.context.gl.uniform3f(this.getUniformLocation(t), e, i, s);
      }
      setUniform4f(t, e, i, s, a) {
        this.context.gl.uniform4f(this.getUniformLocation(t), e, i, s, a);
      }
      setUniform2x2f(t, e) {
        let i = this.context.gl;
        this.tmp2x2.set(e), i.uniformMatrix2fv(this.getUniformLocation(t), false, this.tmp2x2);
      }
      setUniform3x3f(t, e) {
        let i = this.context.gl;
        this.tmp3x3.set(e), i.uniformMatrix3fv(this.getUniformLocation(t), false, this.tmp3x3);
      }
      setUniform4x4f(t, e) {
        let i = this.context.gl;
        this.tmp4x4.set(e), i.uniformMatrix4fv(this.getUniformLocation(t), false, this.tmp4x4);
      }
      getUniformLocation(t) {
        let e = this.context.gl, i = e.getUniformLocation(this.program, t);
        if (!i && !e.isContextLost()) throw new Error(`Couldn't find location for uniform ${t}`);
        return i;
      }
      getAttributeLocation(t) {
        let e = this.context.gl, i = e.getAttribLocation(this.program, t);
        if (i == -1 && !e.isContextLost()) throw new Error(`Couldn't find location for attribute ${t}`);
        return i;
      }
      dispose() {
        this.context.removeRestorable(this);
        let t = this.context.gl;
        this.vs && (t.deleteShader(this.vs), this.vs = null), this.fs && (t.deleteShader(this.fs), this.fs = null), this.program && (t.deleteProgram(this.program), this.program = null);
      }
      static newColoredTextured(t) {
        let e = `
				attribute vec4 ${ut.POSITION};
				attribute vec4 ${ut.COLOR};
				attribute vec2 ${ut.TEXCOORDS};
				uniform mat4 ${ut.MVP_MATRIX};
				varying vec4 v_color;
				varying vec2 v_texCoords;

				void main () {
					v_color = ${ut.COLOR};
					v_texCoords = ${ut.TEXCOORDS};
					gl_Position = ${ut.MVP_MATRIX} * ${ut.POSITION};
				}
			`, i = `
				#ifdef GL_ES
					#define LOWP lowp
					precision mediump float;
				#else
					#define LOWP
				#endif
				varying LOWP vec4 v_color;
				varying vec2 v_texCoords;
				uniform sampler2D u_texture;

				void main () {
					gl_FragColor = v_color * texture2D(u_texture, v_texCoords);
				}
			`;
        return new ut(t, e, i);
      }
      static newTwoColoredTextured(t) {
        let e = `
				attribute vec4 ${ut.POSITION};
				attribute vec4 ${ut.COLOR};
				attribute vec4 ${ut.COLOR2};
				attribute vec2 ${ut.TEXCOORDS};
				uniform mat4 ${ut.MVP_MATRIX};
				varying vec4 v_light;
				varying vec4 v_dark;
				varying vec2 v_texCoords;

				void main () {
					v_light = ${ut.COLOR};
					v_dark = ${ut.COLOR2};
					v_texCoords = ${ut.TEXCOORDS};
					gl_Position = ${ut.MVP_MATRIX} * ${ut.POSITION};
				}
			`, i = `
				#ifdef GL_ES
					#define LOWP lowp
					precision mediump float;
				#else
					#define LOWP
				#endif
				varying LOWP vec4 v_light;
				varying LOWP vec4 v_dark;
				varying vec2 v_texCoords;
				uniform sampler2D u_texture;

				void main () {
					vec4 texColor = texture2D(u_texture, v_texCoords);
					gl_FragColor.a = texColor.a * v_light.a;
					gl_FragColor.rgb = ((texColor.a - 1.0) * v_dark.a + 1.0 - texColor.rgb) * v_dark.rgb + texColor.rgb * v_light.rgb;
				}
			`;
        return new ut(t, e, i);
      }
      static newColored(t) {
        let e = `
				attribute vec4 ${ut.POSITION};
				attribute vec4 ${ut.COLOR};
				uniform mat4 ${ut.MVP_MATRIX};
				varying vec4 v_color;

				void main () {
					v_color = ${ut.COLOR};
					gl_Position = ${ut.MVP_MATRIX} * ${ut.POSITION};
				}
			`, i = `
				#ifdef GL_ES
					#define LOWP lowp
					precision mediump float;
				#else
					#define LOWP
				#endif
				varying LOWP vec4 v_color;

				void main () {
					gl_FragColor = v_color;
				}
			`;
        return new ut(t, e, i);
      }
    }, bt = ut;
    bt.MVP_MATRIX = "u_projTrans", bt.POSITION = "a_position", bt.COLOR = "a_color", bt.COLOR2 = "a_color2", bt.TEXCOORDS = "a_texCoords", bt.SAMPLER = "u_texture";
    var Mi = class {
      constructor(t, e, i, s) {
        this.attributes = e, this.verticesLength = 0, this.dirtyVertices = false, this.indicesLength = 0, this.dirtyIndices = false, this.elementsPerVertex = 0, this.context = t instanceof vt ? t : new vt(t), this.elementsPerVertex = 0;
        for (let a = 0; a < e.length; a++) this.elementsPerVertex += e[a].numElements;
        this.vertices = new Float32Array(i * this.elementsPerVertex), this.indices = new Uint16Array(s), this.context.addRestorable(this);
      }
      getAttributes() {
        return this.attributes;
      }
      maxVertices() {
        return this.vertices.length / this.elementsPerVertex;
      }
      numVertices() {
        return this.verticesLength / this.elementsPerVertex;
      }
      setVerticesLength(t) {
        this.dirtyVertices = true, this.verticesLength = t;
      }
      getVertices() {
        return this.vertices;
      }
      maxIndices() {
        return this.indices.length;
      }
      numIndices() {
        return this.indicesLength;
      }
      setIndicesLength(t) {
        this.dirtyIndices = true, this.indicesLength = t;
      }
      getIndices() {
        return this.indices;
      }
      getVertexSizeInFloats() {
        let t = 0;
        for (var e = 0; e < this.attributes.length; e++) t += this.attributes[e].numElements;
        return t;
      }
      setVertices(t) {
        if (this.dirtyVertices = true, t.length > this.vertices.length) throw Error("Mesh can't store more than " + this.maxVertices() + " vertices");
        this.vertices.set(t, 0), this.verticesLength = t.length;
      }
      setIndices(t) {
        if (this.dirtyIndices = true, t.length > this.indices.length) throw Error("Mesh can't store more than " + this.maxIndices() + " indices");
        this.indices.set(t, 0), this.indicesLength = t.length;
      }
      draw(t, e) {
        this.drawWithOffset(t, e, 0, this.indicesLength > 0 ? this.indicesLength : this.verticesLength / this.elementsPerVertex);
      }
      drawWithOffset(t, e, i, s) {
        let a = this.context.gl;
        (this.dirtyVertices || this.dirtyIndices) && this.update(), this.bind(t), this.indicesLength > 0 ? a.drawElements(e, s, a.UNSIGNED_SHORT, i * 2) : a.drawArrays(e, i, s), this.unbind(t);
      }
      bind(t) {
        let e = this.context.gl;
        e.bindBuffer(e.ARRAY_BUFFER, this.verticesBuffer);
        let i = 0;
        for (let s = 0; s < this.attributes.length; s++) {
          let a = this.attributes[s], c = t.getAttributeLocation(a.name);
          e.enableVertexAttribArray(c), e.vertexAttribPointer(c, a.numElements, e.FLOAT, false, this.elementsPerVertex * 4, i * 4), i += a.numElements;
        }
        this.indicesLength > 0 && e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);
      }
      unbind(t) {
        let e = this.context.gl;
        for (let i = 0; i < this.attributes.length; i++) {
          let s = this.attributes[i], a = t.getAttributeLocation(s.name);
          e.disableVertexAttribArray(a);
        }
        e.bindBuffer(e.ARRAY_BUFFER, null), this.indicesLength > 0 && e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, null);
      }
      update() {
        let t = this.context.gl;
        this.dirtyVertices && (this.verticesBuffer || (this.verticesBuffer = t.createBuffer()), t.bindBuffer(t.ARRAY_BUFFER, this.verticesBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertices.subarray(0, this.verticesLength), t.DYNAMIC_DRAW), this.dirtyVertices = false), this.dirtyIndices && (this.indicesBuffer || (this.indicesBuffer = t.createBuffer()), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indicesBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices.subarray(0, this.indicesLength), t.DYNAMIC_DRAW), this.dirtyIndices = false);
      }
      restore() {
        this.verticesBuffer = null, this.indicesBuffer = null, this.update();
      }
      dispose() {
        this.context.removeRestorable(this);
        let t = this.context.gl;
        t.deleteBuffer(this.verticesBuffer), t.deleteBuffer(this.indicesBuffer);
      }
    }, re = class {
      constructor(t, e, i) {
        this.name = t, this.type = e, this.numElements = i;
      }
    }, Ye = class extends re {
      constructor() {
        super(bt.POSITION, qt.Float, 2);
      }
    }, ar = class extends re {
      constructor() {
        super(bt.POSITION, qt.Float, 3);
      }
    }, Yi = class extends re {
      constructor(t = 0) {
        super(bt.TEXCOORDS + (t == 0 ? "" : t), qt.Float, 2);
      }
    }, Ie = class extends re {
      constructor() {
        super(bt.COLOR, qt.Float, 4);
      }
    }, os = class extends re {
      constructor() {
        super(bt.COLOR2, qt.Float, 4);
      }
    }, qt;
    (function(t) {
      t[t.Float = 0] = "Float";
    })(qt || (qt = {}));
    var Ii = class {
      constructor(t, e = true, i = 10920) {
        if (this.isDrawing = false, this.shader = null, this.lastTexture = null, this.verticesLength = 0, this.indicesLength = 0, i > 10920) throw new Error("Can't have more than 10920 triangles per batch: " + i);
        this.context = t instanceof vt ? t : new vt(t);
        let s = e ? [new Ye(), new Ie(), new Yi(), new os()] : [new Ye(), new Ie(), new Yi()];
        this.mesh = new Mi(t, s, i, i * 3);
        let a = this.context.gl;
        this.srcColorBlend = a.SRC_ALPHA, this.srcAlphaBlend = a.ONE, this.dstBlend = a.ONE_MINUS_SRC_ALPHA;
      }
      begin(t) {
        if (this.isDrawing) throw new Error("PolygonBatch is already drawing. Call PolygonBatch.end() before calling PolygonBatch.begin()");
        this.drawCalls = 0, this.shader = t, this.lastTexture = null, this.isDrawing = true;
        let e = this.context.gl;
        e.enable(e.BLEND), e.blendFuncSeparate(this.srcColorBlend, this.dstBlend, this.srcAlphaBlend, this.dstBlend);
      }
      setBlendMode(t, e, i) {
        this.srcColorBlend == t && this.srcAlphaBlend == e && this.dstBlend == i || (this.srcColorBlend = t, this.srcAlphaBlend = e, this.dstBlend = i, this.isDrawing && (this.flush(), this.context.gl.blendFuncSeparate(t, i, e, i)));
      }
      draw(t, e, i) {
        t != this.lastTexture ? (this.flush(), this.lastTexture = t) : (this.verticesLength + e.length > this.mesh.getVertices().length || this.indicesLength + i.length > this.mesh.getIndices().length) && this.flush();
        let s = this.mesh.numVertices();
        this.mesh.getVertices().set(e, this.verticesLength), this.verticesLength += e.length, this.mesh.setVerticesLength(this.verticesLength);
        let a = this.mesh.getIndices();
        for (let c = this.indicesLength, n = 0; n < i.length; c++, n++) a[c] = i[n] + s;
        this.indicesLength += i.length, this.mesh.setIndicesLength(this.indicesLength);
      }
      flush() {
        this.verticesLength != 0 && (this.lastTexture.bind(), this.mesh.draw(this.shader, this.context.gl.TRIANGLES), this.verticesLength = 0, this.indicesLength = 0, this.mesh.setVerticesLength(0), this.mesh.setIndicesLength(0), this.drawCalls++);
      }
      end() {
        if (!this.isDrawing) throw new Error("PolygonBatch is not drawing. Call PolygonBatch.begin() before calling PolygonBatch.end()");
        (this.verticesLength > 0 || this.indicesLength > 0) && this.flush(), this.shader = null, this.lastTexture = null, this.isDrawing = false;
        let t = this.context.gl;
        t.disable(t.BLEND);
      }
      getDrawCalls() {
        return this.drawCalls;
      }
      dispose() {
        this.mesh.dispose();
      }
    }, ki = class {
      constructor(t, e = 10920) {
        if (this.isDrawing = false, this.shapeType = yt.Filled, this.color = new D(1, 1, 1, 1), this.vertexIndex = 0, this.tmp = new Ht(), e > 10920) throw new Error("Can't have more than 10920 triangles per batch: " + e);
        this.context = t instanceof vt ? t : new vt(t), this.mesh = new Mi(t, [new Ye(), new Ie()], e, 0);
        let i = this.context.gl;
        this.srcColorBlend = i.SRC_ALPHA, this.srcAlphaBlend = i.ONE, this.dstBlend = i.ONE_MINUS_SRC_ALPHA;
      }
      begin(t) {
        if (this.isDrawing) throw new Error("ShapeRenderer.begin() has already been called");
        this.shader = t, this.vertexIndex = 0, this.isDrawing = true;
        let e = this.context.gl;
        e.enable(e.BLEND), e.blendFuncSeparate(this.srcColorBlend, this.dstBlend, this.srcAlphaBlend, this.dstBlend);
      }
      setBlendMode(t, e, i) {
        this.srcColorBlend = t, this.srcAlphaBlend = e, this.dstBlend = i, this.isDrawing && (this.flush(), this.context.gl.blendFuncSeparate(t, i, e, i));
      }
      setColor(t) {
        this.color.setFromColor(t);
      }
      setColorWith(t, e, i, s) {
        this.color.set(t, e, i, s);
      }
      point(t, e, i = null) {
        this.check(yt.Point, 1), i === null && (i = this.color), this.vertex(t, e, i);
      }
      line(t, e, i, s, a = null) {
        this.check(yt.Line, 2);
        this.mesh.getVertices(); this.vertexIndex;
        a === null && (a = this.color), this.vertex(t, e, a), this.vertex(i, s, a);
      }
      triangle(t, e, i, s, a, c, n, r = null, h = null, l = null) {
        this.check(t ? yt.Filled : yt.Line, 3);
        this.mesh.getVertices(); this.vertexIndex;
        r === null && (r = this.color), h === null && (h = this.color), l === null && (l = this.color), t ? (this.vertex(e, i, r), this.vertex(s, a, h), this.vertex(c, n, l)) : (this.vertex(e, i, r), this.vertex(s, a, h), this.vertex(s, a, r), this.vertex(c, n, h), this.vertex(c, n, r), this.vertex(e, i, h));
      }
      quad(t, e, i, s, a, c, n, r, h, l = null, o = null, d = null, u = null) {
        this.check(t ? yt.Filled : yt.Line, 3);
        this.mesh.getVertices(); this.vertexIndex;
        l === null && (l = this.color), o === null && (o = this.color), d === null && (d = this.color), u === null && (u = this.color), t ? (this.vertex(e, i, l), this.vertex(s, a, o), this.vertex(c, n, d), this.vertex(c, n, d), this.vertex(r, h, u), this.vertex(e, i, l)) : (this.vertex(e, i, l), this.vertex(s, a, o), this.vertex(s, a, o), this.vertex(c, n, d), this.vertex(c, n, d), this.vertex(r, h, u), this.vertex(r, h, u), this.vertex(e, i, l));
      }
      rect(t, e, i, s, a, c = null) {
        this.quad(t, e, i, e + s, i, e + s, i + a, e, i + a, c, c, c, c);
      }
      rectLine(t, e, i, s, a, c, n = null) {
        this.check(t ? yt.Filled : yt.Line, 8), n === null && (n = this.color);
        let r = this.tmp.set(a - i, e - s);
        r.normalize(), c *= 0.5;
        let h = r.x * c, l = r.y * c;
        t ? (this.vertex(e + h, i + l, n), this.vertex(e - h, i - l, n), this.vertex(s + h, a + l, n), this.vertex(s - h, a - l, n), this.vertex(s + h, a + l, n), this.vertex(e - h, i - l, n)) : (this.vertex(e + h, i + l, n), this.vertex(e - h, i - l, n), this.vertex(s + h, a + l, n), this.vertex(s - h, a - l, n), this.vertex(s + h, a + l, n), this.vertex(e + h, i + l, n), this.vertex(s - h, a - l, n), this.vertex(e - h, i - l, n));
      }
      x(t, e, i) {
        this.line(t - i, e - i, t + i, e + i), this.line(t - i, e + i, t + i, e - i);
      }
      polygon(t, e, i, s = null) {
        if (i < 3) throw new Error("Polygon must contain at least 3 vertices");
        this.check(yt.Line, i * 2), s === null && (s = this.color);
        this.mesh.getVertices(); this.vertexIndex;
        e <<= 1, i <<= 1;
        let n = t[e], r = t[e + 1], h = e + i;
        for (let l = e, o = e + i - 2; l < o; l += 2) {
          let d = t[l], u = t[l + 1], m = 0, f = 0;
          l + 2 >= h ? (m = n, f = r) : (m = t[l + 2], f = t[l + 3]), this.vertex(d, u, s), this.vertex(m, f, s);
        }
      }
      circle(t, e, i, s, a = null, c = 0) {
        if (c === 0 && (c = Math.max(1, 6 * F.cbrt(s) | 0)), c <= 0) throw new Error("segments must be > 0.");
        a === null && (a = this.color);
        let n = 2 * F.PI / c, r = Math.cos(n), h = Math.sin(n), l = s, o = 0;
        if (t) {
          this.check(yt.Filled, c * 3 + 3), c--;
          for (let u = 0; u < c; u++) {
            this.vertex(e, i, a), this.vertex(e + l, i + o, a);
            let m = l;
            l = r * l - h * o, o = h * m + r * o, this.vertex(e + l, i + o, a);
          }
          this.vertex(e, i, a), this.vertex(e + l, i + o, a);
        } else {
          this.check(yt.Line, c * 2 + 2);
          for (let u = 0; u < c; u++) {
            this.vertex(e + l, i + o, a);
            let m = l;
            l = r * l - h * o, o = h * m + r * o, this.vertex(e + l, i + o, a);
          }
          this.vertex(e + l, i + o, a);
        }
        l = s, o = 0, this.vertex(e + l, i + o, a);
      }
      curve(t, e, i, s, a, c, n, r, h, l = null) {
        this.check(yt.Line, h * 2 + 2), l === null && (l = this.color);
        let o = 1 / h, d = o * o, u = o * o * o, m = 3 * o, f = 3 * d, x = 6 * d, w = 6 * u, v = t - i * 2 + a, g = e - s * 2 + c, p = (i - a) * 3 - t + n, b = (s - c) * 3 - e + r, y = t, T = e, A = (i - t) * m + v * f + p * u, I = (s - e) * m + g * f + b * u, k = v * x + p * w, X = g * x + b * w, B = p * w, L = b * w;
        for (; h-- > 0; ) this.vertex(y, T, l), y += A, T += I, A += k, I += X, k += B, X += L, this.vertex(y, T, l);
        this.vertex(y, T, l), this.vertex(n, r, l);
      }
      vertex(t, e, i) {
        let s = this.vertexIndex, a = this.mesh.getVertices();
        a[s++] = t, a[s++] = e, a[s++] = i.r, a[s++] = i.g, a[s++] = i.b, a[s++] = i.a, this.vertexIndex = s;
      }
      end() {
        if (!this.isDrawing) throw new Error("ShapeRenderer.begin() has not been called");
        this.flush();
        let t = this.context.gl;
        t.disable(t.BLEND), this.isDrawing = false;
      }
      flush() {
        this.vertexIndex != 0 && (this.mesh.setVerticesLength(this.vertexIndex), this.mesh.draw(this.shader, this.shapeType), this.vertexIndex = 0);
      }
      check(t, e) {
        if (!this.isDrawing) throw new Error("ShapeRenderer.begin() has not been called");
        if (this.shapeType == t) if (this.mesh.maxVertices() - this.mesh.numVertices() < e) this.flush();
        else return;
        else this.flush(), this.shapeType = t;
      }
      dispose() {
        this.mesh.dispose();
      }
    }, yt;
    (function(t) {
      t[t.Point = 0] = "Point", t[t.Line = 1] = "Line", t[t.Filled = 4] = "Filled";
    })(yt || (yt = {}));
    var ke = class {
      constructor(t) {
        this.boneLineColor = new D(1, 0, 0, 1), this.boneOriginColor = new D(0, 1, 0, 1), this.attachmentLineColor = new D(0, 0, 1, 0.5), this.triangleLineColor = new D(1, 0.64, 0, 0.5), this.pathColor = new D().setFromString("FF7F00"), this.clipColor = new D(0.8, 0, 0, 2), this.aabbColor = new D(0, 1, 0, 0.5), this.drawBones = true, this.drawRegionAttachments = true, this.drawBoundingBoxes = true, this.drawMeshHull = true, this.drawMeshTriangles = true, this.drawPaths = true, this.drawSkeletonXY = false, this.drawClipping = true, this.premultipliedAlpha = false, this.scale = 1, this.boneWidth = 2, this.bounds = new is(), this.temp = new Array(), this.vertices = O.newFloatArray(2 * 1024), this.context = t instanceof vt ? t : new vt(t);
      }
      draw(t, e, i = null) {
        let s = e.x, a = e.y, c = this.context.gl, n = this.premultipliedAlpha ? c.ONE : c.SRC_ALPHA;
        t.setBlendMode(n, c.ONE, c.ONE_MINUS_SRC_ALPHA);
        let r = e.bones;
        if (this.drawBones) {
          t.setColor(this.boneLineColor);
          for (let h = 0, l = r.length; h < l; h++) {
            let o = r[h];
            if (i && i.indexOf(o.data.name) > -1 || !o.parent) continue;
            let d = s + o.data.length * o.a + o.worldX, u = a + o.data.length * o.c + o.worldY;
            t.rectLine(true, s + o.worldX, a + o.worldY, d, u, this.boneWidth * this.scale);
          }
          this.drawSkeletonXY && t.x(s, a, 4 * this.scale);
        }
        if (this.drawRegionAttachments) {
          t.setColor(this.attachmentLineColor);
          let h = e.slots;
          for (let l = 0, o = h.length; l < o; l++) {
            let d = h[l], u = d.getAttachment();
            if (u instanceof at) {
              let m = u, f = this.vertices;
              m.computeWorldVertices(d.bone, f, 0, 2), t.line(f[0], f[1], f[2], f[3]), t.line(f[2], f[3], f[4], f[5]), t.line(f[4], f[5], f[6], f[7]), t.line(f[6], f[7], f[0], f[1]);
            }
          }
        }
        if (this.drawMeshHull || this.drawMeshTriangles) {
          let h = e.slots;
          for (let l = 0, o = h.length; l < o; l++) {
            let d = h[l];
            if (!d.bone.active) continue;
            let u = d.getAttachment();
            if (!(u instanceof _t)) continue;
            let m = u, f = this.vertices;
            m.computeWorldVertices(d, 0, m.worldVerticesLength, f, 0, 2);
            let x = m.triangles, w = m.hullLength;
            if (this.drawMeshTriangles) {
              t.setColor(this.triangleLineColor);
              for (let v = 0, g = x.length; v < g; v += 3) {
                let p = x[v] * 2, b = x[v + 1] * 2, y = x[v + 2] * 2;
                t.triangle(false, f[p], f[p + 1], f[b], f[b + 1], f[y], f[y + 1]);
              }
            }
            if (this.drawMeshHull && w > 0) {
              t.setColor(this.attachmentLineColor), w = (w >> 1) * 2;
              let v = f[w - 2], g = f[w - 1];
              for (let p = 0, b = w; p < b; p += 2) {
                let y = f[p], T = f[p + 1];
                t.line(y, T, v, g), v = y, g = T;
              }
            }
          }
        }
        if (this.drawBoundingBoxes) {
          let h = this.bounds;
          h.update(e, true), t.setColor(this.aabbColor), t.rect(false, h.minX, h.minY, h.getWidth(), h.getHeight());
          let l = h.polygons, o = h.boundingBoxes;
          for (let d = 0, u = l.length; d < u; d++) {
            let m = l[d];
            t.setColor(o[d].color), t.polygon(m, 0, m.length);
          }
        }
        if (this.drawPaths) {
          let h = e.slots;
          for (let l = 0, o = h.length; l < o; l++) {
            let d = h[l];
            if (!d.bone.active) continue;
            let u = d.getAttachment();
            if (!(u instanceof Qt)) continue;
            let m = u, f = m.worldVerticesLength, x = this.temp = O.setArraySize(this.temp, f, 0);
            m.computeWorldVertices(d, 0, f, x, 0, 2);
            let w = this.pathColor, v = x[2], g = x[3], p = 0, b = 0;
            if (m.closed) {
              t.setColor(w);
              let y = x[0], T = x[1], A = x[f - 2], I = x[f - 1];
              p = x[f - 4], b = x[f - 3], t.curve(v, g, y, T, A, I, p, b, 32), t.setColor(ke.LIGHT_GRAY), t.line(v, g, y, T), t.line(p, b, A, I);
            }
            f -= 4;
            for (let y = 4; y < f; y += 6) {
              let T = x[y], A = x[y + 1], I = x[y + 2], k = x[y + 3];
              p = x[y + 4], b = x[y + 5], t.setColor(w), t.curve(v, g, T, A, I, k, p, b, 32), t.setColor(ke.LIGHT_GRAY), t.line(v, g, T, A), t.line(p, b, I, k), v = p, g = b;
            }
          }
        }
        if (this.drawBones) {
          t.setColor(this.boneOriginColor);
          for (let h = 0, l = r.length; h < l; h++) {
            let o = r[h];
            i && i.indexOf(o.data.name) > -1 || t.circle(true, s + o.worldX, a + o.worldY, 3 * this.scale, ke.GREEN, 8);
          }
        }
        if (this.drawClipping) {
          let h = e.slots;
          t.setColor(this.clipColor);
          for (let l = 0, o = h.length; l < o; l++) {
            let d = h[l];
            if (!d.bone.active) continue;
            let u = d.getAttachment();
            if (!(u instanceof fe)) continue;
            let m = u, f = m.worldVerticesLength, x = this.temp = O.setArraySize(this.temp, f, 0);
            m.computeWorldVertices(d, 0, f, x, 0, 2);
            for (let w = 0, v = x.length; w < v; w += 2) {
              let g = x[w], p = x[w + 1], b = x[(w + 2) % x.length], y = x[(w + 3) % x.length];
              t.line(g, p, b, y);
            }
          }
        }
      }
      dispose() {
      }
    }, Xe = ke;
    Xe.LIGHT_GRAY = new D(192 / 255, 192 / 255, 192 / 255, 1), Xe.GREEN = new D(0, 1, 0, 1);
    var nr = class {
      constructor(t, e, i) {
        this.vertices = t, this.numVertices = e, this.numFloats = i;
      }
    }, cs = class {
      constructor(t, e = true) {
        this.premultipliedAlpha = false, this.vertexEffect = null, this.tempColor = new D(), this.tempColor2 = new D(), this.vertexSize = 2 + 2 + 4, this.twoColorTint = false, this.renderable = new nr(null, 0, 0), this.clipper = new Ce(), this.temp = new Ht(), this.temp2 = new Ht(), this.temp3 = new D(), this.temp4 = new D(), this.twoColorTint = e, e && (this.vertexSize += 4), this.vertices = O.newFloatArray(this.vertexSize * 1024);
      }
      draw(t, e, i = -1, s = -1) {
        let a = this.clipper, c = this.premultipliedAlpha, n = this.twoColorTint, r = null, h = this.temp, l = this.temp2, o = this.temp3, d = this.temp4, u = this.renderable, m = null, f = null, x = e.drawOrder, w = null, v = e.color, g = n ? 12 : 8, p = false;
        i == -1 && (p = true);
        for (let b = 0, y = x.length; b < y; b++) {
          let T = a.isClipping() ? 2 : g, A = x[b];
          if (!A.bone.active) {
            a.clipEndWithSlot(A);
            continue;
          }
          if (i >= 0 && i == A.data.index && (p = true), !p) {
            a.clipEndWithSlot(A);
            continue;
          }
          s >= 0 && s == A.data.index && (p = false);
          let I = A.getAttachment(), k = null;
          if (I instanceof at) {
            let X = I;
            u.vertices = this.vertices, u.numVertices = 4, u.numFloats = T << 2, X.computeWorldVertices(A.bone, u.vertices, 0, T), f = cs.QUAD_TRIANGLES, m = X.uvs, k = X.region.renderObject.page.texture, w = X.color;
          } else if (I instanceof _t) {
            let X = I;
            u.vertices = this.vertices, u.numVertices = X.worldVerticesLength >> 1, u.numFloats = u.numVertices * T, u.numFloats > u.vertices.length && (u.vertices = this.vertices = O.newFloatArray(u.numFloats)), X.computeWorldVertices(A, 0, X.worldVerticesLength, u.vertices, 0, T), f = X.triangles, k = X.region.renderObject.page.texture, m = X.uvs, w = X.color;
          } else if (I instanceof fe) {
            let X = I;
            a.clipStart(A, X);
            continue;
          } else {
            a.clipEndWithSlot(A);
            continue;
          }
          if (k) {
            let X = A.color, B = this.tempColor;
            B.r = v.r * X.r * w.r, B.g = v.g * X.g * w.g, B.b = v.b * X.b * w.b, B.a = v.a * X.a * w.a, c && (B.r *= B.a, B.g *= B.a, B.b *= B.a);
            let L = this.tempColor2;
            A.darkColor ? (c ? (L.r = A.darkColor.r * B.a, L.g = A.darkColor.g * B.a, L.b = A.darkColor.b * B.a) : L.setFromColor(A.darkColor), L.a = c ? 1 : 0) : L.set(0, 0, 0, 1);
            let P = A.data.blendMode;
            if (P != r && (r = P, t.setBlendMode(Me.getSourceColorGLBlendMode(r, c), Me.getSourceAlphaGLBlendMode(r), Me.getDestGLBlendMode(r))), a.isClipping()) {
              a.clipTriangles(u.vertices, u.numFloats, f, f.length, m, B, L, n);
              let C = new Float32Array(a.clippedVertices), M = a.clippedTriangles;
              if (this.vertexEffect) {
                let V = this.vertexEffect, R = C;
                if (n) for (let E = 0, st = C.length; E < st; E += g) h.x = R[E], h.y = R[E + 1], o.set(R[E + 2], R[E + 3], R[E + 4], R[E + 5]), l.x = R[E + 6], l.y = R[E + 7], d.set(R[E + 8], R[E + 9], R[E + 10], R[E + 11]), V.transform(h, l, o, d), R[E] = h.x, R[E + 1] = h.y, R[E + 2] = o.r, R[E + 3] = o.g, R[E + 4] = o.b, R[E + 5] = o.a, R[E + 6] = l.x, R[E + 7] = l.y, R[E + 8] = d.r, R[E + 9] = d.g, R[E + 10] = d.b, R[E + 11] = d.a;
                else for (let E = 0, st = C.length; E < st; E += g) h.x = R[E], h.y = R[E + 1], o.set(R[E + 2], R[E + 3], R[E + 4], R[E + 5]), l.x = R[E + 6], l.y = R[E + 7], d.set(0, 0, 0, 0), V.transform(h, l, o, d), R[E] = h.x, R[E + 1] = h.y, R[E + 2] = o.r, R[E + 3] = o.g, R[E + 4] = o.b, R[E + 5] = o.a, R[E + 6] = l.x, R[E + 7] = l.y;
              }
              t.draw(k, C, M);
            } else {
              let C = u.vertices;
              if (this.vertexEffect) {
                let V = this.vertexEffect;
                if (n) for (let R = 0, E = 0, st = u.numFloats; R < st; R += g, E += 2) h.x = C[R], h.y = C[R + 1], l.x = m[E], l.y = m[E + 1], o.setFromColor(B), d.setFromColor(L), V.transform(h, l, o, d), C[R] = h.x, C[R + 1] = h.y, C[R + 2] = o.r, C[R + 3] = o.g, C[R + 4] = o.b, C[R + 5] = o.a, C[R + 6] = l.x, C[R + 7] = l.y, C[R + 8] = d.r, C[R + 9] = d.g, C[R + 10] = d.b, C[R + 11] = d.a;
                else for (let R = 0, E = 0, st = u.numFloats; R < st; R += g, E += 2) h.x = C[R], h.y = C[R + 1], l.x = m[E], l.y = m[E + 1], o.setFromColor(B), d.set(0, 0, 0, 0), V.transform(h, l, o, d), C[R] = h.x, C[R + 1] = h.y, C[R + 2] = o.r, C[R + 3] = o.g, C[R + 4] = o.b, C[R + 5] = o.a, C[R + 6] = l.x, C[R + 7] = l.y;
              } else if (n) for (let V = 2, R = 0, E = u.numFloats; V < E; V += g, R += 2) C[V] = B.r, C[V + 1] = B.g, C[V + 2] = B.b, C[V + 3] = B.a, C[V + 4] = m[R], C[V + 5] = m[R + 1], C[V + 6] = L.r, C[V + 7] = L.g, C[V + 8] = L.b, C[V + 9] = L.a;
              else for (let V = 2, R = 0, E = u.numFloats; V < E; V += g, R += 2) C[V] = B.r, C[V + 1] = B.g, C[V + 2] = B.b, C[V + 3] = B.a, C[V + 4] = m[R], C[V + 5] = m[R + 1];
              let M = u.vertices.subarray(0, u.numFloats);
              t.draw(k, M, f);
            }
          }
          a.clipEndWithSlot(A);
        }
        a.clipEnd();
      }
    }, Xi = cs;
    Xi.QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0];
    var S = [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0], Re = [0, 1, 2, 2, 3, 0], Ee = new D(1, 1, 1, 1), ds = class {
      constructor(t, e, i = true) {
        this.twoColorTint = false, this.canvas = t, this.context = e instanceof vt ? e : new vt(e), this.twoColorTint = i, this.camera = new ls(t.width, t.height), this.batcherShader = i ? bt.newTwoColoredTextured(this.context) : bt.newColoredTextured(this.context), this.batcher = new Ii(this.context, i), this.shapesShader = bt.newColored(this.context), this.shapes = new ki(this.context), this.skeletonRenderer = new Xi(this.context, i), this.skeletonDebugRenderer = new Xe(this.context);
      }
      dispose() {
        this.batcher.dispose(), this.batcherShader.dispose(), this.shapes.dispose(), this.shapesShader.dispose(), this.skeletonDebugRenderer.dispose();
      }
      begin() {
        this.camera.update(), this.enableRenderer(this.batcher);
      }
      drawSkeleton(t, e = false, i = -1, s = -1) {
        this.enableRenderer(this.batcher), this.skeletonRenderer.premultipliedAlpha = e, this.skeletonRenderer.draw(this.batcher, t, i, s);
      }
      drawSkeletonDebug(t, e = false, i = null) {
        this.enableRenderer(this.shapes), this.skeletonDebugRenderer.premultipliedAlpha = e, this.skeletonDebugRenderer.draw(this.shapes, t, i);
      }
      drawTexture(t, e, i, s, a, c = null) {
        this.enableRenderer(this.batcher), c === null && (c = Ee);
        var n = 0;
        S[n++] = e, S[n++] = i, S[n++] = c.r, S[n++] = c.g, S[n++] = c.b, S[n++] = c.a, S[n++] = 0, S[n++] = 1, this.twoColorTint && (S[n++] = 0, S[n++] = 0, S[n++] = 0, S[n++] = 0), S[n++] = e + s, S[n++] = i, S[n++] = c.r, S[n++] = c.g, S[n++] = c.b, S[n++] = c.a, S[n++] = 1, S[n++] = 1, this.twoColorTint && (S[n++] = 0, S[n++] = 0, S[n++] = 0, S[n++] = 0), S[n++] = e + s, S[n++] = i + a, S[n++] = c.r, S[n++] = c.g, S[n++] = c.b, S[n++] = c.a, S[n++] = 1, S[n++] = 0, this.twoColorTint && (S[n++] = 0, S[n++] = 0, S[n++] = 0, S[n++] = 0), S[n++] = e, S[n++] = i + a, S[n++] = c.r, S[n++] = c.g, S[n++] = c.b, S[n++] = c.a, S[n++] = 0, S[n++] = 0, this.twoColorTint && (S[n++] = 0, S[n++] = 0, S[n++] = 0, S[n] = 0), this.batcher.draw(t, S, Re);
      }
      drawTextureUV(t, e, i, s, a, c, n, r, h, l = null) {
        this.enableRenderer(this.batcher), l === null && (l = Ee);
        var o = 0;
        S[o++] = e, S[o++] = i, S[o++] = l.r, S[o++] = l.g, S[o++] = l.b, S[o++] = l.a, S[o++] = c, S[o++] = n, this.twoColorTint && (S[o++] = 0, S[o++] = 0, S[o++] = 0, S[o++] = 0), S[o++] = e + s, S[o++] = i, S[o++] = l.r, S[o++] = l.g, S[o++] = l.b, S[o++] = l.a, S[o++] = r, S[o++] = n, this.twoColorTint && (S[o++] = 0, S[o++] = 0, S[o++] = 0, S[o++] = 0), S[o++] = e + s, S[o++] = i + a, S[o++] = l.r, S[o++] = l.g, S[o++] = l.b, S[o++] = l.a, S[o++] = r, S[o++] = h, this.twoColorTint && (S[o++] = 0, S[o++] = 0, S[o++] = 0, S[o++] = 0), S[o++] = e, S[o++] = i + a, S[o++] = l.r, S[o++] = l.g, S[o++] = l.b, S[o++] = l.a, S[o++] = c, S[o++] = h, this.twoColorTint && (S[o++] = 0, S[o++] = 0, S[o++] = 0, S[o] = 0), this.batcher.draw(t, S, Re);
      }
      drawTextureRotated(t, e, i, s, a, c, n, r, h = null) {
        this.enableRenderer(this.batcher), h === null && (h = Ee);
        let l = e + c, o = i + n, d = -c, u = -n, m = s - c, f = a - n, x = d, w = u, v = d, g = f, p = m, b = f, y = m, T = u, A = 0, I = 0, k = 0, X = 0, B = 0, L = 0, P = 0, C = 0;
        if (r != 0) {
          let V = F.cosDeg(r), R = F.sinDeg(r);
          A = V * x - R * w, I = R * x + V * w, P = V * v - R * g, C = R * v + V * g, B = V * p - R * b, L = R * p + V * b, k = B + (A - P), X = L + (I - C);
        } else A = x, I = w, P = v, C = g, B = p, L = b, k = y, X = T;
        A += l, I += o, k += l, X += o, B += l, L += o, P += l, C += o;
        var M = 0;
        S[M++] = A, S[M++] = I, S[M++] = h.r, S[M++] = h.g, S[M++] = h.b, S[M++] = h.a, S[M++] = 0, S[M++] = 1, this.twoColorTint && (S[M++] = 0, S[M++] = 0, S[M++] = 0, S[M++] = 0), S[M++] = k, S[M++] = X, S[M++] = h.r, S[M++] = h.g, S[M++] = h.b, S[M++] = h.a, S[M++] = 1, S[M++] = 1, this.twoColorTint && (S[M++] = 0, S[M++] = 0, S[M++] = 0, S[M++] = 0), S[M++] = B, S[M++] = L, S[M++] = h.r, S[M++] = h.g, S[M++] = h.b, S[M++] = h.a, S[M++] = 1, S[M++] = 0, this.twoColorTint && (S[M++] = 0, S[M++] = 0, S[M++] = 0, S[M++] = 0), S[M++] = P, S[M++] = C, S[M++] = h.r, S[M++] = h.g, S[M++] = h.b, S[M++] = h.a, S[M++] = 0, S[M++] = 0, this.twoColorTint && (S[M++] = 0, S[M++] = 0, S[M++] = 0, S[M] = 0), this.batcher.draw(t, S, Re);
      }
      drawRegion(t, e, i, s, a, c = null) {
        this.enableRenderer(this.batcher), c === null && (c = Ee);
        var n = 0;
        S[n++] = e, S[n++] = i, S[n++] = c.r, S[n++] = c.g, S[n++] = c.b, S[n++] = c.a, S[n++] = t.u, S[n++] = t.v2, this.twoColorTint && (S[n++] = 0, S[n++] = 0, S[n++] = 0, S[n++] = 0), S[n++] = e + s, S[n++] = i, S[n++] = c.r, S[n++] = c.g, S[n++] = c.b, S[n++] = c.a, S[n++] = t.u2, S[n++] = t.v2, this.twoColorTint && (S[n++] = 0, S[n++] = 0, S[n++] = 0, S[n++] = 0), S[n++] = e + s, S[n++] = i + a, S[n++] = c.r, S[n++] = c.g, S[n++] = c.b, S[n++] = c.a, S[n++] = t.u2, S[n++] = t.v, this.twoColorTint && (S[n++] = 0, S[n++] = 0, S[n++] = 0, S[n++] = 0), S[n++] = e, S[n++] = i + a, S[n++] = c.r, S[n++] = c.g, S[n++] = c.b, S[n++] = c.a, S[n++] = t.u, S[n++] = t.v, this.twoColorTint && (S[n++] = 0, S[n++] = 0, S[n++] = 0, S[n] = 0), this.batcher.draw(t.page.texture, S, Re);
      }
      line(t, e, i, s, a = null, c = null) {
        this.enableRenderer(this.shapes), this.shapes.line(t, e, i, s, a);
      }
      triangle(t, e, i, s, a, c, n, r = null, h = null, l = null) {
        this.enableRenderer(this.shapes), this.shapes.triangle(t, e, i, s, a, c, n, r, h, l);
      }
      quad(t, e, i, s, a, c, n, r, h, l = null, o = null, d = null, u = null) {
        this.enableRenderer(this.shapes), this.shapes.quad(t, e, i, s, a, c, n, r, h, l, o, d, u);
      }
      rect(t, e, i, s, a, c = null) {
        this.enableRenderer(this.shapes), this.shapes.rect(t, e, i, s, a, c);
      }
      rectLine(t, e, i, s, a, c, n = null) {
        this.enableRenderer(this.shapes), this.shapes.rectLine(t, e, i, s, a, c, n);
      }
      polygon(t, e, i, s = null) {
        this.enableRenderer(this.shapes), this.shapes.polygon(t, e, i, s);
      }
      circle(t, e, i, s, a = null, c = 0) {
        this.enableRenderer(this.shapes), this.shapes.circle(t, e, i, s, a, c);
      }
      curve(t, e, i, s, a, c, n, r, h, l = null) {
        this.enableRenderer(this.shapes), this.shapes.curve(t, e, i, s, a, c, n, r, h, l);
      }
      end() {
        this.activeRenderer === this.batcher ? this.batcher.end() : this.activeRenderer === this.shapes && this.shapes.end(), this.activeRenderer = null;
      }
      resize(t) {
        let e = this.canvas;
        var i = window.devicePixelRatio || 1, s = Math.round(e.clientWidth * i), a = Math.round(e.clientHeight * i);
        if ((e.width != s || e.height != a) && (e.width = s, e.height = a), this.context.gl.viewport(0, 0, e.width, e.height), t === ae.Expand) this.camera.setViewport(s, a);
        else if (t === ae.Fit) {
          let c = e.width, n = e.height, r = this.camera.viewportWidth, h = this.camera.viewportHeight, l = h / r, o = n / c, d = l < o ? r / c : h / n;
          this.camera.setViewport(c * d, n * d);
        }
        this.camera.update();
      }
      enableRenderer(t) {
        this.activeRenderer !== t && (this.end(), t instanceof Ii ? (this.batcherShader.bind(), this.batcherShader.setUniform4x4f(bt.MVP_MATRIX, this.camera.projectionView.values), this.batcherShader.setUniformi("u_texture", 0), this.batcher.begin(this.batcherShader), this.activeRenderer = this.batcher) : t instanceof ki ? (this.shapesShader.bind(), this.shapesShader.setUniform4x4f(bt.MVP_MATRIX, this.camera.projectionView.values), this.shapes.begin(this.shapesShader), this.activeRenderer = this.shapes) : this.activeRenderer = this.skeletonDebugRenderer);
      }
    }, ae;
    (function(t) {
      t[t.Stretch = 0] = "Stretch", t[t.Expand = 1] = "Expand", t[t.Fit = 2] = "Fit";
    })(ae || (ae = {}));
    var ge, ne, us = 0, lr = 1, Ri = 1, fs = 165, ms = 108, te = 163, hr = class {
      constructor(t) {
        if (this.logo = null, this.spinner = null, this.angle = 0, this.fadeOut = 0, this.fadeIn = 0, this.timeKeeper = new Be(), this.backgroundColor = new D(0.135, 0.135, 0.135, 1), this.tempColor = new D(), this.renderer = t, this.timeKeeper.maxDelta = 9, !ne) {
          let e = navigator.userAgent.indexOf("Safari") > -1, i = () => us++;
          ne = new Image(), ne.src = cr, e || (ne.crossOrigin = "anonymous"), ne.onload = i, ge = new Image(), ge.src = or, e || (ge.crossOrigin = "anonymous"), ge.onload = i;
        }
      }
      dispose() {
        var t, e;
        (t = this.logo) == null || t.dispose(), (e = this.spinner) == null || e.dispose();
      }
      draw(t = false) {
        if (us < 2 || t && this.fadeOut > Ri) return;
        this.timeKeeper.update();
        let e = Math.abs(Math.sin(this.timeKeeper.totalTime + 0.25));
        this.angle -= this.timeKeeper.delta * 200 * (1 + 1.5 * Math.pow(e, 5));
        let i = this.tempColor, s = this.renderer, a = s.canvas, c = s.context.gl;
        if (s.resize(ae.Expand), s.camera.position.set(a.width / 2, a.height / 2, 0), s.batcher.setBlendMode(c.ONE, c.ONE, c.ONE_MINUS_SRC_ALPHA), t) {
          if (this.fadeOut += this.timeKeeper.delta * (this.timeKeeper.totalTime < 1 ? 2 : 1), this.fadeOut > Ri) return;
          i.setFromColor(this.backgroundColor), e = 1 - this.fadeOut / Ri, e = 1 - (e - 1) * (e - 1), i.a *= e, i.a > 0 && (s.camera.zoom = 1, s.begin(), s.quad(true, 0, 0, a.width, 0, a.width, a.height, 0, a.height, i, i, i, i), s.end());
        } else this.fadeIn += this.timeKeeper.delta, this.backgroundColor.a > 0 && (c.clearColor(this.backgroundColor.r, this.backgroundColor.g, this.backgroundColor.b, this.backgroundColor.a), c.clear(c.COLOR_BUFFER_BIT)), e = 1;
        e *= Math.min(this.fadeIn / lr, 1), i.set(e, e, e, e), this.logo || (this.logo = new me(s.context, ne), this.spinner = new me(s.context, ge)), s.camera.zoom = Math.max(1, te / a.height), s.begin(), s.drawTexture(this.logo, (a.width - fs) / 2, (a.height - ms) / 2, fs, ms, i), s.drawTextureRotated(this.spinner, (a.width - te) / 2, (a.height - te) / 2, te, te, te / 2, te / 2, this.angle, i), s.end();
      }
    }, or = "data:image/png;base64,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", cr = "data:image/png;base64,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", dr = class {
      constructor(t, e) {
        this.time = new Be(), e.pathPrefix === void 0 && (e.pathPrefix = ""), e.app === void 0 && (e.app = { loadAssets: () => {
        }, initialize: () => {
        }, update: () => {
        }, render: () => {
        }, error: () => {
        } }), e.webglConfig === void 0 && (e.webglConfig = { alpha: true }), this.htmlCanvas = t, this.context = new vt(t, e.webglConfig), this.renderer = new ds(t, this.context), this.gl = this.context.gl, this.assetManager = new ns(this.context, e.pathPrefix), this.input = new Ti(t), e.app.loadAssets(this);
        let i = () => {
          requestAnimationFrame(i), this.time.update(), e.app.update(this, this.time.delta), e.app.render(this);
        }, s = () => {
          if (this.assetManager.isLoadingComplete()) {
            this.assetManager.hasErrors() ? e.app.error(this, this.assetManager.getErrors()) : (e.app.initialize(this), i());
            return;
          }
          requestAnimationFrame(s);
        };
        requestAnimationFrame(s);
      }
      clear(t, e, i, s) {
        this.gl.clearColor(t, e, i, s), this.gl.clear(this.gl.COLOR_BUFFER_BIT);
      }
    };
    return Pi;
  })();
  var spine_webgl_default2 = spine2;

  // src/spine/4.2/spine-webgl.js
  var spine3 = (() => {
    var Ie = Object.defineProperty, Hi = Object.getOwnPropertyDescriptor, _i = Object.getOwnPropertyNames, ji = Object.prototype.hasOwnProperty, Zi = (e, t) => {
      for (var s in t) Ie(e, s, { get: t[s], enumerable: true });
    }, Ki = (e, t, s, i) => {
      if (t && typeof t == "object" || typeof t == "function") for (let r of _i(t)) !ji.call(e, r) && r !== s && Ie(e, r, { get: () => t[r], enumerable: !(i = Hi(t, r)) || i.enumerable });
      return e;
    }, Ji = (e) => Ki(Ie({}, "__esModule", { value: true }), e), Ws = {};
    Zi(Ws, { AlphaTimeline: () => ze, Animation: () => ne, AnimationState: () => sr, AnimationStateAdapter: () => ir, AnimationStateData: () => rr, AssetCache: () => li, AssetManager: () => bi, AssetManagerBase: () => ai, AtlasAttachmentLoader: () => lr, Attachment: () => Re, AttachmentTimeline: () => Ot, BinaryInput: () => gi, BlendMode: () => Is, Bone: () => ms, BoneData: () => us, BoundingBoxAttachment: () => hs, CURRENT: () => ei, CameraController: () => qr, ClippingAttachment: () => $t, Color: () => tt, Color2Attribute: () => Ai, ColorAttribute: () => me, ConstraintData: () => ee, CurveTimeline: () => Ct, CurveTimeline1: () => yt, CurveTimeline2: () => ae, DebugUtils: () => tr, DeformTimeline: () => Ge, Downloader: () => gs, DrawOrderTimeline: () => zt, Event: () => xs, EventData: () => ps, EventQueue: () => Qs, EventTimeline: () => le, EventType: () => $s, FIRST: () => as, FakeTexture: () => nr, GLTexture: () => Gt, HOLD_FIRST: () => he, HOLD_MIX: () => ti, HOLD_SUBSEQUENT: () => ls, IkConstraint: () => oi, IkConstraintData: () => ws, IkConstraintTimeline: () => He, Inherit: () => de, InheritTimeline: () => De, Input: () => Ys, IntSet: () => Qi, Interpolation: () => qs, LoadingScreen: () => Zr, M00: () => V, M01: () => W, M02: () => q, M03: () => O, M10: () => G, M11: () => D, M12: () => H, M13: () => N, M20: () => _, M21: () => j, M22: () => U, M23: () => z, M30: () => J, M31: () => Q, M32: () => $, M33: () => K, ManagedWebGLRenderingContext: () => xt, MathUtils: () => P, Matrix4: () => se, Mesh: () => ks, MeshAttachment: () => Wt, MixBlend: () => Zs, MixDirection: () => Ks, OrthoCamera: () => vi, PathAttachment: () => qt, PathConstraint: () => hi, PathConstraintData: () => bs, PathConstraintMixTimeline: () => Ke, PathConstraintPositionTimeline: () => je, PathConstraintSpacingTimeline: () => Ze, Physics: () => ui, PhysicsConstraintDampingTimeline: () => $e, PhysicsConstraintGravityTimeline: () => ss, PhysicsConstraintInertiaTimeline: () => Je, PhysicsConstraintMassTimeline: () => ts, PhysicsConstraintMixTimeline: () => is, PhysicsConstraintResetTimeline: () => rs, PhysicsConstraintStrengthTimeline: () => Qe, PhysicsConstraintTimeline: () => Pt, PhysicsConstraintWindTimeline: () => es, PointAttachment: () => ni, PolygonBatcher: () => Xs, Pool: () => Jt, Position2Attribute: () => ue, Position3Attribute: () => Gr, PositionMode: () => vs, Pow: () => Gs, PowOut: () => $i, RGB2Timeline: () => qe, RGBA2Timeline: () => We, RGBATimeline: () => Ne, RGBTimeline: () => Ue, RegionAttachment: () => te, ResizeMode: () => ki, RotateMode: () => As, RotateTimeline: () => Qt, SETUP: () => os, SUBSEQUENT: () => oe, ScaleTimeline: () => Xe, ScaleXTimeline: () => Pe, ScaleYTimeline: () => Le, SceneRenderer: () => Yi, SequenceTimeline: () => ns, Shader: () => Tt, ShapeRenderer: () => Ps, ShapeType: () => Mi, ShearTimeline: () => Be, ShearXTimeline: () => Ve, ShearYTimeline: () => Oe, Skeleton: () => fi, SkeletonBinary: () => hr, SkeletonBounds: () => xi, SkeletonClipping: () => wi, SkeletonData: () => Cs, SkeletonDebugRenderer: () => Ei, SkeletonJson: () => zr, SkeletonRenderer: () => Ri, Skin: () => fe, SkinEntry: () => Ss, Slot: () => ci, SlotData: () => Ts, SpacingMode: () => ys, SpineCanvas: () => Qr, StringSet: () => Me, TexCoordAttribute: () => Fs, Texture: () => cs, TextureAtlas: () => ds, TextureAtlasPage: () => ri, TextureAtlasRegion: () => fs, TextureFilter: () => ce, TextureRegion: () => ii, TextureWrap: () => si, TimeKeeper: () => Ee, Timeline: () => ft, Touch: () => yi, TrackEntry: () => Js, TransformConstraint: () => di, TransformConstraintData: () => Ms, TransformConstraintTimeline: () => _e, TranslateTimeline: () => Ye, TranslateXTimeline: () => ke, TranslateYTimeline: () => Fe, Triangulator: () => pi, Utils: () => L, Vector2: () => Vt, Vector3: () => At, VertexAttachment: () => Yt, VertexAttribute: () => Ht, VertexAttributeType: () => Ci, WindowedMean: () => er });
    var Qi = class {
      array = new Array();
      add(e) {
        let t = this.contains(e);
        return this.array[e | 0] = e | 0, !t;
      }
      contains(e) {
        return this.array[e | 0] != null;
      }
      remove(e) {
        this.array[e | 0] = void 0;
      }
      clear() {
        this.array.length = 0;
      }
    }, Me = class {
      entries = {};
      size = 0;
      add(e) {
        let t = this.entries[e];
        return this.entries[e] = true, t ? false : (this.size++, true);
      }
      addAll(e) {
        let t = this.size;
        for (var s = 0, i = e.length; s < i; s++) this.add(e[s]);
        return t != this.size;
      }
      contains(e) {
        return this.entries[e];
      }
      clear() {
        this.entries = {}, this.size = 0;
      }
    }, tt = class Nt {
      constructor(t = 0, s = 0, i = 0, r = 0) {
        this.r = t, this.g = s, this.b = i, this.a = r;
      }
      static WHITE = new Nt(1, 1, 1, 1);
      static RED = new Nt(1, 0, 0, 1);
      static GREEN = new Nt(0, 1, 0, 1);
      static BLUE = new Nt(0, 0, 1, 1);
      static MAGENTA = new Nt(1, 0, 1, 1);
      set(t, s, i, r) {
        return this.r = t, this.g = s, this.b = i, this.a = r, this.clamp();
      }
      setFromColor(t) {
        return this.r = t.r, this.g = t.g, this.b = t.b, this.a = t.a, this;
      }
      setFromString(t) {
        return t = t.charAt(0) == "#" ? t.substr(1) : t, this.r = parseInt(t.substr(0, 2), 16) / 255, this.g = parseInt(t.substr(2, 2), 16) / 255, this.b = parseInt(t.substr(4, 2), 16) / 255, this.a = t.length != 8 ? 1 : parseInt(t.substr(6, 2), 16) / 255, this;
      }
      add(t, s, i, r) {
        return this.r += t, this.g += s, this.b += i, this.a += r, this.clamp();
      }
      clamp() {
        return this.r < 0 ? this.r = 0 : this.r > 1 && (this.r = 1), this.g < 0 ? this.g = 0 : this.g > 1 && (this.g = 1), this.b < 0 ? this.b = 0 : this.b > 1 && (this.b = 1), this.a < 0 ? this.a = 0 : this.a > 1 && (this.a = 1), this;
      }
      static rgba8888ToColor(t, s) {
        t.r = ((s & 4278190080) >>> 24) / 255, t.g = ((s & 16711680) >>> 16) / 255, t.b = ((s & 65280) >>> 8) / 255, t.a = (s & 255) / 255;
      }
      static rgb888ToColor(t, s) {
        t.r = ((s & 16711680) >>> 16) / 255, t.g = ((s & 65280) >>> 8) / 255, t.b = (s & 255) / 255;
      }
      toRgb888() {
        const t = (s) => ("0" + (s * 255).toString(16)).slice(-2);
        return +("0x" + t(this.r) + t(this.g) + t(this.b));
      }
      static fromString(t, s = new Nt()) {
        return s.setFromString(t);
      }
    }, P = class Et {
      static PI = 3.1415927;
      static PI2 = Et.PI * 2;
      static invPI2 = 1 / Et.PI2;
      static radiansToDegrees = 180 / Et.PI;
      static radDeg = Et.radiansToDegrees;
      static degreesToRadians = Et.PI / 180;
      static degRad = Et.degreesToRadians;
      static clamp(t, s, i) {
        return t < s ? s : t > i ? i : t;
      }
      static cosDeg(t) {
        return Math.cos(t * Et.degRad);
      }
      static sinDeg(t) {
        return Math.sin(t * Et.degRad);
      }
      static atan2Deg(t, s) {
        return Math.atan2(t, s) * Et.degRad;
      }
      static signum(t) {
        return t > 0 ? 1 : t < 0 ? -1 : 0;
      }
      static toInt(t) {
        return t > 0 ? Math.floor(t) : Math.ceil(t);
      }
      static cbrt(t) {
        let s = Math.pow(Math.abs(t), 0.3333333333333333);
        return t < 0 ? -s : s;
      }
      static randomTriangular(t, s) {
        return Et.randomTriangularWith(t, s, (t + s) * 0.5);
      }
      static randomTriangularWith(t, s, i) {
        let r = Math.random(), h = s - t;
        return r <= (i - t) / h ? t + Math.sqrt(r * h * (i - t)) : s - Math.sqrt((1 - r) * h * (s - i));
      }
      static isPowerOfTwo(t) {
        return t && (t & t - 1) === 0;
      }
    }, qs = class {
      apply(e, t, s) {
        return e + (t - e) * this.applyInternal(s);
      }
    }, Gs = class extends qs {
      power = 2;
      constructor(e) {
        super(), this.power = e;
      }
      applyInternal(e) {
        return e <= 0.5 ? Math.pow(e * 2, this.power) / 2 : Math.pow((e - 1) * 2, this.power) / (this.power % 2 == 0 ? -2 : 2) + 1;
      }
    }, $i = class extends Gs {
      constructor(e) {
        super(e);
      }
      applyInternal(e) {
        return Math.pow(e - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1;
      }
    }, L = class Kt {
      static SUPPORTS_TYPED_ARRAYS = typeof Float32Array < "u";
      static arrayCopy(t, s, i, r, h) {
        for (let l = s, n = r; l < s + h; l++, n++) i[n] = t[l];
      }
      static arrayFill(t, s, i, r) {
        for (let h = s; h < i; h++) t[h] = r;
      }
      static setArraySize(t, s, i = 0) {
        let r = t.length;
        if (r == s) return t;
        if (t.length = s, r < s) for (let h = r; h < s; h++) t[h] = i;
        return t;
      }
      static ensureArrayCapacity(t, s, i = 0) {
        return t.length >= s ? t : Kt.setArraySize(t, s, i);
      }
      static newArray(t, s) {
        let i = new Array(t);
        for (let r = 0; r < t; r++) i[r] = s;
        return i;
      }
      static newFloatArray(t) {
        if (Kt.SUPPORTS_TYPED_ARRAYS) return new Float32Array(t);
        {
          let s = new Array(t);
          for (let i = 0; i < s.length; i++) s[i] = 0;
          return s;
        }
      }
      static newShortArray(t) {
        if (Kt.SUPPORTS_TYPED_ARRAYS) return new Int16Array(t);
        {
          let s = new Array(t);
          for (let i = 0; i < s.length; i++) s[i] = 0;
          return s;
        }
      }
      static toFloatArray(t) {
        return Kt.SUPPORTS_TYPED_ARRAYS ? new Float32Array(t) : t;
      }
      static toSinglePrecision(t) {
        return Kt.SUPPORTS_TYPED_ARRAYS ? Math.fround(t) : t;
      }
      static webkit602BugfixHelper(t, s) {
      }
      static contains(t, s, i = true) {
        for (var r = 0; r < t.length; r++) if (t[r] == s) return true;
        return false;
      }
      static enumValue(t, s) {
        return t[s[0].toUpperCase() + s.slice(1)];
      }
    }, tr = class {
      static logBones(e) {
        for (let t = 0; t < e.bones.length; t++) {
          let s = e.bones[t];
          console.log(s.data.name + ", " + s.a + ", " + s.b + ", " + s.c + ", " + s.d + ", " + s.worldX + ", " + s.worldY);
        }
      }
    }, Jt = class {
      items = new Array();
      instantiator;
      constructor(e) {
        this.instantiator = e;
      }
      obtain() {
        return this.items.length > 0 ? this.items.pop() : this.instantiator();
      }
      free(e) {
        e.reset && e.reset(), this.items.push(e);
      }
      freeAll(e) {
        for (let t = 0; t < e.length; t++) this.free(e[t]);
      }
      clear() {
        this.items.length = 0;
      }
    }, Vt = class {
      constructor(e = 0, t = 0) {
        this.x = e, this.y = t;
      }
      set(e, t) {
        return this.x = e, this.y = t, this;
      }
      length() {
        let e = this.x, t = this.y;
        return Math.sqrt(e * e + t * t);
      }
      normalize() {
        let e = this.length();
        return e != 0 && (this.x /= e, this.y /= e), this;
      }
    }, Ee = class {
      maxDelta = 0.064;
      framesPerSecond = 0;
      delta = 0;
      totalTime = 0;
      lastTime = Date.now() / 1e3;
      frameCount = 0;
      frameTime = 0;
      update() {
        let e = Date.now() / 1e3;
        this.delta = e - this.lastTime, this.frameTime += this.delta, this.totalTime += this.delta, this.delta > this.maxDelta && (this.delta = this.maxDelta), this.lastTime = e, this.frameCount++, this.frameTime > 1 && (this.framesPerSecond = this.frameCount / this.frameTime, this.frameTime = 0, this.frameCount = 0);
      }
    }, er = class {
      values;
      addedValues = 0;
      lastValue = 0;
      mean = 0;
      dirty = true;
      constructor(e = 32) {
        this.values = new Array(e);
      }
      hasEnoughData() {
        return this.addedValues >= this.values.length;
      }
      addValue(e) {
        this.addedValues < this.values.length && this.addedValues++, this.values[this.lastValue++] = e, this.lastValue > this.values.length - 1 && (this.lastValue = 0), this.dirty = true;
      }
      getMean() {
        if (this.hasEnoughData()) {
          if (this.dirty) {
            let e = 0;
            for (let t = 0; t < this.values.length; t++) e += this.values[t];
            this.mean = e / this.values.length, this.dirty = false;
          }
          return this.mean;
        }
        return 0;
      }
    }, Re = class {
      name;
      constructor(e) {
        if (!e) throw new Error("name cannot be null.");
        this.name = e;
      }
    }, Yt = class Bi extends Re {
      static nextID = 0;
      id = Bi.nextID++;
      bones = null;
      vertices = [];
      worldVerticesLength = 0;
      timelineAttachment = this;
      constructor(t) {
        super(t);
      }
      computeWorldVertices(t, s, i, r, h, l) {
        i = h + (i >> 1) * l;
        let n = t.bone.skeleton, a = t.deform, o = this.vertices, c = this.bones;
        if (!c) {
          a.length > 0 && (o = a);
          let u = t.bone, g = u.worldX, w = u.worldY, b = u.a, x = u.b, p = u.c, v = u.d;
          for (let y = s, A = h; A < i; y += 2, A += l) {
            let C = o[y], S = o[y + 1];
            r[A] = C * b + S * x + g, r[A + 1] = C * p + S * v + w;
          }
          return;
        }
        let d = 0, f = 0;
        for (let u = 0; u < s; u += 2) {
          let g = c[d];
          d += g + 1, f += g;
        }
        let m = n.bones;
        if (a.length == 0) for (let u = h, g = f * 3; u < i; u += l) {
          let w = 0, b = 0, x = c[d++];
          for (x += d; d < x; d++, g += 3) {
            let p = m[c[d]], v = o[g], y = o[g + 1], A = o[g + 2];
            w += (v * p.a + y * p.b + p.worldX) * A, b += (v * p.c + y * p.d + p.worldY) * A;
          }
          r[u] = w, r[u + 1] = b;
        }
        else {
          let u = a;
          for (let g = h, w = f * 3, b = f << 1; g < i; g += l) {
            let x = 0, p = 0, v = c[d++];
            for (v += d; d < v; d++, w += 3, b += 2) {
              let y = m[c[d]], A = o[w] + u[b], C = o[w + 1] + u[b + 1], S = o[w + 2];
              x += (A * y.a + C * y.b + y.worldX) * S, p += (A * y.c + C * y.d + y.worldY) * S;
            }
            r[g] = x, r[g + 1] = p;
          }
        }
      }
      copyTo(t) {
        this.bones ? (t.bones = new Array(this.bones.length), L.arrayCopy(this.bones, 0, t.bones, 0, this.bones.length)) : t.bones = null, this.vertices && (t.vertices = L.newFloatArray(this.vertices.length), L.arrayCopy(this.vertices, 0, t.vertices, 0, this.vertices.length)), t.worldVerticesLength = this.worldVerticesLength, t.timelineAttachment = this.timelineAttachment;
      }
    }, Hs = class Ae {
      static _nextID = 0;
      id = Ae.nextID();
      regions;
      start = 0;
      digits = 0;
      setupIndex = 0;
      constructor(t) {
        this.regions = new Array(t);
      }
      copy() {
        let t = new Ae(this.regions.length);
        return L.arrayCopy(this.regions, 0, t.regions, 0, this.regions.length), t.start = this.start, t.digits = this.digits, t.setupIndex = this.setupIndex, t;
      }
      apply(t, s) {
        let i = t.sequenceIndex;
        i == -1 && (i = this.setupIndex), i >= this.regions.length && (i = this.regions.length - 1);
        let r = this.regions[i];
        s.region != r && (s.region = r, s.updateRegion());
      }
      getPath(t, s) {
        let i = t, r = (this.start + s).toString();
        for (let h = this.digits - r.length; h > 0; h--) i += "0";
        return i += r, i;
      }
      static nextID() {
        return Ae._nextID++;
      }
    }, _s = ((e) => (e[e.hold = 0] = "hold", e[e.once = 1] = "once", e[e.loop = 2] = "loop", e[e.pingpong = 3] = "pingpong", e[e.onceReverse = 4] = "onceReverse", e[e.loopReverse = 5] = "loopReverse", e[e.pingpongReverse = 6] = "pingpongReverse", e))(_s || {}), js = [0, 1, 2, 3, 4, 5, 6], ne = class {
      name;
      timelines = [];
      timelineIds = new Me();
      duration;
      constructor(e, t, s) {
        if (!e) throw new Error("name cannot be null.");
        this.name = e, this.setTimelines(t), this.duration = s;
      }
      setTimelines(e) {
        if (!e) throw new Error("timelines cannot be null.");
        this.timelines = e, this.timelineIds.clear();
        for (var t = 0; t < e.length; t++) this.timelineIds.addAll(e[t].getPropertyIds());
      }
      hasTimeline(e) {
        for (let t = 0; t < e.length; t++) if (this.timelineIds.contains(e[t])) return true;
        return false;
      }
      apply(e, t, s, i, r, h, l, n) {
        if (!e) throw new Error("skeleton cannot be null.");
        i && this.duration != 0 && (s %= this.duration, t > 0 && (t %= this.duration));
        let a = this.timelines;
        for (let o = 0, c = a.length; o < c; o++) a[o].apply(e, t, s, r, h, l, n);
      }
    }, Zs = ((e) => (e[e.setup = 0] = "setup", e[e.first = 1] = "first", e[e.replace = 2] = "replace", e[e.add = 3] = "add", e))(Zs || {}), Ks = ((e) => (e[e.mixIn = 0] = "mixIn", e[e.mixOut = 1] = "mixOut", e))(Ks || {}), it = { rotate: 0, x: 1, y: 2, scaleX: 3, scaleY: 4, shearX: 5, shearY: 6, inherit: 7, rgb: 8, alpha: 9, rgb2: 10, attachment: 11, deform: 12, event: 13, drawOrder: 14, ikConstraint: 15, transformConstraint: 16, pathConstraintPosition: 17, pathConstraintSpacing: 18, pathConstraintMix: 19, physicsConstraintInertia: 20, physicsConstraintStrength: 21, physicsConstraintDamping: 22, physicsConstraintMass: 23, physicsConstraintWind: 24, physicsConstraintGravity: 25, physicsConstraintMix: 26, physicsConstraintReset: 27, sequence: 28 }, ft = class {
      propertyIds;
      frames;
      constructor(e, t) {
        this.propertyIds = t, this.frames = L.newFloatArray(e * this.getFrameEntries());
      }
      getPropertyIds() {
        return this.propertyIds;
      }
      getFrameEntries() {
        return 1;
      }
      getFrameCount() {
        return this.frames.length / this.getFrameEntries();
      }
      getDuration() {
        return this.frames[this.frames.length - this.getFrameEntries()];
      }
      static search1(e, t) {
        let s = e.length;
        for (let i = 1; i < s; i++) if (e[i] > t) return i - 1;
        return s - 1;
      }
      static search(e, t, s) {
        let i = e.length;
        for (let r = s; r < i; r += s) if (e[r] > t) return r - s;
        return i - s;
      }
    }, Ct = class extends ft {
      curves;
      constructor(e, t, s) {
        super(e, s), this.curves = L.newFloatArray(e + t * 18), this.curves[e - 1] = 1;
      }
      setLinear(e) {
        this.curves[e] = 0;
      }
      setStepped(e) {
        this.curves[e] = 1;
      }
      shrink(e) {
        let t = this.getFrameCount() + e * 18;
        if (this.curves.length > t) {
          let s = L.newFloatArray(t);
          L.arrayCopy(this.curves, 0, s, 0, t), this.curves = s;
        }
      }
      setBezier(e, t, s, i, r, h, l, n, a, o, c) {
        let d = this.curves, f = this.getFrameCount() + e * 18;
        s == 0 && (d[t] = 2 + f);
        let m = (i - h * 2 + n) * 0.03, u = (r - l * 2 + a) * 0.03, g = ((h - n) * 3 - i + o) * 6e-3, w = ((l - a) * 3 - r + c) * 6e-3, b = m * 2 + g, x = u * 2 + w, p = (h - i) * 0.3 + m + g * 0.16666667, v = (l - r) * 0.3 + u + w * 0.16666667, y = i + p, A = r + v;
        for (let C = f + 18; f < C; f += 2) d[f] = y, d[f + 1] = A, p += b, v += x, b += g, x += w, y += p, A += v;
      }
      getBezierValue(e, t, s, i) {
        let r = this.curves;
        if (r[i] > e) {
          let a = this.frames[t], o = this.frames[t + s];
          return o + (e - a) / (r[i] - a) * (r[i + 1] - o);
        }
        let h = i + 18;
        for (i += 2; i < h; i += 2) if (r[i] >= e) {
          let a = r[i - 2], o = r[i - 1];
          return o + (e - a) / (r[i] - a) * (r[i + 1] - o);
        }
        t += this.getFrameEntries();
        let l = r[h - 2], n = r[h - 1];
        return n + (e - l) / (this.frames[t] - l) * (this.frames[t + s] - n);
      }
    }, yt = class extends Ct {
      constructor(e, t, s) {
        super(e, t, [s]);
      }
      getFrameEntries() {
        return 2;
      }
      setFrame(e, t, s) {
        e <<= 1, this.frames[e] = t, this.frames[e + 1] = s;
      }
      getCurveValue(e) {
        let t = this.frames, s = t.length - 2;
        for (let r = 2; r <= s; r += 2) if (t[r] > e) {
          s = r - 2;
          break;
        }
        let i = this.curves[s >> 1];
        switch (i) {
          case 0:
            let r = t[s], h = t[s + 1];
            return h + (e - r) / (t[s + 2] - r) * (t[s + 2 + 1] - h);
          case 1:
            return t[s + 1];
        }
        return this.getBezierValue(e, s, 1, i - 2);
      }
      getRelativeValue(e, t, s, i, r) {
        if (e < this.frames[0]) {
          switch (s) {
            case 0:
              return r;
            case 1:
              return i + (r - i) * t;
          }
          return i;
        }
        let h = this.getCurveValue(e);
        switch (s) {
          case 0:
            return r + h * t;
          case 1:
          case 2:
            h += r - i;
        }
        return i + h * t;
      }
      getAbsoluteValue(e, t, s, i, r) {
        if (e < this.frames[0]) {
          switch (s) {
            case 0:
              return r;
            case 1:
              return i + (r - i) * t;
          }
          return i;
        }
        let h = this.getCurveValue(e);
        return s == 0 ? r + (h - r) * t : i + (h - i) * t;
      }
      getAbsoluteValue2(e, t, s, i, r, h) {
        if (e < this.frames[0]) {
          switch (s) {
            case 0:
              return r;
            case 1:
              return i + (r - i) * t;
          }
          return i;
        }
        return s == 0 ? r + (h - r) * t : i + (h - i) * t;
      }
      getScaleValue(e, t, s, i, r, h) {
        const l = this.frames;
        if (e < l[0]) {
          switch (s) {
            case 0:
              return h;
            case 1:
              return r + (h - r) * t;
          }
          return r;
        }
        let n = this.getCurveValue(e) * h;
        if (t == 1) return s == 3 ? r + n - h : n;
        if (i == 1) switch (s) {
          case 0:
            return h + (Math.abs(n) * P.signum(h) - h) * t;
          case 1:
          case 2:
            return r + (Math.abs(n) * P.signum(r) - r) * t;
        }
        else {
          let a = 0;
          switch (s) {
            case 0:
              return a = Math.abs(h) * P.signum(n), a + (n - a) * t;
            case 1:
            case 2:
              return a = Math.abs(r) * P.signum(n), a + (n - a) * t;
          }
        }
        return r + (n - h) * t;
      }
    }, ae = class extends Ct {
      constructor(e, t, s, i) {
        super(e, t, [s, i]);
      }
      getFrameEntries() {
        return 3;
      }
      setFrame(e, t, s, i) {
        e *= 3, this.frames[e] = t, this.frames[e + 1] = s, this.frames[e + 2] = i;
      }
    }, Qt = class extends yt {
      boneIndex = 0;
      constructor(e, t, s) {
        super(e, t, it.rotate + "|" + s), this.boneIndex = s;
      }
      apply(e, t, s, i, r, h, l) {
        let n = e.bones[this.boneIndex];
        n.active && (n.rotation = this.getRelativeValue(s, r, h, n.rotation, n.data.rotation));
      }
    }, Ye = class extends ae {
      boneIndex = 0;
      constructor(e, t, s) {
        super(e, t, it.x + "|" + s, it.y + "|" + s), this.boneIndex = s;
      }
      apply(e, t, s, i, r, h, l) {
        let n = e.bones[this.boneIndex];
        if (!n.active) return;
        let a = this.frames;
        if (s < a[0]) {
          switch (h) {
            case 0:
              n.x = n.data.x, n.y = n.data.y;
              return;
            case 1:
              n.x += (n.data.x - n.x) * r, n.y += (n.data.y - n.y) * r;
          }
          return;
        }
        let o = 0, c = 0, d = ft.search(a, s, 3), f = this.curves[d / 3];
        switch (f) {
          case 0:
            let m = a[d];
            o = a[d + 1], c = a[d + 2];
            let u = (s - m) / (a[d + 3] - m);
            o += (a[d + 3 + 1] - o) * u, c += (a[d + 3 + 2] - c) * u;
            break;
          case 1:
            o = a[d + 1], c = a[d + 2];
            break;
          default:
            o = this.getBezierValue(s, d, 1, f - 2), c = this.getBezierValue(s, d, 2, f + 18 - 2);
        }
        switch (h) {
          case 0:
            n.x = n.data.x + o * r, n.y = n.data.y + c * r;
            break;
          case 1:
          case 2:
            n.x += (n.data.x + o - n.x) * r, n.y += (n.data.y + c - n.y) * r;
            break;
          case 3:
            n.x += o * r, n.y += c * r;
        }
      }
    }, ke = class extends yt {
      boneIndex = 0;
      constructor(e, t, s) {
        super(e, t, it.x + "|" + s), this.boneIndex = s;
      }
      apply(e, t, s, i, r, h, l) {
        let n = e.bones[this.boneIndex];
        n.active && (n.x = this.getRelativeValue(s, r, h, n.x, n.data.x));
      }
    }, Fe = class extends yt {
      boneIndex = 0;
      constructor(e, t, s) {
        super(e, t, it.y + "|" + s), this.boneIndex = s;
      }
      apply(e, t, s, i, r, h, l) {
        let n = e.bones[this.boneIndex];
        n.active && (n.y = this.getRelativeValue(s, r, h, n.y, n.data.y));
      }
    }, Xe = class extends ae {
      boneIndex = 0;
      constructor(e, t, s) {
        super(e, t, it.scaleX + "|" + s, it.scaleY + "|" + s), this.boneIndex = s;
      }
      apply(e, t, s, i, r, h, l) {
        let n = e.bones[this.boneIndex];
        if (!n.active) return;
        let a = this.frames;
        if (s < a[0]) {
          switch (h) {
            case 0:
              n.scaleX = n.data.scaleX, n.scaleY = n.data.scaleY;
              return;
            case 1:
              n.scaleX += (n.data.scaleX - n.scaleX) * r, n.scaleY += (n.data.scaleY - n.scaleY) * r;
          }
          return;
        }
        let o, c, d = ft.search(a, s, 3), f = this.curves[d / 3];
        switch (f) {
          case 0:
            let m = a[d];
            o = a[d + 1], c = a[d + 2];
            let u = (s - m) / (a[d + 3] - m);
            o += (a[d + 3 + 1] - o) * u, c += (a[d + 3 + 2] - c) * u;
            break;
          case 1:
            o = a[d + 1], c = a[d + 2];
            break;
          default:
            o = this.getBezierValue(s, d, 1, f - 2), c = this.getBezierValue(s, d, 2, f + 18 - 2);
        }
        if (o *= n.data.scaleX, c *= n.data.scaleY, r == 1) h == 3 ? (n.scaleX += o - n.data.scaleX, n.scaleY += c - n.data.scaleY) : (n.scaleX = o, n.scaleY = c);
        else {
          let m = 0, u = 0;
          if (l == 1) switch (h) {
            case 0:
              m = n.data.scaleX, u = n.data.scaleY, n.scaleX = m + (Math.abs(o) * P.signum(m) - m) * r, n.scaleY = u + (Math.abs(c) * P.signum(u) - u) * r;
              break;
            case 1:
            case 2:
              m = n.scaleX, u = n.scaleY, n.scaleX = m + (Math.abs(o) * P.signum(m) - m) * r, n.scaleY = u + (Math.abs(c) * P.signum(u) - u) * r;
              break;
            case 3:
              n.scaleX += (o - n.data.scaleX) * r, n.scaleY += (c - n.data.scaleY) * r;
          }
          else switch (h) {
            case 0:
              m = Math.abs(n.data.scaleX) * P.signum(o), u = Math.abs(n.data.scaleY) * P.signum(c), n.scaleX = m + (o - m) * r, n.scaleY = u + (c - u) * r;
              break;
            case 1:
            case 2:
              m = Math.abs(n.scaleX) * P.signum(o), u = Math.abs(n.scaleY) * P.signum(c), n.scaleX = m + (o - m) * r, n.scaleY = u + (c - u) * r;
              break;
            case 3:
              n.scaleX += (o - n.data.scaleX) * r, n.scaleY += (c - n.data.scaleY) * r;
          }
        }
      }
    }, Pe = class extends yt {
      boneIndex = 0;
      constructor(e, t, s) {
        super(e, t, it.scaleX + "|" + s), this.boneIndex = s;
      }
      apply(e, t, s, i, r, h, l) {
        let n = e.bones[this.boneIndex];
        n.active && (n.scaleX = this.getScaleValue(s, r, h, l, n.scaleX, n.data.scaleX));
      }
    }, Le = class extends yt {
      boneIndex = 0;
      constructor(e, t, s) {
        super(e, t, it.scaleY + "|" + s), this.boneIndex = s;
      }
      apply(e, t, s, i, r, h, l) {
        let n = e.bones[this.boneIndex];
        n.active && (n.scaleY = this.getScaleValue(s, r, h, l, n.scaleY, n.data.scaleY));
      }
    }, Be = class extends ae {
      boneIndex = 0;
      constructor(e, t, s) {
        super(e, t, it.shearX + "|" + s, it.shearY + "|" + s), this.boneIndex = s;
      }
      apply(e, t, s, i, r, h, l) {
        let n = e.bones[this.boneIndex];
        if (!n.active) return;
        let a = this.frames;
        if (s < a[0]) {
          switch (h) {
            case 0:
              n.shearX = n.data.shearX, n.shearY = n.data.shearY;
              return;
            case 1:
              n.shearX += (n.data.shearX - n.shearX) * r, n.shearY += (n.data.shearY - n.shearY) * r;
          }
          return;
        }
        let o = 0, c = 0, d = ft.search(a, s, 3), f = this.curves[d / 3];
        switch (f) {
          case 0:
            let m = a[d];
            o = a[d + 1], c = a[d + 2];
            let u = (s - m) / (a[d + 3] - m);
            o += (a[d + 3 + 1] - o) * u, c += (a[d + 3 + 2] - c) * u;
            break;
          case 1:
            o = a[d + 1], c = a[d + 2];
            break;
          default:
            o = this.getBezierValue(s, d, 1, f - 2), c = this.getBezierValue(s, d, 2, f + 18 - 2);
        }
        switch (h) {
          case 0:
            n.shearX = n.data.shearX + o * r, n.shearY = n.data.shearY + c * r;
            break;
          case 1:
          case 2:
            n.shearX += (n.data.shearX + o - n.shearX) * r, n.shearY += (n.data.shearY + c - n.shearY) * r;
            break;
          case 3:
            n.shearX += o * r, n.shearY += c * r;
        }
      }
    }, Ve = class extends yt {
      boneIndex = 0;
      constructor(e, t, s) {
        super(e, t, it.shearX + "|" + s), this.boneIndex = s;
      }
      apply(e, t, s, i, r, h, l) {
        let n = e.bones[this.boneIndex];
        n.active && (n.shearX = this.getRelativeValue(s, r, h, n.shearX, n.data.shearX));
      }
    }, Oe = class extends yt {
      boneIndex = 0;
      constructor(e, t, s) {
        super(e, t, it.shearY + "|" + s), this.boneIndex = s;
      }
      apply(e, t, s, i, r, h, l) {
        let n = e.bones[this.boneIndex];
        n.active && (n.shearY = this.getRelativeValue(s, r, h, n.shearY, n.data.shearY));
      }
    }, De = class extends ft {
      boneIndex = 0;
      constructor(e, t) {
        super(e, [it.inherit + "|" + t]), this.boneIndex = t;
      }
      getFrameEntries() {
        return 2;
      }
      setFrame(e, t, s) {
        e *= 2, this.frames[e] = t, this.frames[e + 1] = s;
      }
      apply(e, t, s, i, r, h, l) {
        let n = e.bones[this.boneIndex];
        if (!n.active) return;
        if (l == 1) {
          h == 0 && (n.inherit = n.data.inherit);
          return;
        }
        let a = this.frames;
        if (s < a[0]) {
          (h == 0 || h == 1) && (n.inherit = n.data.inherit);
          return;
        }
        n.inherit = this.frames[ft.search(a, s, 2) + 1];
      }
    }, Ne = class extends Ct {
      slotIndex = 0;
      constructor(e, t, s) {
        super(e, t, [it.rgb + "|" + s, it.alpha + "|" + s]), this.slotIndex = s;
      }
      getFrameEntries() {
        return 5;
      }
      setFrame(e, t, s, i, r, h) {
        e *= 5, this.frames[e] = t, this.frames[e + 1] = s, this.frames[e + 2] = i, this.frames[e + 3] = r, this.frames[e + 4] = h;
      }
      apply(e, t, s, i, r, h, l) {
        let n = e.slots[this.slotIndex];
        if (!n.bone.active) return;
        let a = this.frames, o = n.color;
        if (s < a[0]) {
          let w = n.data.color;
          switch (h) {
            case 0:
              o.setFromColor(w);
              return;
            case 1:
              o.add((w.r - o.r) * r, (w.g - o.g) * r, (w.b - o.b) * r, (w.a - o.a) * r);
          }
          return;
        }
        let c = 0, d = 0, f = 0, m = 0, u = ft.search(a, s, 5), g = this.curves[u / 5];
        switch (g) {
          case 0:
            let w = a[u];
            c = a[u + 1], d = a[u + 2], f = a[u + 3], m = a[u + 4];
            let b = (s - w) / (a[u + 5] - w);
            c += (a[u + 5 + 1] - c) * b, d += (a[u + 5 + 2] - d) * b, f += (a[u + 5 + 3] - f) * b, m += (a[u + 5 + 4] - m) * b;
            break;
          case 1:
            c = a[u + 1], d = a[u + 2], f = a[u + 3], m = a[u + 4];
            break;
          default:
            c = this.getBezierValue(s, u, 1, g - 2), d = this.getBezierValue(s, u, 2, g + 18 - 2), f = this.getBezierValue(s, u, 3, g + 18 * 2 - 2), m = this.getBezierValue(s, u, 4, g + 18 * 3 - 2);
        }
        r == 1 ? o.set(c, d, f, m) : (h == 0 && o.setFromColor(n.data.color), o.add((c - o.r) * r, (d - o.g) * r, (f - o.b) * r, (m - o.a) * r));
      }
    }, Ue = class extends Ct {
      slotIndex = 0;
      constructor(e, t, s) {
        super(e, t, [it.rgb + "|" + s]), this.slotIndex = s;
      }
      getFrameEntries() {
        return 4;
      }
      setFrame(e, t, s, i, r) {
        e <<= 2, this.frames[e] = t, this.frames[e + 1] = s, this.frames[e + 2] = i, this.frames[e + 3] = r;
      }
      apply(e, t, s, i, r, h, l) {
        let n = e.slots[this.slotIndex];
        if (!n.bone.active) return;
        let a = this.frames, o = n.color;
        if (s < a[0]) {
          let g = n.data.color;
          switch (h) {
            case 0:
              o.r = g.r, o.g = g.g, o.b = g.b;
              return;
            case 1:
              o.r += (g.r - o.r) * r, o.g += (g.g - o.g) * r, o.b += (g.b - o.b) * r;
          }
          return;
        }
        let c = 0, d = 0, f = 0, m = ft.search(a, s, 4), u = this.curves[m >> 2];
        switch (u) {
          case 0:
            let g = a[m];
            c = a[m + 1], d = a[m + 2], f = a[m + 3];
            let w = (s - g) / (a[m + 4] - g);
            c += (a[m + 4 + 1] - c) * w, d += (a[m + 4 + 2] - d) * w, f += (a[m + 4 + 3] - f) * w;
            break;
          case 1:
            c = a[m + 1], d = a[m + 2], f = a[m + 3];
            break;
          default:
            c = this.getBezierValue(s, m, 1, u - 2), d = this.getBezierValue(s, m, 2, u + 18 - 2), f = this.getBezierValue(s, m, 3, u + 18 * 2 - 2);
        }
        if (r == 1) o.r = c, o.g = d, o.b = f;
        else {
          if (h == 0) {
            let g = n.data.color;
            o.r = g.r, o.g = g.g, o.b = g.b;
          }
          o.r += (c - o.r) * r, o.g += (d - o.g) * r, o.b += (f - o.b) * r;
        }
      }
    }, ze = class extends yt {
      slotIndex = 0;
      constructor(e, t, s) {
        super(e, t, it.alpha + "|" + s), this.slotIndex = s;
      }
      apply(e, t, s, i, r, h, l) {
        let n = e.slots[this.slotIndex];
        if (!n.bone.active) return;
        let a = n.color;
        if (s < this.frames[0]) {
          let c = n.data.color;
          switch (h) {
            case 0:
              a.a = c.a;
              return;
            case 1:
              a.a += (c.a - a.a) * r;
          }
          return;
        }
        let o = this.getCurveValue(s);
        r == 1 ? a.a = o : (h == 0 && (a.a = n.data.color.a), a.a += (o - a.a) * r);
      }
    }, We = class extends Ct {
      slotIndex = 0;
      constructor(e, t, s) {
        super(e, t, [it.rgb + "|" + s, it.alpha + "|" + s, it.rgb2 + "|" + s]), this.slotIndex = s;
      }
      getFrameEntries() {
        return 8;
      }
      setFrame(e, t, s, i, r, h, l, n, a) {
        e <<= 3, this.frames[e] = t, this.frames[e + 1] = s, this.frames[e + 2] = i, this.frames[e + 3] = r, this.frames[e + 4] = h, this.frames[e + 5] = l, this.frames[e + 6] = n, this.frames[e + 7] = a;
      }
      apply(e, t, s, i, r, h, l) {
        let n = e.slots[this.slotIndex];
        if (!n.bone.active) return;
        let a = this.frames, o = n.color, c = n.darkColor;
        if (s < a[0]) {
          let v = n.data.color, y = n.data.darkColor;
          switch (h) {
            case 0:
              o.setFromColor(v), c.r = y.r, c.g = y.g, c.b = y.b;
              return;
            case 1:
              o.add((v.r - o.r) * r, (v.g - o.g) * r, (v.b - o.b) * r, (v.a - o.a) * r), c.r += (y.r - c.r) * r, c.g += (y.g - c.g) * r, c.b += (y.b - c.b) * r;
          }
          return;
        }
        let d = 0, f = 0, m = 0, u = 0, g = 0, w = 0, b = 0, x = ft.search(a, s, 8), p = this.curves[x >> 3];
        switch (p) {
          case 0:
            let v = a[x];
            d = a[x + 1], f = a[x + 2], m = a[x + 3], u = a[x + 4], g = a[x + 5], w = a[x + 6], b = a[x + 7];
            let y = (s - v) / (a[x + 8] - v);
            d += (a[x + 8 + 1] - d) * y, f += (a[x + 8 + 2] - f) * y, m += (a[x + 8 + 3] - m) * y, u += (a[x + 8 + 4] - u) * y, g += (a[x + 8 + 5] - g) * y, w += (a[x + 8 + 6] - w) * y, b += (a[x + 8 + 7] - b) * y;
            break;
          case 1:
            d = a[x + 1], f = a[x + 2], m = a[x + 3], u = a[x + 4], g = a[x + 5], w = a[x + 6], b = a[x + 7];
            break;
          default:
            d = this.getBezierValue(s, x, 1, p - 2), f = this.getBezierValue(s, x, 2, p + 18 - 2), m = this.getBezierValue(s, x, 3, p + 18 * 2 - 2), u = this.getBezierValue(s, x, 4, p + 18 * 3 - 2), g = this.getBezierValue(s, x, 5, p + 18 * 4 - 2), w = this.getBezierValue(s, x, 6, p + 18 * 5 - 2), b = this.getBezierValue(s, x, 7, p + 18 * 6 - 2);
        }
        if (r == 1) o.set(d, f, m, u), c.r = g, c.g = w, c.b = b;
        else {
          if (h == 0) {
            o.setFromColor(n.data.color);
            let v = n.data.darkColor;
            c.r = v.r, c.g = v.g, c.b = v.b;
          }
          o.add((d - o.r) * r, (f - o.g) * r, (m - o.b) * r, (u - o.a) * r), c.r += (g - c.r) * r, c.g += (w - c.g) * r, c.b += (b - c.b) * r;
        }
      }
    }, qe = class extends Ct {
      slotIndex = 0;
      constructor(e, t, s) {
        super(e, t, [it.rgb + "|" + s, it.rgb2 + "|" + s]), this.slotIndex = s;
      }
      getFrameEntries() {
        return 7;
      }
      setFrame(e, t, s, i, r, h, l, n) {
        e *= 7, this.frames[e] = t, this.frames[e + 1] = s, this.frames[e + 2] = i, this.frames[e + 3] = r, this.frames[e + 4] = h, this.frames[e + 5] = l, this.frames[e + 6] = n;
      }
      apply(e, t, s, i, r, h, l) {
        let n = e.slots[this.slotIndex];
        if (!n.bone.active) return;
        let a = this.frames, o = n.color, c = n.darkColor;
        if (s < a[0]) {
          let v = n.data.color, y = n.data.darkColor;
          switch (h) {
            case 0:
              o.r = v.r, o.g = v.g, o.b = v.b, c.r = y.r, c.g = y.g, c.b = y.b;
              return;
            case 1:
              o.r += (v.r - o.r) * r, o.g += (v.g - o.g) * r, o.b += (v.b - o.b) * r, c.r += (y.r - c.r) * r, c.g += (y.g - c.g) * r, c.b += (y.b - c.b) * r;
          }
          return;
        }
        let d = 0, f = 0, m = 0, g = 0, w = 0, b = 0, x = ft.search(a, s, 7), p = this.curves[x / 7];
        switch (p) {
          case 0:
            let v = a[x];
            d = a[x + 1], f = a[x + 2], m = a[x + 3], g = a[x + 4], w = a[x + 5], b = a[x + 6];
            let y = (s - v) / (a[x + 7] - v);
            d += (a[x + 7 + 1] - d) * y, f += (a[x + 7 + 2] - f) * y, m += (a[x + 7 + 3] - m) * y, g += (a[x + 7 + 4] - g) * y, w += (a[x + 7 + 5] - w) * y, b += (a[x + 7 + 6] - b) * y;
            break;
          case 1:
            d = a[x + 1], f = a[x + 2], m = a[x + 3], g = a[x + 4], w = a[x + 5], b = a[x + 6];
            break;
          default:
            d = this.getBezierValue(s, x, 1, p - 2), f = this.getBezierValue(s, x, 2, p + 18 - 2), m = this.getBezierValue(s, x, 3, p + 18 * 2 - 2), g = this.getBezierValue(s, x, 4, p + 18 * 3 - 2), w = this.getBezierValue(s, x, 5, p + 18 * 4 - 2), b = this.getBezierValue(s, x, 6, p + 18 * 5 - 2);
        }
        if (r == 1) o.r = d, o.g = f, o.b = m, c.r = g, c.g = w, c.b = b;
        else {
          if (h == 0) {
            let v = n.data.color, y = n.data.darkColor;
            o.r = v.r, o.g = v.g, o.b = v.b, c.r = y.r, c.g = y.g, c.b = y.b;
          }
          o.r += (d - o.r) * r, o.g += (f - o.g) * r, o.b += (m - o.b) * r, c.r += (g - c.r) * r, c.g += (w - c.g) * r, c.b += (b - c.b) * r;
        }
      }
    }, Ot = class extends ft {
      slotIndex = 0;
      attachmentNames;
      constructor(e, t) {
        super(e, [it.attachment + "|" + t]), this.slotIndex = t, this.attachmentNames = new Array(e);
      }
      getFrameCount() {
        return this.frames.length;
      }
      setFrame(e, t, s) {
        this.frames[e] = t, this.attachmentNames[e] = s;
      }
      apply(e, t, s, i, r, h, l) {
        let n = e.slots[this.slotIndex];
        if (n.bone.active) {
          if (l == 1) {
            h == 0 && this.setAttachment(e, n, n.data.attachmentName);
            return;
          }
          if (s < this.frames[0]) {
            (h == 0 || h == 1) && this.setAttachment(e, n, n.data.attachmentName);
            return;
          }
          this.setAttachment(e, n, this.attachmentNames[ft.search1(this.frames, s)]);
        }
      }
      setAttachment(e, t, s) {
        t.setAttachment(s ? e.getAttachment(this.slotIndex, s) : null);
      }
    }, Ge = class extends Ct {
      slotIndex = 0;
      attachment;
      vertices;
      constructor(e, t, s, i) {
        super(e, t, [it.deform + "|" + s + "|" + i.id]), this.slotIndex = s, this.attachment = i, this.vertices = new Array(e);
      }
      getFrameCount() {
        return this.frames.length;
      }
      setFrame(e, t, s) {
        this.frames[e] = t, this.vertices[e] = s;
      }
      setBezier(e, t, s, i, r, h, l, n, a, o, c) {
        let d = this.curves, f = this.getFrameCount() + e * 18;
        s == 0 && (d[t] = 2 + f);
        let m = (i - h * 2 + n) * 0.03, u = a * 0.03 - l * 0.06, g = ((h - n) * 3 - i + o) * 6e-3, w = (l - a + 0.33333333) * 0.018, b = m * 2 + g, x = u * 2 + w, p = (h - i) * 0.3 + m + g * 0.16666667, v = l * 0.3 + u + w * 0.16666667, y = i + p, A = v;
        for (let C = f + 18; f < C; f += 2) d[f] = y, d[f + 1] = A, p += b, v += x, b += g, x += w, y += p, A += v;
      }
      getCurvePercent(e, t) {
        let s = this.curves, i = s[t];
        switch (i) {
          case 0:
            let n = this.frames[t];
            return (e - n) / (this.frames[t + this.getFrameEntries()] - n);
          case 1:
            return 0;
        }
        if (i -= 2, s[i] > e) {
          let n = this.frames[t];
          return s[i + 1] * (e - n) / (s[i] - n);
        }
        let r = i + 18;
        for (i += 2; i < r; i += 2) if (s[i] >= e) {
          let n = s[i - 2], a = s[i - 1];
          return a + (e - n) / (s[i] - n) * (s[i + 1] - a);
        }
        let h = s[r - 2], l = s[r - 1];
        return l + (1 - l) * (e - h) / (this.frames[t + this.getFrameEntries()] - h);
      }
      apply(e, t, s, i, r, h, l) {
        let n = e.slots[this.slotIndex];
        if (!n.bone.active) return;
        let a = n.getAttachment();
        if (!a || !(a instanceof Yt) || a.timelineAttachment != this.attachment) return;
        let o = n.deform;
        o.length == 0 && (h = 0);
        let c = this.vertices, d = c[0].length, f = this.frames;
        if (s < f[0]) {
          switch (h) {
            case 0:
              o.length = 0;
              return;
            case 1:
              if (r == 1) {
                o.length = 0;
                return;
              }
              o.length = d;
              let x = a;
              if (x.bones) {
                r = 1 - r;
                for (var m = 0; m < d; m++) o[m] *= r;
              } else {
                let p = x.vertices;
                for (var m = 0; m < d; m++) o[m] += (p[m] - o[m]) * r;
              }
          }
          return;
        }
        if (o.length = d, s >= f[f.length - 1]) {
          let x = c[f.length - 1];
          if (r == 1) if (h == 3) {
            let p = a;
            if (p.bones) for (let v = 0; v < d; v++) o[v] += x[v];
            else {
              let v = p.vertices;
              for (let y = 0; y < d; y++) o[y] += x[y] - v[y];
            }
          } else L.arrayCopy(x, 0, o, 0, d);
          else switch (h) {
            case 0: {
              let v = a;
              if (v.bones) for (let y = 0; y < d; y++) o[y] = x[y] * r;
              else {
                let y = v.vertices;
                for (let A = 0; A < d; A++) {
                  let C = y[A];
                  o[A] = C + (x[A] - C) * r;
                }
              }
              break;
            }
            case 1:
            case 2:
              for (let v = 0; v < d; v++) o[v] += (x[v] - o[v]) * r;
              break;
            case 3:
              let p = a;
              if (p.bones) for (let v = 0; v < d; v++) o[v] += x[v] * r;
              else {
                let v = p.vertices;
                for (let y = 0; y < d; y++) o[y] += (x[y] - v[y]) * r;
              }
          }
          return;
        }
        let u = ft.search1(f, s), g = this.getCurvePercent(s, u), w = c[u], b = c[u + 1];
        if (r == 1) if (h == 3) {
          let x = a;
          if (x.bones) for (let p = 0; p < d; p++) {
            let v = w[p];
            o[p] += v + (b[p] - v) * g;
          }
          else {
            let p = x.vertices;
            for (let v = 0; v < d; v++) {
              let y = w[v];
              o[v] += y + (b[v] - y) * g - p[v];
            }
          }
        } else for (let x = 0; x < d; x++) {
          let p = w[x];
          o[x] = p + (b[x] - p) * g;
        }
        else switch (h) {
          case 0: {
            let p = a;
            if (p.bones) for (let v = 0; v < d; v++) {
              let y = w[v];
              o[v] = (y + (b[v] - y) * g) * r;
            }
            else {
              let v = p.vertices;
              for (let y = 0; y < d; y++) {
                let A = w[y], C = v[y];
                o[y] = C + (A + (b[y] - A) * g - C) * r;
              }
            }
            break;
          }
          case 1:
          case 2:
            for (let p = 0; p < d; p++) {
              let v = w[p];
              o[p] += (v + (b[p] - v) * g - o[p]) * r;
            }
            break;
          case 3:
            let x = a;
            if (x.bones) for (let p = 0; p < d; p++) {
              let v = w[p];
              o[p] += (v + (b[p] - v) * g) * r;
            }
            else {
              let p = x.vertices;
              for (let v = 0; v < d; v++) {
                let y = w[v];
                o[v] += (y + (b[v] - y) * g - p[v]) * r;
              }
            }
        }
      }
    }, le = class Vi extends ft {
      static propertyIds = ["" + it.event];
      events;
      constructor(t) {
        super(t, Vi.propertyIds), this.events = new Array(t);
      }
      getFrameCount() {
        return this.frames.length;
      }
      setFrame(t, s) {
        this.frames[t] = s.time, this.events[t] = s;
      }
      apply(t, s, i, r, h, l, n) {
        if (!r) return;
        let a = this.frames, o = this.frames.length;
        if (s > i) this.apply(t, s, Number.MAX_VALUE, r, h, l, n), s = -1;
        else if (s >= a[o - 1]) return;
        if (i < a[0]) return;
        let c = 0;
        if (s < a[0]) c = 0;
        else {
          c = ft.search1(a, s) + 1;
          let d = a[c];
          for (; c > 0 && a[c - 1] == d; ) c--;
        }
        for (; c < o && i >= a[c]; c++) r.push(this.events[c]);
      }
    }, zt = class Oi extends ft {
      static propertyIds = ["" + it.drawOrder];
      drawOrders;
      constructor(t) {
        super(t, Oi.propertyIds), this.drawOrders = new Array(t);
      }
      getFrameCount() {
        return this.frames.length;
      }
      setFrame(t, s, i) {
        this.frames[t] = s, this.drawOrders[t] = i;
      }
      apply(t, s, i, r, h, l, n) {
        if (n == 1) {
          l == 0 && L.arrayCopy(t.slots, 0, t.drawOrder, 0, t.slots.length);
          return;
        }
        if (i < this.frames[0]) {
          (l == 0 || l == 1) && L.arrayCopy(t.slots, 0, t.drawOrder, 0, t.slots.length);
          return;
        }
        let a = ft.search1(this.frames, i), o = this.drawOrders[a];
        if (!o) L.arrayCopy(t.slots, 0, t.drawOrder, 0, t.slots.length);
        else {
          let c = t.drawOrder, d = t.slots;
          for (let f = 0, m = o.length; f < m; f++) c[f] = d[o[f]];
        }
      }
    }, He = class extends Ct {
      constraintIndex = 0;
      constructor(e, t, s) {
        super(e, t, [it.ikConstraint + "|" + s]), this.constraintIndex = s;
      }
      getFrameEntries() {
        return 6;
      }
      setFrame(e, t, s, i, r, h, l) {
        e *= 6, this.frames[e] = t, this.frames[e + 1] = s, this.frames[e + 2] = i, this.frames[e + 3] = r, this.frames[e + 4] = h ? 1 : 0, this.frames[e + 5] = l ? 1 : 0;
      }
      apply(e, t, s, i, r, h, l) {
        let n = e.ikConstraints[this.constraintIndex];
        if (!n.active) return;
        let a = this.frames;
        if (s < a[0]) {
          switch (h) {
            case 0:
              n.mix = n.data.mix, n.softness = n.data.softness, n.bendDirection = n.data.bendDirection, n.compress = n.data.compress, n.stretch = n.data.stretch;
              return;
            case 1:
              n.mix += (n.data.mix - n.mix) * r, n.softness += (n.data.softness - n.softness) * r, n.bendDirection = n.data.bendDirection, n.compress = n.data.compress, n.stretch = n.data.stretch;
          }
          return;
        }
        let o = 0, c = 0, d = ft.search(a, s, 6), f = this.curves[d / 6];
        switch (f) {
          case 0:
            let m = a[d];
            o = a[d + 1], c = a[d + 2];
            let u = (s - m) / (a[d + 6] - m);
            o += (a[d + 6 + 1] - o) * u, c += (a[d + 6 + 2] - c) * u;
            break;
          case 1:
            o = a[d + 1], c = a[d + 2];
            break;
          default:
            o = this.getBezierValue(s, d, 1, f - 2), c = this.getBezierValue(s, d, 2, f + 18 - 2);
        }
        h == 0 ? (n.mix = n.data.mix + (o - n.data.mix) * r, n.softness = n.data.softness + (c - n.data.softness) * r, l == 1 ? (n.bendDirection = n.data.bendDirection, n.compress = n.data.compress, n.stretch = n.data.stretch) : (n.bendDirection = a[d + 3], n.compress = a[d + 4] != 0, n.stretch = a[d + 5] != 0)) : (n.mix += (o - n.mix) * r, n.softness += (c - n.softness) * r, l == 0 && (n.bendDirection = a[d + 3], n.compress = a[d + 4] != 0, n.stretch = a[d + 5] != 0));
      }
    }, _e = class extends Ct {
      constraintIndex = 0;
      constructor(e, t, s) {
        super(e, t, [it.transformConstraint + "|" + s]), this.constraintIndex = s;
      }
      getFrameEntries() {
        return 7;
      }
      setFrame(e, t, s, i, r, h, l, n) {
        let a = this.frames;
        e *= 7, a[e] = t, a[e + 1] = s, a[e + 2] = i, a[e + 3] = r, a[e + 4] = h, a[e + 5] = l, a[e + 6] = n;
      }
      apply(e, t, s, i, r, h, l) {
        let n = e.transformConstraints[this.constraintIndex];
        if (!n.active) return;
        let a = this.frames;
        if (s < a[0]) {
          let b = n.data;
          switch (h) {
            case 0:
              n.mixRotate = b.mixRotate, n.mixX = b.mixX, n.mixY = b.mixY, n.mixScaleX = b.mixScaleX, n.mixScaleY = b.mixScaleY, n.mixShearY = b.mixShearY;
              return;
            case 1:
              n.mixRotate += (b.mixRotate - n.mixRotate) * r, n.mixX += (b.mixX - n.mixX) * r, n.mixY += (b.mixY - n.mixY) * r, n.mixScaleX += (b.mixScaleX - n.mixScaleX) * r, n.mixScaleY += (b.mixScaleY - n.mixScaleY) * r, n.mixShearY += (b.mixShearY - n.mixShearY) * r;
          }
          return;
        }
        let o, c, d, f, m, u, g = ft.search(a, s, 7), w = this.curves[g / 7];
        switch (w) {
          case 0:
            let b = a[g];
            o = a[g + 1], c = a[g + 2], d = a[g + 3], f = a[g + 4], m = a[g + 5], u = a[g + 6];
            let x = (s - b) / (a[g + 7] - b);
            o += (a[g + 7 + 1] - o) * x, c += (a[g + 7 + 2] - c) * x, d += (a[g + 7 + 3] - d) * x, f += (a[g + 7 + 4] - f) * x, m += (a[g + 7 + 5] - m) * x, u += (a[g + 7 + 6] - u) * x;
            break;
          case 1:
            o = a[g + 1], c = a[g + 2], d = a[g + 3], f = a[g + 4], m = a[g + 5], u = a[g + 6];
            break;
          default:
            o = this.getBezierValue(s, g, 1, w - 2), c = this.getBezierValue(s, g, 2, w + 18 - 2), d = this.getBezierValue(s, g, 3, w + 18 * 2 - 2), f = this.getBezierValue(s, g, 4, w + 18 * 3 - 2), m = this.getBezierValue(s, g, 5, w + 18 * 4 - 2), u = this.getBezierValue(s, g, 6, w + 18 * 5 - 2);
        }
        if (h == 0) {
          let b = n.data;
          n.mixRotate = b.mixRotate + (o - b.mixRotate) * r, n.mixX = b.mixX + (c - b.mixX) * r, n.mixY = b.mixY + (d - b.mixY) * r, n.mixScaleX = b.mixScaleX + (f - b.mixScaleX) * r, n.mixScaleY = b.mixScaleY + (m - b.mixScaleY) * r, n.mixShearY = b.mixShearY + (u - b.mixShearY) * r;
        } else n.mixRotate += (o - n.mixRotate) * r, n.mixX += (c - n.mixX) * r, n.mixY += (d - n.mixY) * r, n.mixScaleX += (f - n.mixScaleX) * r, n.mixScaleY += (m - n.mixScaleY) * r, n.mixShearY += (u - n.mixShearY) * r;
      }
    }, je = class extends yt {
      constraintIndex = 0;
      constructor(e, t, s) {
        super(e, t, it.pathConstraintPosition + "|" + s), this.constraintIndex = s;
      }
      apply(e, t, s, i, r, h, l) {
        let n = e.pathConstraints[this.constraintIndex];
        n.active && (n.position = this.getAbsoluteValue(s, r, h, n.position, n.data.position));
      }
    }, Ze = class extends yt {
      constraintIndex = 0;
      constructor(e, t, s) {
        super(e, t, it.pathConstraintSpacing + "|" + s), this.constraintIndex = s;
      }
      apply(e, t, s, i, r, h, l) {
        let n = e.pathConstraints[this.constraintIndex];
        n.active && (n.spacing = this.getAbsoluteValue(s, r, h, n.spacing, n.data.spacing));
      }
    }, Ke = class extends Ct {
      constraintIndex = 0;
      constructor(e, t, s) {
        super(e, t, [it.pathConstraintMix + "|" + s]), this.constraintIndex = s;
      }
      getFrameEntries() {
        return 4;
      }
      setFrame(e, t, s, i, r) {
        let h = this.frames;
        e <<= 2, h[e] = t, h[e + 1] = s, h[e + 2] = i, h[e + 3] = r;
      }
      apply(e, t, s, i, r, h, l) {
        let n = e.pathConstraints[this.constraintIndex];
        if (!n.active) return;
        let a = this.frames;
        if (s < a[0]) {
          switch (h) {
            case 0:
              n.mixRotate = n.data.mixRotate, n.mixX = n.data.mixX, n.mixY = n.data.mixY;
              return;
            case 1:
              n.mixRotate += (n.data.mixRotate - n.mixRotate) * r, n.mixX += (n.data.mixX - n.mixX) * r, n.mixY += (n.data.mixY - n.mixY) * r;
          }
          return;
        }
        let o, c, d, f = ft.search(a, s, 4), m = this.curves[f >> 2];
        switch (m) {
          case 0:
            let u = a[f];
            o = a[f + 1], c = a[f + 2], d = a[f + 3];
            let g = (s - u) / (a[f + 4] - u);
            o += (a[f + 4 + 1] - o) * g, c += (a[f + 4 + 2] - c) * g, d += (a[f + 4 + 3] - d) * g;
            break;
          case 1:
            o = a[f + 1], c = a[f + 2], d = a[f + 3];
            break;
          default:
            o = this.getBezierValue(s, f, 1, m - 2), c = this.getBezierValue(s, f, 2, m + 18 - 2), d = this.getBezierValue(s, f, 3, m + 18 * 2 - 2);
        }
        if (h == 0) {
          let u = n.data;
          n.mixRotate = u.mixRotate + (o - u.mixRotate) * r, n.mixX = u.mixX + (c - u.mixX) * r, n.mixY = u.mixY + (d - u.mixY) * r;
        } else n.mixRotate += (o - n.mixRotate) * r, n.mixX += (c - n.mixX) * r, n.mixY += (d - n.mixY) * r;
      }
    }, Pt = class extends yt {
      constraintIndex = 0;
      constructor(e, t, s, i) {
        super(e, t, i + "|" + s), this.constraintIndex = s;
      }
      apply(e, t, s, i, r, h, l) {
        let n;
        if (this.constraintIndex == -1) {
          const a = s >= this.frames[0] ? this.getCurveValue(s) : 0;
          for (const o of e.physicsConstraints) o.active && this.global(o.data) && this.set(o, this.getAbsoluteValue2(s, r, h, this.get(o), this.setup(o), a));
        } else n = e.physicsConstraints[this.constraintIndex], n.active && this.set(n, this.getAbsoluteValue(s, r, h, this.get(n), this.setup(n)));
      }
    }, Je = class extends Pt {
      constructor(e, t, s) {
        super(e, t, s, it.physicsConstraintInertia);
      }
      setup(e) {
        return e.data.inertia;
      }
      get(e) {
        return e.inertia;
      }
      set(e, t) {
        e.inertia = t;
      }
      global(e) {
        return e.inertiaGlobal;
      }
    }, Qe = class extends Pt {
      constructor(e, t, s) {
        super(e, t, s, it.physicsConstraintStrength);
      }
      setup(e) {
        return e.data.strength;
      }
      get(e) {
        return e.strength;
      }
      set(e, t) {
        e.strength = t;
      }
      global(e) {
        return e.strengthGlobal;
      }
    }, $e = class extends Pt {
      constructor(e, t, s) {
        super(e, t, s, it.physicsConstraintDamping);
      }
      setup(e) {
        return e.data.damping;
      }
      get(e) {
        return e.damping;
      }
      set(e, t) {
        e.damping = t;
      }
      global(e) {
        return e.dampingGlobal;
      }
    }, ts = class extends Pt {
      constructor(e, t, s) {
        super(e, t, s, it.physicsConstraintMass);
      }
      setup(e) {
        return 1 / e.data.massInverse;
      }
      get(e) {
        return 1 / e.massInverse;
      }
      set(e, t) {
        e.massInverse = 1 / t;
      }
      global(e) {
        return e.massGlobal;
      }
    }, es = class extends Pt {
      constructor(e, t, s) {
        super(e, t, s, it.physicsConstraintWind);
      }
      setup(e) {
        return e.data.wind;
      }
      get(e) {
        return e.wind;
      }
      set(e, t) {
        e.wind = t;
      }
      global(e) {
        return e.windGlobal;
      }
    }, ss = class extends Pt {
      constructor(e, t, s) {
        super(e, t, s, it.physicsConstraintGravity);
      }
      setup(e) {
        return e.data.gravity;
      }
      get(e) {
        return e.gravity;
      }
      set(e, t) {
        e.gravity = t;
      }
      global(e) {
        return e.gravityGlobal;
      }
    }, is = class extends Pt {
      constructor(e, t, s) {
        super(e, t, s, it.physicsConstraintMix);
      }
      setup(e) {
        return e.data.mix;
      }
      get(e) {
        return e.mix;
      }
      set(e, t) {
        e.mix = t;
      }
      global(e) {
        return e.mixGlobal;
      }
    }, rs = class Di extends ft {
      static propertyIds = [it.physicsConstraintReset.toString()];
      constraintIndex;
      constructor(t, s) {
        super(t, Di.propertyIds), this.constraintIndex = s;
      }
      getFrameCount() {
        return this.frames.length;
      }
      setFrame(t, s) {
        this.frames[t] = s;
      }
      apply(t, s, i, r, h, l, n) {
        let a;
        if (this.constraintIndex != -1 && (a = t.physicsConstraints[this.constraintIndex], !a.active)) return;
        const o = this.frames;
        if (s > i) this.apply(t, s, Number.MAX_VALUE, [], h, l, n), s = -1;
        else if (s >= o[o.length - 1]) return;
        if (!(i < o[0]) && (s < o[0] || i >= o[ft.search1(o, s) + 1])) if (a != null) a.reset();
        else for (const c of t.physicsConstraints) c.active && c.reset();
      }
    }, ns = class Lt extends ft {
      static ENTRIES = 3;
      static MODE = 1;
      static DELAY = 2;
      slotIndex;
      attachment;
      constructor(t, s, i) {
        super(t, [it.sequence + "|" + s + "|" + i.sequence.id]), this.slotIndex = s, this.attachment = i;
      }
      getFrameEntries() {
        return Lt.ENTRIES;
      }
      getSlotIndex() {
        return this.slotIndex;
      }
      getAttachment() {
        return this.attachment;
      }
      setFrame(t, s, i, r, h) {
        let l = this.frames;
        t *= Lt.ENTRIES, l[t] = s, l[t + Lt.MODE] = i | r << 4, l[t + Lt.DELAY] = h;
      }
      apply(t, s, i, r, h, l, n) {
        let a = t.slots[this.slotIndex];
        if (!a.bone.active) return;
        let o = a.attachment, c = this.attachment;
        if (o != c && (!(o instanceof Yt) || o.timelineAttachment != c)) return;
        if (n == 1) {
          l == 0 && (a.sequenceIndex = -1);
          return;
        }
        let d = this.frames;
        if (i < d[0]) {
          (l == 0 || l == 1) && (a.sequenceIndex = -1);
          return;
        }
        let f = ft.search(d, i, Lt.ENTRIES), m = d[f], u = d[f + Lt.MODE], g = d[f + Lt.DELAY];
        if (!this.attachment.sequence) return;
        let w = u >> 4, b = this.attachment.sequence.regions.length, x = js[u & 15];
        if (x != 0) switch (w += (i - m) / g + 1e-5 | 0, x) {
          case 1:
            w = Math.min(b - 1, w);
            break;
          case 2:
            w %= b;
            break;
          case 3: {
            let p = (b << 1) - 2;
            w = p == 0 ? 0 : w % p, w >= b && (w = p - w);
            break;
          }
          case 4:
            w = Math.max(b - 1 - w, 0);
            break;
          case 5:
            w = b - 1 - w % b;
            break;
          case 6: {
            let p = (b << 1) - 2;
            w = p == 0 ? 0 : (w + b - 1) % p, w >= b && (w = p - w);
          }
        }
        a.sequenceIndex = w;
      }
    }, sr = class Ce {
      static _emptyAnimation = new ne("<empty>", [], 0);
      static emptyAnimation() {
        return Ce._emptyAnimation;
      }
      data;
      tracks = new Array();
      timeScale = 1;
      unkeyedState = 0;
      events = new Array();
      listeners = new Array();
      queue = new Qs(this);
      propertyIDs = new Me();
      animationsChanged = false;
      trackEntryPool = new Jt(() => new Js());
      constructor(t) {
        this.data = t;
      }
      update(t) {
        t *= this.timeScale;
        let s = this.tracks;
        for (let i = 0, r = s.length; i < r; i++) {
          let h = s[i];
          if (!h) continue;
          h.animationLast = h.nextAnimationLast, h.trackLast = h.nextTrackLast;
          let l = t * h.timeScale;
          if (h.delay > 0) {
            if (h.delay -= l, h.delay > 0) continue;
            l = -h.delay, h.delay = 0;
          }
          let n = h.next;
          if (n) {
            let a = h.trackLast - n.delay;
            if (a >= 0) {
              for (n.delay = 0, n.trackTime += h.timeScale == 0 ? 0 : (a / h.timeScale + t) * n.timeScale, h.trackTime += l, this.setCurrent(i, n, true); n.mixingFrom; ) n.mixTime += t, n = n.mixingFrom;
              continue;
            }
          } else if (h.trackLast >= h.trackEnd && !h.mixingFrom) {
            s[i] = null, this.queue.end(h), this.clearNext(h);
            continue;
          }
          if (h.mixingFrom && this.updateMixingFrom(h, t)) {
            let a = h.mixingFrom;
            for (h.mixingFrom = null, a && (a.mixingTo = null); a; ) this.queue.end(a), a = a.mixingFrom;
          }
          h.trackTime += l;
        }
        this.queue.drain();
      }
      updateMixingFrom(t, s) {
        let i = t.mixingFrom;
        if (!i) return true;
        let r = this.updateMixingFrom(i, s);
        return i.animationLast = i.nextAnimationLast, i.trackLast = i.nextTrackLast, t.nextTrackLast != -1 && t.mixTime >= t.mixDuration ? ((i.totalAlpha == 0 || t.mixDuration == 0) && (t.mixingFrom = i.mixingFrom, i.mixingFrom != null && (i.mixingFrom.mixingTo = t), t.interruptAlpha = i.interruptAlpha, this.queue.end(i)), r) : (i.trackTime += s * i.timeScale, t.mixTime += s, false);
      }
      apply(t) {
        if (!t) throw new Error("skeleton cannot be null.");
        this.animationsChanged && this._animationsChanged();
        let s = this.events, i = this.tracks, r = false;
        for (let f = 0, m = i.length; f < m; f++) {
          let u = i[f];
          if (!u || u.delay > 0) continue;
          r = true;
          let g = f == 0 ? 1 : u.mixBlend, w = u.alpha;
          u.mixingFrom ? w *= this.applyMixingFrom(u, t, g) : u.trackTime >= u.trackEnd && !u.next && (w = 0);
          let b = w >= u.alphaAttachmentThreshold, x = u.animationLast, p = u.getAnimationTime(), v = p, y = s;
          u.reverse && (v = u.animation.duration - v, y = null);
          let A = u.animation.timelines, C = A.length;
          if (f == 0 && w == 1 || g == 3) {
            f == 0 && (b = true);
            for (let S = 0; S < C; S++) {
              var h = A[S];
              h instanceof Ot ? this.applyAttachmentTimeline(h, t, v, g, b) : h.apply(t, x, v, y, w, g, 0);
            }
          } else {
            let S = u.timelineMode, I = u.shortestRotation, Y = !I && u.timelinesRotation.length != C << 1;
            Y && (u.timelinesRotation.length = C << 1);
            for (let k = 0; k < C; k++) {
              let F = A[k], X = S[k] == oe ? g : 0;
              !I && F instanceof Qt ? this.applyRotateTimeline(F, t, v, w, X, u.timelinesRotation, k << 1, Y) : F instanceof Ot ? this.applyAttachmentTimeline(F, t, v, g, b) : (F.apply(t, x, v, y, w, X, 0));
            }
          }
          this.queueEvents(u, p), s.length = 0, u.nextAnimationLast = p, u.nextTrackLast = u.trackTime;
        }
        for (var l = this.unkeyedState + os, n = t.slots, a = 0, o = t.slots.length; a < o; a++) {
          var c = n[a];
          if (c.attachmentState == l) {
            var d = c.data.attachmentName;
            c.setAttachment(d ? t.getAttachment(c.data.index, d) : null);
          }
        }
        return this.unkeyedState += 2, this.queue.drain(), r;
      }
      applyMixingFrom(t, s, i) {
        let r = t.mixingFrom;
        r.mixingFrom && this.applyMixingFrom(r, s, i);
        let h = 0;
        t.mixDuration == 0 ? (h = 1, i == 1 && (i = 0)) : (h = t.mixTime / t.mixDuration, h > 1 && (h = 1), i != 1 && (i = r.mixBlend));
        let l = h < r.mixAttachmentThreshold, n = h < r.mixDrawOrderThreshold, a = r.animation.timelines, o = a.length, c = r.alpha * t.interruptAlpha, d = c * (1 - h), f = r.animationLast, m = r.getAnimationTime(), u = m, g = null;
        if (r.reverse ? u = r.animation.duration - u : h < r.eventThreshold && (g = this.events), i == 3) for (let w = 0; w < o; w++) a[w].apply(s, f, u, g, d, i, 1);
        else {
          let w = r.timelineMode, b = r.timelineHoldMix, x = r.shortestRotation, p = !x && r.timelinesRotation.length != o << 1;
          p && (r.timelinesRotation.length = o << 1), r.totalAlpha = 0;
          for (let v = 0; v < o; v++) {
            let y = a[v], A = 1, C, S = 0;
            switch (w[v]) {
              case oe:
                if (!n && y instanceof zt) continue;
                C = i, S = d;
                break;
              case as:
                C = 0, S = d;
                break;
              case ls:
                C = i, S = c;
                break;
              case he:
                C = 0, S = c;
                break;
              default:
                C = 0;
                let I = b[v];
                S = c * Math.max(0, 1 - I.mixTime / I.mixDuration);
                break;
            }
            r.totalAlpha += S, !x && y instanceof Qt ? this.applyRotateTimeline(y, s, u, S, C, r.timelinesRotation, v << 1, p) : y instanceof Ot ? this.applyAttachmentTimeline(y, s, u, C, l && S >= r.alphaAttachmentThreshold) : (n && y instanceof zt && C == 0 && (A = 0), y.apply(s, f, u, g, S, C, A));
          }
        }
        return t.mixDuration > 0 && this.queueEvents(r, m), this.events.length = 0, r.nextAnimationLast = m, r.nextTrackLast = r.trackTime, h;
      }
      applyAttachmentTimeline(t, s, i, r, h) {
        var l = s.slots[t.slotIndex];
        l.bone.active && (i < t.frames[0] ? (r == 0 || r == 1) && this.setAttachment(s, l, l.data.attachmentName, h) : this.setAttachment(s, l, t.attachmentNames[ft.search1(t.frames, i)], h), l.attachmentState <= this.unkeyedState && (l.attachmentState = this.unkeyedState + os));
      }
      setAttachment(t, s, i, r) {
        s.setAttachment(i ? t.getAttachment(s.data.index, i) : null), r && (s.attachmentState = this.unkeyedState + ei);
      }
      applyRotateTimeline(t, s, i, r, h, l, n, a) {
        if (a && (l[n] = 0), r == 1) {
          t.apply(s, 0, i, null, 1, h, 0);
          return;
        }
        let o = s.bones[t.boneIndex];
        if (!o.active) return;
        let c = t.frames, d = 0, f = 0;
        if (i < c[0]) switch (h) {
          case 0:
            o.rotation = o.data.rotation;
          default:
            return;
          case 1:
            d = o.rotation, f = o.data.rotation;
        }
        else d = h == 0 ? o.data.rotation : o.rotation, f = o.data.rotation + t.getCurveValue(i);
        let m = 0, u = f - d;
        if (u -= Math.ceil(u / 360 - 0.5) * 360, u == 0) m = l[n];
        else {
          let g = 0, w = 0;
          a ? (g = 0, w = u) : (g = l[n], w = l[n + 1]);
          let b = g - g % 360;
          m = u + b;
          let x = u >= 0, p = g >= 0;
          Math.abs(w) <= 90 && P.signum(w) != P.signum(u) && (Math.abs(g - b) > 180 ? (m += 360 * P.signum(g), p = x) : b != 0 ? m -= 360 * P.signum(g) : p = x), p != x && (m += 360 * P.signum(g)), l[n] = m;
        }
        l[n + 1] = u, o.rotation = d + m * r;
      }
      queueEvents(t, s) {
        let i = t.animationStart, r = t.animationEnd, h = r - i, l = t.trackLast % h, n = this.events, a = 0, o = n.length;
        for (; a < o; a++) {
          let d = n[a];
          if (d.time < l) break;
          d.time > r || this.queue.event(t, d);
        }
        let c = false;
        if (t.loop) if (h == 0) c = true;
        else {
          const d = Math.floor(t.trackTime / h);
          c = d > 0 && d > Math.floor(t.trackLast / h);
        }
        else c = s >= r && t.animationLast < r;
        for (c && this.queue.complete(t); a < o; a++) {
          let d = n[a];
          d.time < i || this.queue.event(t, d);
        }
      }
      clearTracks() {
        let t = this.queue.drainDisabled;
        this.queue.drainDisabled = true;
        for (let s = 0, i = this.tracks.length; s < i; s++) this.clearTrack(s);
        this.tracks.length = 0, this.queue.drainDisabled = t, this.queue.drain();
      }
      clearTrack(t) {
        if (t >= this.tracks.length) return;
        let s = this.tracks[t];
        if (!s) return;
        this.queue.end(s), this.clearNext(s);
        let i = s;
        for (; ; ) {
          let r = i.mixingFrom;
          if (!r) break;
          this.queue.end(r), i.mixingFrom = null, i.mixingTo = null, i = r;
        }
        this.tracks[s.trackIndex] = null, this.queue.drain();
      }
      setCurrent(t, s, i) {
        let r = this.expandToIndex(t);
        this.tracks[t] = s, s.previous = null, r && (i && this.queue.interrupt(r), s.mixingFrom = r, r.mixingTo = s, s.mixTime = 0, r.mixingFrom && r.mixDuration > 0 && (s.interruptAlpha *= Math.min(1, r.mixTime / r.mixDuration)), r.timelinesRotation.length = 0), this.queue.start(s);
      }
      setAnimation(t, s, i = false) {
        let r = this.data.skeletonData.findAnimation(s);
        if (!r) throw new Error("Animation not found: " + s);
        return this.setAnimationWith(t, r, i);
      }
      setAnimationWith(t, s, i = false) {
        if (!s) throw new Error("animation cannot be null.");
        let r = true, h = this.expandToIndex(t);
        h && (h.nextTrackLast == -1 ? (this.tracks[t] = h.mixingFrom, this.queue.interrupt(h), this.queue.end(h), this.clearNext(h), h = h.mixingFrom, r = false) : this.clearNext(h));
        let l = this.trackEntry(t, s, i, h);
        return this.setCurrent(t, l, r), this.queue.drain(), l;
      }
      addAnimation(t, s, i = false, r = 0) {
        let h = this.data.skeletonData.findAnimation(s);
        if (!h) throw new Error("Animation not found: " + s);
        return this.addAnimationWith(t, h, i, r);
      }
      addAnimationWith(t, s, i = false, r = 0) {
        if (!s) throw new Error("animation cannot be null.");
        let h = this.expandToIndex(t);
        if (h) for (; h.next; ) h = h.next;
        let l = this.trackEntry(t, s, i, h);
        return h ? (h.next = l, l.previous = h, r <= 0 && (r = Math.max(r + h.getTrackComplete() - l.mixDuration, 0))) : (this.setCurrent(t, l, true), this.queue.drain(), r < 0 && (r = 0)), l.delay = r, l;
      }
      setEmptyAnimation(t, s = 0) {
        let i = this.setAnimationWith(t, Ce.emptyAnimation(), false);
        return i.mixDuration = s, i.trackEnd = s, i;
      }
      addEmptyAnimation(t, s = 0, i = 0) {
        let r = this.addAnimationWith(t, Ce.emptyAnimation(), false, i);
        return i <= 0 && (r.delay = Math.max(r.delay + r.mixDuration - s, 0)), r.mixDuration = s, r.trackEnd = s, r;
      }
      setEmptyAnimations(t = 0) {
        let s = this.queue.drainDisabled;
        this.queue.drainDisabled = true;
        for (let i = 0, r = this.tracks.length; i < r; i++) {
          let h = this.tracks[i];
          h && this.setEmptyAnimation(h.trackIndex, t);
        }
        this.queue.drainDisabled = s, this.queue.drain();
      }
      expandToIndex(t) {
        return t < this.tracks.length ? this.tracks[t] : (L.ensureArrayCapacity(this.tracks, t + 1, null), this.tracks.length = t + 1, null);
      }
      trackEntry(t, s, i, r) {
        let h = this.trackEntryPool.obtain();
        return h.reset(), h.trackIndex = t, h.animation = s, h.loop = i, h.holdPrevious = false, h.reverse = false, h.shortestRotation = false, h.eventThreshold = 0, h.alphaAttachmentThreshold = 0, h.mixAttachmentThreshold = 0, h.mixDrawOrderThreshold = 0, h.animationStart = 0, h.animationEnd = s.duration, h.animationLast = -1, h.nextAnimationLast = -1, h.delay = 0, h.trackTime = 0, h.trackLast = -1, h.nextTrackLast = -1, h.trackEnd = Number.MAX_VALUE, h.timeScale = 1, h.alpha = 1, h.mixTime = 0, h.mixDuration = r ? this.data.getMix(r.animation, s) : 0, h.interruptAlpha = 1, h.totalAlpha = 0, h.mixBlend = 2, h;
      }
      clearNext(t) {
        let s = t.next;
        for (; s; ) this.queue.dispose(s), s = s.next;
        t.next = null;
      }
      _animationsChanged() {
        this.animationsChanged = false, this.propertyIDs.clear();
        let t = this.tracks;
        for (let s = 0, i = t.length; s < i; s++) {
          let r = t[s];
          if (r) {
            for (; r.mixingFrom; ) r = r.mixingFrom;
            do
              (!r.mixingTo || r.mixBlend != 3) && this.computeHold(r), r = r.mixingTo;
            while (r);
          }
        }
      }
      computeHold(t) {
        let s = t.mixingTo, i = t.animation.timelines, r = t.animation.timelines.length, h = t.timelineMode;
        h.length = r;
        let l = t.timelineHoldMix;
        l.length = 0;
        let n = this.propertyIDs;
        if (s && s.holdPrevious) {
          for (let a = 0; a < r; a++) h[a] = n.addAll(i[a].getPropertyIds()) ? he : ls;
          return;
        }
        t: for (let a = 0; a < r; a++) {
          let o = i[a], c = o.getPropertyIds();
          if (!n.addAll(c)) h[a] = oe;
          else if (!s || o instanceof Ot || o instanceof zt || o instanceof le || !s.animation.hasTimeline(c)) h[a] = as;
          else {
            for (let d = s.mixingTo; d; d = d.mixingTo) if (!d.animation.hasTimeline(c)) {
              if (t.mixDuration > 0) {
                h[a] = ti, l[a] = d;
                continue t;
              }
              break;
            }
            h[a] = he;
          }
        }
      }
      getCurrent(t) {
        return t >= this.tracks.length ? null : this.tracks[t];
      }
      addListener(t) {
        if (!t) throw new Error("listener cannot be null.");
        this.listeners.push(t);
      }
      removeListener(t) {
        let s = this.listeners.indexOf(t);
        s >= 0 && this.listeners.splice(s, 1);
      }
      clearListeners() {
        this.listeners.length = 0;
      }
      clearListenerNotifications() {
        this.queue.clear();
      }
    }, Js = class {
      animation = null;
      previous = null;
      next = null;
      mixingFrom = null;
      mixingTo = null;
      listener = null;
      trackIndex = 0;
      loop = false;
      holdPrevious = false;
      reverse = false;
      shortestRotation = false;
      eventThreshold = 0;
      mixAttachmentThreshold = 0;
      alphaAttachmentThreshold = 0;
      mixDrawOrderThreshold = 0;
      animationStart = 0;
      animationEnd = 0;
      animationLast = 0;
      nextAnimationLast = 0;
      delay = 0;
      trackTime = 0;
      trackLast = 0;
      nextTrackLast = 0;
      trackEnd = 0;
      timeScale = 0;
      alpha = 0;
      mixTime = 0;
      _mixDuration = 0;
      interruptAlpha = 0;
      totalAlpha = 0;
      get mixDuration() {
        return this._mixDuration;
      }
      set mixDuration(e) {
        this._mixDuration = e;
      }
      setMixDurationWithDelay(e, t) {
        this._mixDuration = e, t <= 0 && (this.previous != null ? t = Math.max(t + this.previous.getTrackComplete() - e, 0) : t = 0), this.delay = t;
      }
      mixBlend = 2;
      timelineMode = new Array();
      timelineHoldMix = new Array();
      timelinesRotation = new Array();
      reset() {
        this.next = null, this.previous = null, this.mixingFrom = null, this.mixingTo = null, this.animation = null, this.listener = null, this.timelineMode.length = 0, this.timelineHoldMix.length = 0, this.timelinesRotation.length = 0;
      }
      getAnimationTime() {
        if (this.loop) {
          let e = this.animationEnd - this.animationStart;
          return e == 0 ? this.animationStart : this.trackTime % e + this.animationStart;
        }
        return Math.min(this.trackTime + this.animationStart, this.animationEnd);
      }
      setAnimationLast(e) {
        this.animationLast = e, this.nextAnimationLast = e;
      }
      isComplete() {
        return this.trackTime >= this.animationEnd - this.animationStart;
      }
      resetRotationDirections() {
        this.timelinesRotation.length = 0;
      }
      getTrackComplete() {
        let e = this.animationEnd - this.animationStart;
        if (e != 0) {
          if (this.loop) return e * (1 + (this.trackTime / e | 0));
          if (this.trackTime < e) return e;
        }
        return this.trackTime;
      }
      wasApplied() {
        return this.nextTrackLast != -1;
      }
      isNextReady() {
        return this.next != null && this.nextTrackLast - this.next.delay >= 0;
      }
    }, Qs = class {
      objects = [];
      drainDisabled = false;
      animState;
      constructor(e) {
        this.animState = e;
      }
      start(e) {
        this.objects.push(0), this.objects.push(e), this.animState.animationsChanged = true;
      }
      interrupt(e) {
        this.objects.push(1), this.objects.push(e);
      }
      end(e) {
        this.objects.push(2), this.objects.push(e), this.animState.animationsChanged = true;
      }
      dispose(e) {
        this.objects.push(3), this.objects.push(e);
      }
      complete(e) {
        this.objects.push(4), this.objects.push(e);
      }
      event(e, t) {
        this.objects.push(5), this.objects.push(e), this.objects.push(t);
      }
      drain() {
        if (this.drainDisabled) return;
        this.drainDisabled = true;
        let e = this.objects, t = this.animState.listeners;
        for (let s = 0; s < e.length; s += 2) {
          let i = e[s], r = e[s + 1];
          switch (i) {
            case 0:
              r.listener && r.listener.start && r.listener.start(r);
              for (let l = 0; l < t.length; l++) {
                let n = t[l];
                n.start && n.start(r);
              }
              break;
            case 1:
              r.listener && r.listener.interrupt && r.listener.interrupt(r);
              for (let l = 0; l < t.length; l++) {
                let n = t[l];
                n.interrupt && n.interrupt(r);
              }
              break;
            case 2:
              r.listener && r.listener.end && r.listener.end(r);
              for (let l = 0; l < t.length; l++) {
                let n = t[l];
                n.end && n.end(r);
              }
            case 3:
              r.listener && r.listener.dispose && r.listener.dispose(r);
              for (let l = 0; l < t.length; l++) {
                let n = t[l];
                n.dispose && n.dispose(r);
              }
              this.animState.trackEntryPool.free(r);
              break;
            case 4:
              r.listener && r.listener.complete && r.listener.complete(r);
              for (let l = 0; l < t.length; l++) {
                let n = t[l];
                n.complete && n.complete(r);
              }
              break;
            case 5:
              let h = e[s++ + 2];
              r.listener && r.listener.event && r.listener.event(r, h);
              for (let l = 0; l < t.length; l++) {
                let n = t[l];
                n.event && n.event(r, h);
              }
              break;
          }
        }
        this.clear(), this.drainDisabled = false;
      }
      clear() {
        this.objects.length = 0;
      }
    }, $s = ((e) => (e[e.start = 0] = "start", e[e.interrupt = 1] = "interrupt", e[e.end = 2] = "end", e[e.dispose = 3] = "dispose", e[e.complete = 4] = "complete", e[e.event = 5] = "event", e))($s || {}), ir = class {
      start(e) {
      }
      interrupt(e) {
      }
      end(e) {
      }
      dispose(e) {
      }
      complete(e) {
      }
      event(e, t) {
      }
    }, oe = 0, as = 1, ls = 2, he = 3, ti = 4, os = 1, ei = 2, rr = class {
      skeletonData;
      animationToMixTime = {};
      defaultMix = 0;
      constructor(e) {
        if (!e) throw new Error("skeletonData cannot be null.");
        this.skeletonData = e;
      }
      setMix(e, t, s) {
        let i = this.skeletonData.findAnimation(e);
        if (!i) throw new Error("Animation not found: " + e);
        let r = this.skeletonData.findAnimation(t);
        if (!r) throw new Error("Animation not found: " + t);
        this.setMixWith(i, r, s);
      }
      setMixWith(e, t, s) {
        if (!e) throw new Error("from cannot be null.");
        if (!t) throw new Error("to cannot be null.");
        let i = e.name + "." + t.name;
        this.animationToMixTime[i] = s;
      }
      getMix(e, t) {
        let s = e.name + "." + t.name, i = this.animationToMixTime[s];
        return i === void 0 ? this.defaultMix : i;
      }
    }, hs = class Ni extends Yt {
      color = new tt(1, 1, 1, 1);
      constructor(t) {
        super(t);
      }
      copy() {
        let t = new Ni(this.name);
        return this.copyTo(t), t.color.setFromColor(this.color), t;
      }
    }, $t = class Ui extends Yt {
      endSlot = null;
      color = new tt(0.2275, 0.2275, 0.8078, 1);
      constructor(t) {
        super(t);
      }
      copy() {
        let t = new Ui(this.name);
        return this.copyTo(t), t.endSlot = this.endSlot, t.color.setFromColor(this.color), t;
      }
    }, cs = class {
      _image;
      constructor(e) {
        this._image = e;
      }
      getImage() {
        return this._image;
      }
    }, ce = ((e) => (e[e.Nearest = 9728] = "Nearest", e[e.Linear = 9729] = "Linear", e[e.MipMap = 9987] = "MipMap", e[e.MipMapNearestNearest = 9984] = "MipMapNearestNearest", e[e.MipMapLinearNearest = 9985] = "MipMapLinearNearest", e[e.MipMapNearestLinear = 9986] = "MipMapNearestLinear", e[e.MipMapLinearLinear = 9987] = "MipMapLinearLinear", e))(ce || {}), si = ((e) => (e[e.MirroredRepeat = 33648] = "MirroredRepeat", e[e.ClampToEdge = 33071] = "ClampToEdge", e[e.Repeat = 10497] = "Repeat", e))(si || {}), ii = class {
      texture;
      u = 0;
      v = 0;
      u2 = 0;
      v2 = 0;
      width = 0;
      height = 0;
      degrees = 0;
      offsetX = 0;
      offsetY = 0;
      originalWidth = 0;
      originalHeight = 0;
    }, nr = class extends cs {
      setFilters(e, t) {
      }
      setWraps(e, t) {
      }
      dispose() {
      }
    }, ds = class {
      pages = new Array();
      regions = new Array();
      constructor(e) {
        let t = new ar(e), s = new Array(4), i = {};
        i.size = (o) => {
          o.width = parseInt(s[1]), o.height = parseInt(s[2]);
        }, i.format = () => {
        }, i.filter = (o) => {
          o.minFilter = L.enumValue(ce, s[1]), o.magFilter = L.enumValue(ce, s[2]);
        }, i.repeat = (o) => {
          s[1].indexOf("x") != -1 && (o.uWrap = 10497), s[1].indexOf("y") != -1 && (o.vWrap = 10497);
        }, i.pma = (o) => {
          o.pma = s[1] == "true";
        };
        var r = {};
        r.xy = (o) => {
          o.x = parseInt(s[1]), o.y = parseInt(s[2]);
        }, r.size = (o) => {
          o.width = parseInt(s[1]), o.height = parseInt(s[2]);
        }, r.bounds = (o) => {
          o.x = parseInt(s[1]), o.y = parseInt(s[2]), o.width = parseInt(s[3]), o.height = parseInt(s[4]);
        }, r.offset = (o) => {
          o.offsetX = parseInt(s[1]), o.offsetY = parseInt(s[2]);
        }, r.orig = (o) => {
          o.originalWidth = parseInt(s[1]), o.originalHeight = parseInt(s[2]);
        }, r.offsets = (o) => {
          o.offsetX = parseInt(s[1]), o.offsetY = parseInt(s[2]), o.originalWidth = parseInt(s[3]), o.originalHeight = parseInt(s[4]);
        }, r.rotate = (o) => {
          let c = s[1];
          c == "true" ? o.degrees = 90 : c != "false" && (o.degrees = parseInt(c));
        }, r.index = (o) => {
          o.index = parseInt(s[1]);
        };
        let h = t.readLine();
        for (; h && h.trim().length == 0; ) h = t.readLine();
        for (; !(!h || h.trim().length == 0 || t.readEntry(s, h) == 0); ) h = t.readLine();
        let l = null, n = null, a = null;
        for (; h !== null; ) if (h.trim().length == 0) l = null, h = t.readLine();
        else if (l) {
          let o = new fs(l, h);
          for (; ; ) {
            let c = t.readEntry(s, h = t.readLine());
            if (c == 0) break;
            let d = r[s[0]];
            if (d) d(o);
            else {
              n || (n = []), a || (a = []), n.push(s[0]);
              let f = [];
              for (let m = 0; m < c; m++) f.push(parseInt(s[m + 1]));
              a.push(f);
            }
          }
          o.originalWidth == 0 && o.originalHeight == 0 && (o.originalWidth = o.width, o.originalHeight = o.height), n && n.length > 0 && a && a.length > 0 && (o.names = n, o.values = a, n = null, a = null), o.u = o.x / l.width, o.v = o.y / l.height, o.degrees == 90 ? (o.u2 = (o.x + o.height) / l.width, o.v2 = (o.y + o.width) / l.height) : (o.u2 = (o.x + o.width) / l.width, o.v2 = (o.y + o.height) / l.height), this.regions.push(o);
        } else {
          for (l = new ri(h.trim()); t.readEntry(s, h = t.readLine()) != 0; ) {
            let o = i[s[0]];
            o && o(l);
          }
          this.pages.push(l);
        }
      }
      findRegion(e) {
        for (let t = 0; t < this.regions.length; t++) if (this.regions[t].name == e) return this.regions[t];
        return null;
      }
      setTextures(e, t = "") {
        for (let s of this.pages) s.setTexture(e.get(t + s.name));
      }
      dispose() {
        var _a;
        for (let e = 0; e < this.pages.length; e++) (_a = this.pages[e].texture) == null ? void 0 : _a.dispose();
      }
    }, ar = class {
      lines;
      index = 0;
      constructor(e) {
        this.lines = e.split(/\r\n|\r|\n/);
      }
      readLine() {
        return this.index >= this.lines.length ? null : this.lines[this.index++];
      }
      readEntry(e, t) {
        if (!t || (t = t.trim(), t.length == 0)) return 0;
        let s = t.indexOf(":");
        if (s == -1) return 0;
        e[0] = t.substr(0, s).trim();
        for (let i = 1, r = s + 1; ; i++) {
          let h = t.indexOf(",", r);
          if (h == -1) return e[i] = t.substr(r).trim(), i;
          if (e[i] = t.substr(r, h - r).trim(), r = h + 1, i == 4) return 4;
        }
      }
    }, ri = class {
      name;
      minFilter = 9728;
      magFilter = 9728;
      uWrap = 33071;
      vWrap = 33071;
      texture = null;
      width = 0;
      height = 0;
      pma = false;
      regions = new Array();
      constructor(e) {
        this.name = e;
      }
      setTexture(e) {
        this.texture = e, e.setFilters(this.minFilter, this.magFilter), e.setWraps(this.uWrap, this.vWrap);
        for (let t of this.regions) t.texture = e;
      }
    }, fs = class extends ii {
      page;
      name;
      x = 0;
      y = 0;
      offsetX = 0;
      offsetY = 0;
      originalWidth = 0;
      originalHeight = 0;
      index = 0;
      degrees = 0;
      names = null;
      values = null;
      constructor(e, t) {
        super(), this.page = e, this.name = t, e.regions.push(this);
      }
    }, Wt = class Ds extends Yt {
      region = null;
      path;
      regionUVs = [];
      uvs = [];
      triangles = [];
      color = new tt(1, 1, 1, 1);
      width = 0;
      height = 0;
      hullLength = 0;
      edges = [];
      parentMesh = null;
      sequence = null;
      tempColor = new tt(0, 0, 0, 0);
      constructor(t, s) {
        super(t), this.path = s;
      }
      updateRegion() {
        if (!this.region) throw new Error("Region not set.");
        let t = this.regionUVs;
        (!this.uvs || this.uvs.length != t.length) && (this.uvs = L.newFloatArray(t.length));
        let s = this.uvs, i = this.uvs.length, r = this.region.u, h = this.region.v, l = 0, n = 0;
        if (this.region instanceof fs) {
          let a = this.region, o = a.page, c = o.width, d = o.height;
          switch (a.degrees) {
            case 90:
              r -= (a.originalHeight - a.offsetY - a.height) / c, h -= (a.originalWidth - a.offsetX - a.width) / d, l = a.originalHeight / c, n = a.originalWidth / d;
              for (let f = 0; f < i; f += 2) s[f] = r + t[f + 1] * l, s[f + 1] = h + (1 - t[f]) * n;
              return;
            case 180:
              r -= (a.originalWidth - a.offsetX - a.width) / c, h -= a.offsetY / d, l = a.originalWidth / c, n = a.originalHeight / d;
              for (let f = 0; f < i; f += 2) s[f] = r + (1 - t[f]) * l, s[f + 1] = h + (1 - t[f + 1]) * n;
              return;
            case 270:
              r -= a.offsetY / c, h -= a.offsetX / d, l = a.originalHeight / c, n = a.originalWidth / d;
              for (let f = 0; f < i; f += 2) s[f] = r + (1 - t[f + 1]) * l, s[f + 1] = h + t[f] * n;
              return;
          }
          r -= a.offsetX / c, h -= (a.originalHeight - a.offsetY - a.height) / d, l = a.originalWidth / c, n = a.originalHeight / d;
        } else this.region ? (l = this.region.u2 - r, n = this.region.v2 - h) : (r = h = 0, l = n = 1);
        for (let a = 0; a < i; a += 2) s[a] = r + t[a] * l, s[a + 1] = h + t[a + 1] * n;
      }
      getParentMesh() {
        return this.parentMesh;
      }
      setParentMesh(t) {
        this.parentMesh = t, t && (this.bones = t.bones, this.vertices = t.vertices, this.worldVerticesLength = t.worldVerticesLength, this.regionUVs = t.regionUVs, this.triangles = t.triangles, this.hullLength = t.hullLength, this.worldVerticesLength = t.worldVerticesLength);
      }
      copy() {
        if (this.parentMesh) return this.newLinkedMesh();
        let t = new Ds(this.name, this.path);
        return t.region = this.region, t.color.setFromColor(this.color), this.copyTo(t), t.regionUVs = new Array(this.regionUVs.length), L.arrayCopy(this.regionUVs, 0, t.regionUVs, 0, this.regionUVs.length), t.uvs = this.uvs instanceof Float32Array ? L.newFloatArray(this.uvs.length) : new Array(this.uvs.length), L.arrayCopy(this.uvs, 0, t.uvs, 0, this.uvs.length), t.triangles = new Array(this.triangles.length), L.arrayCopy(this.triangles, 0, t.triangles, 0, this.triangles.length), t.hullLength = this.hullLength, t.sequence = this.sequence != null ? this.sequence.copy() : null, this.edges && (t.edges = new Array(this.edges.length), L.arrayCopy(this.edges, 0, t.edges, 0, this.edges.length)), t.width = this.width, t.height = this.height, t;
      }
      computeWorldVertices(t, s, i, r, h, l) {
        this.sequence != null && this.sequence.apply(t, this), super.computeWorldVertices(t, s, i, r, h, l);
      }
      newLinkedMesh() {
        let t = new Ds(this.name, this.path);
        return t.region = this.region, t.color.setFromColor(this.color), t.timelineAttachment = this.timelineAttachment, t.setParentMesh(this.parentMesh ? this.parentMesh : this), t.region != null && t.updateRegion(), t;
      }
    }, qt = class zi extends Yt {
      lengths = [];
      closed = false;
      constantSpeed = false;
      color = new tt(1, 1, 1, 1);
      constructor(t) {
        super(t);
      }
      copy() {
        let t = new zi(this.name);
        return this.copyTo(t), t.lengths = new Array(this.lengths.length), L.arrayCopy(this.lengths, 0, t.lengths, 0, this.lengths.length), t.closed = closed, t.constantSpeed = this.constantSpeed, t.color.setFromColor(this.color), t;
      }
    }, ni = class Wi extends Yt {
      x = 0;
      y = 0;
      rotation = 0;
      color = new tt(0.38, 0.94, 0, 1);
      constructor(t) {
        super(t);
      }
      computeWorldPosition(t, s) {
        return s.x = this.x * t.a + this.y * t.b + t.worldX, s.y = this.x * t.c + this.y * t.d + t.worldY, s;
      }
      computeWorldRotation(t) {
        const s = this.rotation * P.degRad, i = Math.cos(s), r = Math.sin(s), h = i * t.a + r * t.b, l = i * t.c + r * t.d;
        return P.atan2Deg(l, h);
      }
      copy() {
        let t = new Wi(this.name);
        return t.x = this.x, t.y = this.y, t.rotation = this.rotation, t.color.setFromColor(this.color), t;
      }
    }, te = class qi extends Re {
      x = 0;
      y = 0;
      scaleX = 1;
      scaleY = 1;
      rotation = 0;
      width = 0;
      height = 0;
      color = new tt(1, 1, 1, 1);
      path;
      region = null;
      sequence = null;
      offset = L.newFloatArray(8);
      uvs = L.newFloatArray(8);
      tempColor = new tt(1, 1, 1, 1);
      constructor(t, s) {
        super(t), this.path = s;
      }
      updateRegion() {
        if (!this.region) throw new Error("Region not set.");
        let t = this.region, s = this.uvs;
        if (t == null) {
          s[0] = 0, s[1] = 0, s[2] = 0, s[3] = 1, s[4] = 1, s[5] = 1, s[6] = 1, s[7] = 0;
          return;
        }
        let i = this.width / this.region.originalWidth * this.scaleX, r = this.height / this.region.originalHeight * this.scaleY, h = -this.width / 2 * this.scaleX + this.region.offsetX * i, l = -this.height / 2 * this.scaleY + this.region.offsetY * r, n = h + this.region.width * i, a = l + this.region.height * r, o = this.rotation * P.degRad, c = Math.cos(o), d = Math.sin(o), f = this.x, m = this.y, u = h * c + f, g = h * d, w = l * c + m, b = l * d, x = n * c + f, p = n * d, v = a * c + m, y = a * d, A = this.offset;
        A[0] = u - b, A[1] = w + g, A[2] = u - y, A[3] = v + g, A[4] = x - y, A[5] = v + p, A[6] = x - b, A[7] = w + p, t.degrees == 90 ? (s[0] = t.u2, s[1] = t.v2, s[2] = t.u, s[3] = t.v2, s[4] = t.u, s[5] = t.v, s[6] = t.u2, s[7] = t.v) : (s[0] = t.u, s[1] = t.v2, s[2] = t.u, s[3] = t.v, s[4] = t.u2, s[5] = t.v, s[6] = t.u2, s[7] = t.v2);
      }
      computeWorldVertices(t, s, i, r) {
        this.sequence != null && this.sequence.apply(t, this);
        let h = t.bone, l = this.offset, n = h.worldX, a = h.worldY, o = h.a, c = h.b, d = h.c, f = h.d, m = 0, u = 0;
        m = l[0], u = l[1], s[i] = m * o + u * c + n, s[i + 1] = m * d + u * f + a, i += r, m = l[2], u = l[3], s[i] = m * o + u * c + n, s[i + 1] = m * d + u * f + a, i += r, m = l[4], u = l[5], s[i] = m * o + u * c + n, s[i + 1] = m * d + u * f + a, i += r, m = l[6], u = l[7], s[i] = m * o + u * c + n, s[i + 1] = m * d + u * f + a;
      }
      copy() {
        let t = new qi(this.name, this.path);
        return t.region = this.region, t.x = this.x, t.y = this.y, t.scaleX = this.scaleX, t.scaleY = this.scaleY, t.rotation = this.rotation, t.width = this.width, t.height = this.height, L.arrayCopy(this.uvs, 0, t.uvs, 0, 8), L.arrayCopy(this.offset, 0, t.offset, 0, 8), t.color.setFromColor(this.color), t.sequence = this.sequence != null ? this.sequence.copy() : null, t;
      }
      static X1 = 0;
      static Y1 = 1;
      static C1R = 2;
      static C1G = 3;
      static C1B = 4;
      static C1A = 5;
      static U1 = 6;
      static V1 = 7;
      static X2 = 8;
      static Y2 = 9;
      static C2R = 10;
      static C2G = 11;
      static C2B = 12;
      static C2A = 13;
      static U2 = 14;
      static V2 = 15;
      static X3 = 16;
      static Y3 = 17;
      static C3R = 18;
      static C3G = 19;
      static C3B = 20;
      static C3A = 21;
      static U3 = 22;
      static V3 = 23;
      static X4 = 24;
      static Y4 = 25;
      static C4R = 26;
      static C4G = 27;
      static C4B = 28;
      static C4A = 29;
      static U4 = 30;
      static V4 = 31;
    }, lr = class {
      atlas;
      constructor(e) {
        this.atlas = e;
      }
      loadSequence(e, t, s) {
        let i = s.regions;
        for (let r = 0, h = i.length; r < h; r++) {
          let l = s.getPath(t, r), n = this.atlas.findRegion(l);
          if (n == null) throw new Error("Region not found in atlas: " + l + " (sequence: " + e + ")");
          i[r] = n;
        }
      }
      newRegionAttachment(e, t, s, i) {
        let r = new te(t, s);
        if (i != null) this.loadSequence(t, s, i);
        else {
          let h = this.atlas.findRegion(s);
          if (!h) throw new Error("Region not found in atlas: " + s + " (region attachment: " + t + ")");
          r.region = h;
        }
        return r;
      }
      newMeshAttachment(e, t, s, i) {
        let r = new Wt(t, s);
        if (i != null) this.loadSequence(t, s, i);
        else {
          let h = this.atlas.findRegion(s);
          if (!h) throw new Error("Region not found in atlas: " + s + " (mesh attachment: " + t + ")");
          r.region = h;
        }
        return r;
      }
      newBoundingBoxAttachment(e, t) {
        return new hs(t);
      }
      newPathAttachment(e, t) {
        return new qt(t);
      }
      newPointAttachment(e, t) {
        return new ni(t);
      }
      newClippingAttachment(e, t) {
        return new $t(t);
      }
    }, us = class {
      index = 0;
      name;
      parent = null;
      length = 0;
      x = 0;
      y = 0;
      rotation = 0;
      scaleX = 1;
      scaleY = 1;
      shearX = 0;
      shearY = 0;
      inherit = 0;
      skinRequired = false;
      color = new tt();
      icon;
      visible = false;
      constructor(e, t, s) {
        if (e < 0) throw new Error("index must be >= 0.");
        if (!t) throw new Error("name cannot be null.");
        this.index = e, this.name = t, this.parent = s;
      }
    }, de = ((e) => (e[e.Normal = 0] = "Normal", e[e.OnlyTranslation = 1] = "OnlyTranslation", e[e.NoRotationOrReflection = 2] = "NoRotationOrReflection", e[e.NoScale = 3] = "NoScale", e[e.NoScaleOrReflection = 4] = "NoScaleOrReflection", e))(de || {}), ms = class {
      data;
      skeleton;
      parent = null;
      children = new Array();
      x = 0;
      y = 0;
      rotation = 0;
      scaleX = 0;
      scaleY = 0;
      shearX = 0;
      shearY = 0;
      ax = 0;
      ay = 0;
      arotation = 0;
      ascaleX = 0;
      ascaleY = 0;
      ashearX = 0;
      ashearY = 0;
      a = 0;
      b = 0;
      c = 0;
      d = 0;
      worldY = 0;
      worldX = 0;
      inherit = 0;
      sorted = false;
      active = false;
      constructor(e, t, s) {
        if (!e) throw new Error("data cannot be null.");
        if (!t) throw new Error("skeleton cannot be null.");
        this.data = e, this.skeleton = t, this.parent = s, this.setToSetupPose();
      }
      isActive() {
        return this.active;
      }
      update(e) {
        this.updateWorldTransformWith(this.ax, this.ay, this.arotation, this.ascaleX, this.ascaleY, this.ashearX, this.ashearY);
      }
      updateWorldTransform() {
        this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
      }
      updateWorldTransformWith(e, t, s, i, r, h, l) {
        this.ax = e, this.ay = t, this.arotation = s, this.ascaleX = i, this.ascaleY = r, this.ashearX = h, this.ashearY = l;
        let n = this.parent;
        if (!n) {
          let f = this.skeleton;
          const m = f.scaleX, u = f.scaleY, g = (s + h) * P.degRad, w = (s + 90 + l) * P.degRad;
          this.a = Math.cos(g) * i * m, this.b = Math.cos(w) * r * m, this.c = Math.sin(g) * i * u, this.d = Math.sin(w) * r * u, this.worldX = e * m + f.x, this.worldY = t * u + f.y;
          return;
        }
        let a = n.a, o = n.b, c = n.c, d = n.d;
        switch (this.worldX = a * e + o * t + n.worldX, this.worldY = c * e + d * t + n.worldY, this.inherit) {
          case 0: {
            const f = (s + h) * P.degRad, m = (s + 90 + l) * P.degRad, u = Math.cos(f) * i, g = Math.cos(m) * r, w = Math.sin(f) * i, b = Math.sin(m) * r;
            this.a = a * u + o * w, this.b = a * g + o * b, this.c = c * u + d * w, this.d = c * g + d * b;
            return;
          }
          case 1: {
            const f = (s + h) * P.degRad, m = (s + 90 + l) * P.degRad;
            this.a = Math.cos(f) * i, this.b = Math.cos(m) * r, this.c = Math.sin(f) * i, this.d = Math.sin(m) * r;
            break;
          }
          case 2: {
            let f = 1 / this.skeleton.scaleX, m = 1 / this.skeleton.scaleY;
            a *= f, c *= m;
            let u = a * a + c * c, g = 0;
            u > 1e-4 ? (u = Math.abs(a * d * m - o * f * c) / u, o = c * u, d = a * u, g = Math.atan2(c, a) * P.radDeg) : (a = 0, c = 0, g = 90 - Math.atan2(d, o) * P.radDeg);
            const w = (s + h - g) * P.degRad, b = (s + l - g + 90) * P.degRad, x = Math.cos(w) * i, p = Math.cos(b) * r, v = Math.sin(w) * i, y = Math.sin(b) * r;
            this.a = a * x - o * v, this.b = a * p - o * y, this.c = c * x + d * v, this.d = c * p + d * y;
            break;
          }
          case 3:
          case 4: {
            s *= P.degRad;
            const f = Math.cos(s), m = Math.sin(s);
            let u = (a * f + o * m) / this.skeleton.scaleX, g = (c * f + d * m) / this.skeleton.scaleY, w = Math.sqrt(u * u + g * g);
            w > 1e-5 && (w = 1 / w), u *= w, g *= w, w = Math.sqrt(u * u + g * g), this.inherit == 3 && a * d - o * c < 0 != (this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0) && (w = -w), s = Math.PI / 2 + Math.atan2(g, u);
            const b = Math.cos(s) * w, x = Math.sin(s) * w;
            h *= P.degRad, l = (90 + l) * P.degRad;
            const p = Math.cos(h) * i, v = Math.cos(l) * r, y = Math.sin(h) * i, A = Math.sin(l) * r;
            this.a = u * p + b * y, this.b = u * v + b * A, this.c = g * p + x * y, this.d = g * v + x * A;
            break;
          }
        }
        this.a *= this.skeleton.scaleX, this.b *= this.skeleton.scaleX, this.c *= this.skeleton.scaleY, this.d *= this.skeleton.scaleY;
      }
      setToSetupPose() {
        let e = this.data;
        this.x = e.x, this.y = e.y, this.rotation = e.rotation, this.scaleX = e.scaleX, this.scaleY = e.scaleY, this.shearX = e.shearX, this.shearY = e.shearY, this.inherit = e.inherit;
      }
      updateAppliedTransform() {
        let e = this.parent;
        if (!e) {
          this.ax = this.worldX - this.skeleton.x, this.ay = this.worldY - this.skeleton.y, this.arotation = Math.atan2(this.c, this.a) * P.radDeg, this.ascaleX = Math.sqrt(this.a * this.a + this.c * this.c), this.ascaleY = Math.sqrt(this.b * this.b + this.d * this.d), this.ashearX = 0, this.ashearY = Math.atan2(this.a * this.b + this.c * this.d, this.a * this.d - this.b * this.c) * P.radDeg;
          return;
        }
        let t = e.a, s = e.b, i = e.c, r = e.d, h = 1 / (t * r - s * i), l = r * h, n = s * h, a = i * h, o = t * h, c = this.worldX - e.worldX, d = this.worldY - e.worldY;
        this.ax = c * l - d * n, this.ay = d * o - c * a;
        let f, m, u, g;
        if (this.inherit == 1) f = this.a, m = this.b, u = this.c, g = this.d;
        else {
          switch (this.inherit) {
            case 2: {
              let v = Math.abs(t * r - s * i) / (t * t + i * i);
              s = -i * this.skeleton.scaleX * v / this.skeleton.scaleY, r = t * this.skeleton.scaleY * v / this.skeleton.scaleX, h = 1 / (t * r - s * i), l = r * h, n = s * h;
              break;
            }
            case 3:
            case 4:
              let w = P.cosDeg(this.rotation), b = P.sinDeg(this.rotation);
              t = (t * w + s * b) / this.skeleton.scaleX, i = (i * w + r * b) / this.skeleton.scaleY;
              let x = Math.sqrt(t * t + i * i);
              x > 1e-5 && (x = 1 / x), t *= x, i *= x, x = Math.sqrt(t * t + i * i), this.inherit == 3 && h < 0 != (this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0) && (x = -x);
              let p = P.PI / 2 + Math.atan2(i, t);
              s = Math.cos(p) * x, r = Math.sin(p) * x, h = 1 / (t * r - s * i), l = r * h, n = s * h, a = i * h, o = t * h;
          }
          f = l * this.a - n * this.c, m = l * this.b - n * this.d, u = o * this.c - a * this.a, g = o * this.d - a * this.b;
        }
        if (this.ashearX = 0, this.ascaleX = Math.sqrt(f * f + u * u), this.ascaleX > 1e-4) {
          let w = f * g - m * u;
          this.ascaleY = w / this.ascaleX, this.ashearY = -Math.atan2(f * m + u * g, w) * P.radDeg, this.arotation = Math.atan2(u, f) * P.radDeg;
        } else this.ascaleX = 0, this.ascaleY = Math.sqrt(m * m + g * g), this.ashearY = 0, this.arotation = 90 - Math.atan2(g, m) * P.radDeg;
      }
      getWorldRotationX() {
        return Math.atan2(this.c, this.a) * P.radDeg;
      }
      getWorldRotationY() {
        return Math.atan2(this.d, this.b) * P.radDeg;
      }
      getWorldScaleX() {
        return Math.sqrt(this.a * this.a + this.c * this.c);
      }
      getWorldScaleY() {
        return Math.sqrt(this.b * this.b + this.d * this.d);
      }
      worldToLocal(e) {
        let t = 1 / (this.a * this.d - this.b * this.c), s = e.x - this.worldX, i = e.y - this.worldY;
        return e.x = s * this.d * t - i * this.b * t, e.y = i * this.a * t - s * this.c * t, e;
      }
      localToWorld(e) {
        let t = e.x, s = e.y;
        return e.x = t * this.a + s * this.b + this.worldX, e.y = t * this.c + s * this.d + this.worldY, e;
      }
      worldToParent(e) {
        if (e == null) throw new Error("world cannot be null.");
        return this.parent == null ? e : this.parent.worldToLocal(e);
      }
      parentToWorld(e) {
        if (e == null) throw new Error("world cannot be null.");
        return this.parent == null ? e : this.parent.localToWorld(e);
      }
      worldToLocalRotation(e) {
        let t = P.sinDeg(e), s = P.cosDeg(e);
        return Math.atan2(this.a * t - this.c * s, this.d * s - this.b * t) * P.radDeg + this.rotation - this.shearX;
      }
      localToWorldRotation(e) {
        e -= this.rotation - this.shearX;
        let t = P.sinDeg(e), s = P.cosDeg(e);
        return Math.atan2(s * this.c + t * this.d, s * this.a + t * this.b) * P.radDeg;
      }
      rotateWorld(e) {
        e *= P.degRad;
        const t = Math.sin(e), s = Math.cos(e), i = this.a, r = this.b;
        this.a = s * i - t * this.c, this.b = s * r - t * this.d, this.c = t * i + s * this.c, this.d = t * r + s * this.d;
      }
    }, ee = class {
      constructor(e, t, s) {
        this.name = e, this.order = t, this.skinRequired = s;
      }
    }, ai = class {
      pathPrefix = "";
      textureLoader;
      downloader;
      cache;
      errors = {};
      toLoad = 0;
      loaded = 0;
      constructor(e, t = "", s = new gs(), i = new li()) {
        this.textureLoader = e, this.pathPrefix = t, this.downloader = s, this.cache = i;
      }
      start(e) {
        return this.toLoad++, this.pathPrefix + e;
      }
      success(e, t, s) {
        this.toLoad--, this.loaded++, this.cache.assets[t] = s, this.cache.assetsRefCount[t] = (this.cache.assetsRefCount[t] || 0) + 1, e && e(t, s);
      }
      error(e, t, s) {
        this.toLoad--, this.loaded++, this.errors[t] = s, e && e(t, s);
      }
      loadAll() {
        return new Promise((t, s) => {
          let i = () => {
            if (this.isLoadingComplete()) {
              this.hasErrors() ? s(this.errors) : t(this);
              return;
            }
            requestAnimationFrame(i);
          };
          requestAnimationFrame(i);
        });
      }
      setRawDataURI(e, t) {
        this.downloader.rawDataUris[this.pathPrefix + e] = t;
      }
      loadBinary(e, t = () => {
      }, s = () => {
      }) {
        e = this.start(e), !this.reuseAssets(e, t, s) && (this.cache.assetsLoaded[e] = new Promise((i, r) => {
          this.downloader.downloadBinary(e, (h) => {
            this.success(t, e, h), i(h);
          }, (h, l) => {
            const n = `Couldn't load binary ${e}: status ${h}, ${l}`;
            this.error(s, e, n), r(n);
          });
        }));
      }
      loadText(e, t = () => {
      }, s = () => {
      }) {
        e = this.start(e), this.downloader.downloadText(e, (i) => {
          this.success(t, e, i);
        }, (i, r) => {
          this.error(s, e, `Couldn't load text ${e}: status ${i}, ${r}`);
        });
      }
      loadJson(e, t = () => {
      }, s = () => {
      }) {
        e = this.start(e), !this.reuseAssets(e, t, s) && (this.cache.assetsLoaded[e] = new Promise((i, r) => {
          this.downloader.downloadJson(e, (h) => {
            this.success(t, e, h), i(h);
          }, (h, l) => {
            const n = `Couldn't load JSON ${e}: status ${h}, ${l}`;
            this.error(s, e, n), r(n);
          });
        }));
      }
      reuseAssets(e, t = () => {
      }, s = () => {
      }) {
        const i = this.cache.assetsLoaded[e], r = i !== void 0;
        return r && (this.cache.assetsLoaded[e] = i.then((h) => (h = h instanceof Image || h instanceof ImageBitmap ? this.textureLoader(h) : h, this.success(t, e, h), h)).catch((h) => this.error(s, e, h))), r;
      }
      loadTexture(e, t = () => {
      }, s = () => {
      }) {
        e = this.start(e), !this.reuseAssets(e, t, s) && (this.cache.assetsLoaded[e] = new Promise((i, r) => {
          if (!!!(typeof window < "u" && typeof navigator < "u" && window.document)) fetch(e, { mode: "cors" }).then((n) => {
            if (n.ok) return n.blob();
            const a = `Couldn't load image: ${e}`;
            this.error(s, e, `Couldn't load image: ${e}`), r(a);
          }).then((n) => n ? createImageBitmap(n, { premultiplyAlpha: "none", colorSpaceConversion: "none" }) : null).then((n) => {
            if (n) {
              const a = this.createTexture(e, n);
              this.success(t, e, a), i(a);
            }
          });
          else {
            let n = new Image();
            n.crossOrigin = "anonymous", n.onload = () => {
              const a = this.createTexture(e, n);
              this.success(t, e, a), i(a);
            }, n.onerror = () => {
              const a = `Couldn't load image: ${e}`;
              this.error(s, e, a), r(a);
            }, this.downloader.rawDataUris[e] && (e = this.downloader.rawDataUris[e]), n.src = e;
          }
        }));
      }
      loadTextureAtlas(e, t = () => {
      }, s = () => {
      }, i) {
        let r = e.lastIndexOf("/"), h = r >= 0 ? e.substring(0, r + 1) : "";
        e = this.start(e), !this.reuseAssets(e, t, s) && (this.cache.assetsLoaded[e] = new Promise((l, n) => {
          this.downloader.downloadText(e, (a) => {
            try {
              const o = this.createTextureAtlas(e, a);
              let c = o.pages.length, d = false;
              for (let f of o.pages) this.loadTexture(i ? i[f.name] : h + f.name, (m, u) => {
                d || (f.setTexture(u), --c == 0 && (this.success(t, e, o), l(o)));
              }, (m, u) => {
                if (!d) {
                  const g = `Couldn't load texture ${e} page image: ${m}`;
                  this.error(s, e, g), n(g);
                }
                d = true;
              });
            } catch (o) {
              const c = `Couldn't parse texture atlas ${e}: ${o.message}`;
              this.error(s, e, c), n(c);
            }
          }, (a, o) => {
            const c = `Couldn't load texture atlas ${e}: status ${a}, ${o}`;
            this.error(s, e, c), n(c);
          });
        }));
      }
      loadTextureAtlasButNoTextures(e, t = () => {
      }, s = () => {
      }, i) {
        e = this.start(e), !this.reuseAssets(e, t, s) && (this.cache.assetsLoaded[e] = new Promise((r, h) => {
          this.downloader.downloadText(e, (l) => {
            try {
              const n = this.createTextureAtlas(e, l);
              this.success(t, e, n), r(n);
            } catch (n) {
              const a = `Couldn't parse texture atlas ${e}: ${n.message}`;
              this.error(s, e, a), h(a);
            }
          }, (l, n) => {
            const a = `Couldn't load texture atlas ${e}: status ${l}, ${n}`;
            this.error(s, e, a), h(a);
          });
        }));
      }
      async loadBinaryAsync(e) {
        return new Promise((t, s) => {
          this.loadBinary(e, (i, r) => t(r), (i, r) => s(r));
        });
      }
      async loadJsonAsync(e) {
        return new Promise((t, s) => {
          this.loadJson(e, (i, r) => t(r), (i, r) => s(r));
        });
      }
      async loadTextureAsync(e) {
        return new Promise((t, s) => {
          this.loadTexture(e, (i, r) => t(r), (i, r) => s(r));
        });
      }
      async loadTextureAtlasAsync(e) {
        return new Promise((t, s) => {
          this.loadTextureAtlas(e, (i, r) => t(r), (i, r) => s(r));
        });
      }
      async loadTextureAtlasButNoTexturesAsync(e) {
        return new Promise((t, s) => {
          this.loadTextureAtlasButNoTextures(e, (i, r) => t(r), (i, r) => s(r));
        });
      }
      setCache(e) {
        this.cache = e;
      }
      get(e) {
        return this.cache.assets[this.pathPrefix + e];
      }
      require(e) {
        e = this.pathPrefix + e;
        let t = this.cache.assets[e];
        if (t) return t;
        let s = this.errors[e];
        throw Error("Asset not found: " + e + (s ? `
` + s : ""));
      }
      remove(e) {
        e = this.pathPrefix + e;
        let t = this.cache.assets[e];
        return t.dispose && t.dispose(), delete this.cache.assets[e], delete this.cache.assetsRefCount[e], delete this.cache.assetsLoaded[e], t;
      }
      removeAll() {
        for (let e in this.cache.assets) {
          let t = this.cache.assets[e];
          t.dispose && t.dispose();
        }
        this.cache.assets = {}, this.cache.assetsLoaded = {}, this.cache.assetsRefCount = {};
      }
      isLoadingComplete() {
        return this.toLoad == 0;
      }
      getToLoad() {
        return this.toLoad;
      }
      getLoaded() {
        return this.loaded;
      }
      dispose() {
        this.removeAll();
      }
      disposeAsset(e) {
        const t = this.cache.assets[e];
        if (t instanceof ds) {
          t.dispose();
          return;
        }
        this.disposeAssetInternal(e);
      }
      hasErrors() {
        return Object.keys(this.errors).length > 0;
      }
      getErrors() {
        return this.errors;
      }
      disposeAssetInternal(e) {
        if (this.cache.assetsRefCount[e] > 0 && --this.cache.assetsRefCount[e] === 0) return this.remove(e);
      }
      createTextureAtlas(e, t) {
        const s = new ds(t);
        return s.dispose = () => {
          var _a;
          if (!(this.cache.assetsRefCount[e] <= 0)) {
            this.disposeAssetInternal(e);
            for (const i of s.pages) (_a = i.texture) == null ? void 0 : _a.dispose();
          }
        }, s;
      }
      createTexture(e, t) {
        const s = this.textureLoader(t), i = s.dispose.bind(s);
        return s.dispose = () => {
          this.disposeAssetInternal(e) && i();
        }, s;
      }
    }, li = class Se {
      assets = {};
      assetsRefCount = {};
      assetsLoaded = {};
      static AVAILABLE_CACHES = /* @__PURE__ */ new Map();
      static getCache(t) {
        const s = Se.AVAILABLE_CACHES.get(t);
        if (s) return s;
        const i = new Se();
        return Se.AVAILABLE_CACHES.set(t, i), i;
      }
      async addAsset(t, s) {
        this.assetsLoaded[t] = Promise.resolve(s), this.assets[t] = await s;
      }
    }, gs = class {
      callbacks = {};
      rawDataUris = {};
      dataUriToString(e) {
        if (!e.startsWith("data:")) throw new Error("Not a data URI.");
        let t = e.indexOf("base64,");
        return t != -1 ? (t += 7, atob(e.substr(t))) : e.substr(e.indexOf(",") + 1);
      }
      base64ToUint8Array(e) {
        for (var t = window.atob(e), s = t.length, i = new Uint8Array(s), r = 0; r < s; r++) i[r] = t.charCodeAt(r);
        return i;
      }
      dataUriToUint8Array(e) {
        if (!e.startsWith("data:")) throw new Error("Not a data URI.");
        let t = e.indexOf("base64,");
        if (t == -1) throw new Error("Not a binary data URI.");
        return t += 7, this.base64ToUint8Array(e.substr(t));
      }
      downloadText(e, t, s) {
        if (this.start(e, t, s)) return;
        const i = this.rawDataUris[e];
        if (i && !i.includes(".")) {
          try {
            this.finish(e, 200, this.dataUriToString(i));
          } catch (l) {
            this.finish(e, 400, JSON.stringify(l));
          }
          return;
        }
        let r = new XMLHttpRequest();
        r.overrideMimeType("text/html"), r.open("GET", i || e, true);
        let h = () => {
          this.finish(e, r.status, r.responseText);
        };
        r.onload = h, r.onerror = h, r.send();
      }
      downloadJson(e, t, s) {
        this.downloadText(e, (i) => {
          t(JSON.parse(i));
        }, s);
      }
      downloadBinary(e, t, s) {
        if (this.start(e, t, s)) return;
        const i = this.rawDataUris[e];
        if (i && !i.includes(".")) {
          try {
            this.finish(e, 200, this.dataUriToUint8Array(i));
          } catch (l) {
            this.finish(e, 400, JSON.stringify(l));
          }
          return;
        }
        let r = new XMLHttpRequest();
        r.open("GET", i || e, true), r.responseType = "arraybuffer";
        let h = () => {
          this.finish(e, r.status, r.response);
        };
        r.onload = () => {
          r.status == 200 || r.status == 0 ? this.finish(e, 200, new Uint8Array(r.response)) : h();
        }, r.onerror = h, r.send();
      }
      start(e, t, s) {
        let i = this.callbacks[e];
        try {
          if (i) return true;
          this.callbacks[e] = i = [];
        } finally {
          i.push(t, s);
        }
      }
      finish(e, t, s) {
        let i = this.callbacks[e];
        delete this.callbacks[e];
        let r = t == 200 || t == 0 ? [s] : [t, s];
        for (let h = r.length - 1, l = i.length; h < l; h += 2) i[h].apply(null, r);
      }
    }, xs = class {
      data;
      intValue = 0;
      floatValue = 0;
      stringValue = null;
      time = 0;
      volume = 0;
      balance = 0;
      constructor(e, t) {
        if (!t) throw new Error("data cannot be null.");
        this.time = e, this.data = t;
      }
    }, ps = class {
      name;
      intValue = 0;
      floatValue = 0;
      stringValue = null;
      audioPath = null;
      volume = 0;
      balance = 0;
      constructor(e) {
        this.name = e;
      }
    }, oi = class {
      data;
      bones;
      target;
      bendDirection = 0;
      compress = false;
      stretch = false;
      mix = 1;
      softness = 0;
      active = false;
      constructor(e, t) {
        if (!e) throw new Error("data cannot be null.");
        if (!t) throw new Error("skeleton cannot be null.");
        this.data = e, this.bones = new Array();
        for (let i = 0; i < e.bones.length; i++) {
          let r = t.findBone(e.bones[i].name);
          if (!r) throw new Error(`Couldn't find bone ${e.bones[i].name}`);
          this.bones.push(r);
        }
        let s = t.findBone(e.target.name);
        if (!s) throw new Error(`Couldn't find bone ${e.target.name}`);
        this.target = s, this.mix = e.mix, this.softness = e.softness, this.bendDirection = e.bendDirection, this.compress = e.compress, this.stretch = e.stretch;
      }
      isActive() {
        return this.active;
      }
      setToSetupPose() {
        const e = this.data;
        this.mix = e.mix, this.softness = e.softness, this.bendDirection = e.bendDirection, this.compress = e.compress, this.stretch = e.stretch;
      }
      update(e) {
        if (this.mix == 0) return;
        let t = this.target, s = this.bones;
        switch (s.length) {
          case 1:
            this.apply1(s[0], t.worldX, t.worldY, this.compress, this.stretch, this.data.uniform, this.mix);
            break;
          case 2:
            this.apply2(s[0], s[1], t.worldX, t.worldY, this.bendDirection, this.stretch, this.data.uniform, this.softness, this.mix);
            break;
        }
      }
      apply1(e, t, s, i, r, h, l) {
        let n = e.parent;
        if (!n) throw new Error("IK bone must have parent.");
        let a = n.a, o = n.b, c = n.c, d = n.d, f = -e.ashearX - e.arotation, m = 0, u = 0;
        switch (e.inherit) {
          case 1:
            m = (t - e.worldX) * P.signum(e.skeleton.scaleX), u = (s - e.worldY) * P.signum(e.skeleton.scaleY);
            break;
          case 2:
            let b = Math.abs(a * d - o * c) / Math.max(1e-4, a * a + c * c), x = a / e.skeleton.scaleX, p = c / e.skeleton.scaleY;
            o = -p * b * e.skeleton.scaleX, d = x * b * e.skeleton.scaleY, f += Math.atan2(p, x) * P.radDeg;
          default:
            let v = t - n.worldX, y = s - n.worldY, A = a * d - o * c;
            Math.abs(A) <= 1e-4 ? (m = 0, u = 0) : (m = (v * d - y * o) / A - e.ax, u = (y * a - v * c) / A - e.ay);
        }
        f += Math.atan2(u, m) * P.radDeg, e.ascaleX < 0 && (f += 180), f > 180 ? f -= 360 : f < -180 && (f += 360);
        let g = e.ascaleX, w = e.ascaleY;
        if (i || r) {
          switch (e.inherit) {
            case 3:
            case 4:
              m = t - e.worldX, u = s - e.worldY;
          }
          const b = e.data.length * g;
          if (b > 1e-4) {
            const x = m * m + u * u;
            if (i && x < b * b || r && x > b * b) {
              const p = (Math.sqrt(x) / b - 1) * l + 1;
              g *= p, h && (w *= p);
            }
          }
        }
        e.updateWorldTransformWith(e.ax, e.ay, e.arotation + f * l, g, w, e.ashearX, e.ashearY);
      }
      apply2(e, t, s, i, r, h, l, n, a) {
        if (e.inherit != 0 || t.inherit != 0) return;
        let o = e.ax, c = e.ay, d = e.ascaleX, f = e.ascaleY, m = d, u = f, g = t.ascaleX, w = 0, b = 0, x = 0;
        d < 0 ? (d = -d, w = 180, x = -1) : (w = 0, x = 1), f < 0 && (f = -f, x = -x), g < 0 ? (g = -g, b = 180) : b = 0;
        let p = t.ax, v = 0, y = 0, A = 0, C = e.a, S = e.b, I = e.c, Y = e.d, k = Math.abs(d - f) <= 1e-4;
        !k || h ? (v = 0, y = C * p + e.worldX, A = I * p + e.worldY) : (v = t.ay, y = C * p + S * v + e.worldX, A = I * p + Y * v + e.worldY);
        let F = e.parent;
        if (!F) throw new Error("IK parent must itself have a parent.");
        C = F.a, S = F.b, I = F.c, Y = F.d;
        let X = C * Y - S * I, E = y - F.worldX, R = A - F.worldY;
        X = Math.abs(X) <= 1e-4 ? 0 : 1 / X;
        let B = (E * Y - R * S) * X - o, st = (R * C - E * I) * X - c, et = Math.sqrt(B * B + st * st), rt = t.data.length * g, ct, ot;
        if (et < 1e-4) {
          this.apply1(e, s, i, false, h, false, a), t.updateWorldTransformWith(p, v, 0, t.ascaleX, t.ascaleY, t.ashearX, t.ashearY);
          return;
        }
        E = s - F.worldX, R = i - F.worldY;
        let ut = (E * Y - R * S) * X - o, Z = (R * C - E * I) * X - c, nt = ut * ut + Z * Z;
        if (n != 0) {
          n *= d * (g + 1) * 0.5;
          let mt = Math.sqrt(nt), pt = mt - et - rt * d + n;
          if (pt > 0) {
            let wt = Math.min(1, pt / (n * 2)) - 1;
            wt = (pt - n * (1 - wt * wt)) / mt, ut -= wt * ut, Z -= wt * Z, nt = ut * ut + Z * Z;
          }
        }
        t: if (k) {
          rt *= d;
          let mt = (nt - et * et - rt * rt) / (2 * et * rt);
          mt < -1 ? (mt = -1, ot = Math.PI * r) : mt > 1 ? (mt = 1, ot = 0, h && (C = (Math.sqrt(nt) / (et + rt) - 1) * a + 1, m *= C, l && (u *= C))) : ot = Math.acos(mt) * r, C = et + rt * mt, S = rt * Math.sin(ot), ct = Math.atan2(Z * C - ut * S, ut * C + Z * S);
        } else {
          C = d * rt, S = f * rt;
          let mt = C * C, pt = S * S, wt = Math.atan2(Z, ut);
          I = pt * et * et + mt * nt - mt * pt;
          let Mt = -2 * pt * et, jt = pt - mt;
          if (Y = Mt * Mt - 4 * jt * I, Y >= 0) {
            let Zt = Math.sqrt(Y);
            Mt < 0 && (Zt = -Zt), Zt = -(Mt + Zt) * 0.5;
            let re = Zt / jt, Li = I / Zt, ye = Math.abs(re) < Math.abs(Li) ? re : Li;
            if (re = nt - ye * ye, re >= 0) {
              R = Math.sqrt(re) * r, ct = wt - Math.atan2(R, ye), ot = Math.atan2(R / f, (ye - et) / d);
              break t;
            }
          }
          let ie = P.PI, be = et - C, Vs = be * be, Fi = 0, Xi = 0, ve = et + C, Os = ve * ve, Pi = 0;
          I = -C * et / (mt - pt), I >= -1 && I <= 1 && (I = Math.acos(I), E = C * Math.cos(I) + et, R = S * Math.sin(I), Y = E * E + R * R, Y < Vs && (ie = I, Vs = Y, be = E, Fi = R), Y > Os && (Xi = I, Os = Y, ve = E, Pi = R)), nt <= (Vs + Os) * 0.5 ? (ct = wt - Math.atan2(Fi * r, be), ot = ie * r) : (ct = wt - Math.atan2(Pi * r, ve), ot = Xi * r);
        }
        let ht = Math.atan2(v, p) * x, bt = e.arotation;
        ct = (ct - ht) * P.radDeg + w - bt, ct > 180 ? ct -= 360 : ct < -180 && (ct += 360), e.updateWorldTransformWith(o, c, bt + ct * a, m, u, 0, 0), bt = t.arotation, ot = ((ot + ht) * P.radDeg - t.ashearX) * x + b - bt, ot > 180 ? ot -= 360 : ot < -180 && (ot += 360), t.updateWorldTransformWith(p, v, bt + ot * a, t.ascaleX, t.ascaleY, t.ashearX, t.ashearY);
      }
    }, ws = class extends ee {
      bones = new Array();
      _target = null;
      set target(e) {
        this._target = e;
      }
      get target() {
        if (this._target) return this._target;
        throw new Error("BoneData not set.");
      }
      bendDirection = 0;
      compress = false;
      stretch = false;
      uniform = false;
      mix = 0;
      softness = 0;
      constructor(e) {
        super(e, 0, false);
      }
    }, bs = class extends ee {
      bones = new Array();
      _target = null;
      set target(e) {
        this._target = e;
      }
      get target() {
        if (this._target) return this._target;
        throw new Error("SlotData not set.");
      }
      positionMode = 0;
      spacingMode = 1;
      rotateMode = 1;
      offsetRotation = 0;
      position = 0;
      spacing = 0;
      mixRotate = 0;
      mixX = 0;
      mixY = 0;
      constructor(e) {
        super(e, 0, false);
      }
    }, vs = ((e) => (e[e.Fixed = 0] = "Fixed", e[e.Percent = 1] = "Percent", e))(vs || {}), ys = ((e) => (e[e.Length = 0] = "Length", e[e.Fixed = 1] = "Fixed", e[e.Percent = 2] = "Percent", e[e.Proportional = 3] = "Proportional", e))(ys || {}), As = ((e) => (e[e.Tangent = 0] = "Tangent", e[e.Chain = 1] = "Chain", e[e.ChainScale = 2] = "ChainScale", e))(As || {}), hi = class Bt {
      static NONE = -1;
      static BEFORE = -2;
      static AFTER = -3;
      static epsilon = 1e-5;
      data;
      bones;
      target;
      position = 0;
      spacing = 0;
      mixRotate = 0;
      mixX = 0;
      mixY = 0;
      spaces = new Array();
      positions = new Array();
      world = new Array();
      curves = new Array();
      lengths = new Array();
      segments = new Array();
      active = false;
      constructor(t, s) {
        if (!t) throw new Error("data cannot be null.");
        if (!s) throw new Error("skeleton cannot be null.");
        this.data = t, this.bones = new Array();
        for (let r = 0, h = t.bones.length; r < h; r++) {
          let l = s.findBone(t.bones[r].name);
          if (!l) throw new Error(`Couldn't find bone ${t.bones[r].name}.`);
          this.bones.push(l);
        }
        let i = s.findSlot(t.target.name);
        if (!i) throw new Error(`Couldn't find target bone ${t.target.name}`);
        this.target = i, this.position = t.position, this.spacing = t.spacing, this.mixRotate = t.mixRotate, this.mixX = t.mixX, this.mixY = t.mixY;
      }
      isActive() {
        return this.active;
      }
      setToSetupPose() {
        const t = this.data;
        this.position = t.position, this.spacing = t.spacing, this.mixRotate = t.mixRotate, this.mixX = t.mixX, this.mixY = t.mixY;
      }
      update(t) {
        let s = this.target.getAttachment();
        if (!(s instanceof qt)) return;
        let i = this.mixRotate, r = this.mixX, h = this.mixY;
        if (i == 0 && r == 0 && h == 0) return;
        let l = this.data, n = l.rotateMode == 0, a = l.rotateMode == 2, o = this.bones, c = o.length, d = n ? c : c + 1, f = L.setArraySize(this.spaces, d), m = a ? this.lengths = L.setArraySize(this.lengths, c) : [], u = this.spacing;
        switch (l.spacingMode) {
          case 2:
            if (a) for (let A = 0, C = d - 1; A < C; A++) {
              let S = o[A], I = S.data.length, Y = I * S.a, k = I * S.c;
              m[A] = Math.sqrt(Y * Y + k * k);
            }
            L.arrayFill(f, 1, d, u);
            break;
          case 3:
            let v = 0;
            for (let A = 0, C = d - 1; A < C; ) {
              let S = o[A], I = S.data.length;
              if (I < Bt.epsilon) a && (m[A] = 0), f[++A] = u;
              else {
                let Y = I * S.a, k = I * S.c, F = Math.sqrt(Y * Y + k * k);
                a && (m[A] = F), f[++A] = F, v += F;
              }
            }
            if (v > 0) {
              v = d / v * u;
              for (let A = 1; A < d; A++) f[A] *= v;
            }
            break;
          default:
            let y = l.spacingMode == 0;
            for (let A = 0, C = d - 1; A < C; ) {
              let S = o[A], I = S.data.length;
              if (I < Bt.epsilon) a && (m[A] = 0), f[++A] = u;
              else {
                let Y = I * S.a, k = I * S.c, F = Math.sqrt(Y * Y + k * k);
                a && (m[A] = F), f[++A] = (y ? I + u : u) * F / I;
              }
            }
        }
        let g = this.computeWorldPositions(s, d, n), w = g[0], b = g[1], x = l.offsetRotation, p = false;
        if (x == 0) p = l.rotateMode == 1;
        else {
          p = false;
          let v = this.target.bone;
          x *= v.a * v.d - v.b * v.c > 0 ? P.degRad : -0.01745329277777778;
        }
        for (let v = 0, y = 3; v < c; v++, y += 3) {
          let A = o[v];
          A.worldX += (w - A.worldX) * r, A.worldY += (b - A.worldY) * h;
          let C = g[y], S = g[y + 1], I = C - w, Y = S - b;
          if (a) {
            let k = m[v];
            if (k != 0) {
              let F = (Math.sqrt(I * I + Y * Y) / k - 1) * i + 1;
              A.a *= F, A.c *= F;
            }
          }
          if (w = C, b = S, i > 0) {
            let k = A.a, F = A.b, X = A.c, E = A.d, R = 0, B = 0, st = 0;
            if (n ? R = g[y - 1] : f[v + 1] == 0 ? R = g[y + 2] : R = Math.atan2(Y, I), R -= Math.atan2(X, k), p) {
              B = Math.cos(R), st = Math.sin(R);
              let et = A.data.length;
              w += (et * (B * k - st * X) - I) * i, b += (et * (st * k + B * X) - Y) * i;
            } else R += x;
            R > P.PI ? R -= P.PI2 : R < -3.1415927 && (R += P.PI2), R *= i, B = Math.cos(R), st = Math.sin(R), A.a = B * k - st * X, A.b = B * F - st * E, A.c = st * k + B * X, A.d = st * F + B * E;
          }
          A.updateAppliedTransform();
        }
      }
      computeWorldPositions(t, s, i) {
        let r = this.target, h = this.position, l = this.spaces, n = L.setArraySize(this.positions, s * 3 + 2), a = this.world, o = t.closed, c = t.worldVerticesLength, d = c / 6, f = Bt.NONE;
        if (!t.constantSpeed) {
          let et = t.lengths;
          d -= o ? 1 : 2;
          let rt = et[d];
          this.data.positionMode == 1 && (h *= rt);
          let ct;
          switch (this.data.spacingMode) {
            case 2:
              ct = rt;
              break;
            case 3:
              ct = rt / s;
              break;
            default:
              ct = 1;
          }
          a = L.setArraySize(this.world, 8);
          for (let ot = 0, ut = 0, Z = 0; ot < s; ot++, ut += 3) {
            let nt = l[ot] * ct;
            h += nt;
            let ht = h;
            if (o) ht %= rt, ht < 0 && (ht += rt), Z = 0;
            else if (ht < 0) {
              f != Bt.BEFORE && (f = Bt.BEFORE, t.computeWorldVertices(r, 2, 4, a, 0, 2)), this.addBeforePosition(ht, a, 0, n, ut);
              continue;
            } else if (ht > rt) {
              f != Bt.AFTER && (f = Bt.AFTER, t.computeWorldVertices(r, c - 6, 4, a, 0, 2)), this.addAfterPosition(ht - rt, a, 0, n, ut);
              continue;
            }
            for (; ; Z++) {
              let bt = et[Z];
              if (!(ht > bt)) {
                if (Z == 0) ht /= bt;
                else {
                  let mt = et[Z - 1];
                  ht = (ht - mt) / (bt - mt);
                }
                break;
              }
            }
            Z != f && (f = Z, o && Z == d ? (t.computeWorldVertices(r, c - 4, 4, a, 0, 2), t.computeWorldVertices(r, 0, 4, a, 4, 2)) : t.computeWorldVertices(r, Z * 6 + 2, 8, a, 0, 2)), this.addCurvePosition(ht, a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], n, ut, i || ot > 0 && nt == 0);
          }
          return n;
        }
        o ? (c += 2, a = L.setArraySize(this.world, c), t.computeWorldVertices(r, 2, c - 4, a, 0, 2), t.computeWorldVertices(r, 0, 2, a, c - 4, 2), a[c - 2] = a[0], a[c - 1] = a[1]) : (d--, c -= 4, a = L.setArraySize(this.world, c), t.computeWorldVertices(r, 2, c, a, 0, 2));
        let m = L.setArraySize(this.curves, d), u = 0, g = a[0], w = a[1], b = 0, x = 0, p = 0, v = 0, y = 0, A = 0, C = 0, S = 0, I = 0, Y = 0, k = 0, F = 0, X = 0, E = 0;
        for (let et = 0, rt = 2; et < d; et++, rt += 6) b = a[rt], x = a[rt + 1], p = a[rt + 2], v = a[rt + 3], y = a[rt + 4], A = a[rt + 5], C = (g - b * 2 + p) * 0.1875, S = (w - x * 2 + v) * 0.1875, I = ((b - p) * 3 - g + y) * 0.09375, Y = ((x - v) * 3 - w + A) * 0.09375, k = C * 2 + I, F = S * 2 + Y, X = (b - g) * 0.75 + C + I * 0.16666667, E = (x - w) * 0.75 + S + Y * 0.16666667, u += Math.sqrt(X * X + E * E), X += k, E += F, k += I, F += Y, u += Math.sqrt(X * X + E * E), X += k, E += F, u += Math.sqrt(X * X + E * E), X += k + I, E += F + Y, u += Math.sqrt(X * X + E * E), m[et] = u, g = y, w = A;
        this.data.positionMode == 1 && (h *= u);
        let R;
        switch (this.data.spacingMode) {
          case 2:
            R = u;
            break;
          case 3:
            R = u / s;
            break;
          default:
            R = 1;
        }
        let B = this.segments, st = 0;
        for (let et = 0, rt = 0, ct = 0, ot = 0; et < s; et++, rt += 3) {
          let ut = l[et] * R;
          h += ut;
          let Z = h;
          if (o) Z %= u, Z < 0 && (Z += u), ct = 0;
          else if (Z < 0) {
            this.addBeforePosition(Z, a, 0, n, rt);
            continue;
          } else if (Z > u) {
            this.addAfterPosition(Z - u, a, c - 4, n, rt);
            continue;
          }
          for (; ; ct++) {
            let nt = m[ct];
            if (!(Z > nt)) {
              if (ct == 0) Z /= nt;
              else {
                let ht = m[ct - 1];
                Z = (Z - ht) / (nt - ht);
              }
              break;
            }
          }
          if (ct != f) {
            f = ct;
            let nt = ct * 6;
            for (g = a[nt], w = a[nt + 1], b = a[nt + 2], x = a[nt + 3], p = a[nt + 4], v = a[nt + 5], y = a[nt + 6], A = a[nt + 7], C = (g - b * 2 + p) * 0.03, S = (w - x * 2 + v) * 0.03, I = ((b - p) * 3 - g + y) * 6e-3, Y = ((x - v) * 3 - w + A) * 6e-3, k = C * 2 + I, F = S * 2 + Y, X = (b - g) * 0.3 + C + I * 0.16666667, E = (x - w) * 0.3 + S + Y * 0.16666667, st = Math.sqrt(X * X + E * E), B[0] = st, nt = 1; nt < 8; nt++) X += k, E += F, k += I, F += Y, st += Math.sqrt(X * X + E * E), B[nt] = st;
            X += k, E += F, st += Math.sqrt(X * X + E * E), B[8] = st, X += k + I, E += F + Y, st += Math.sqrt(X * X + E * E), B[9] = st, ot = 0;
          }
          for (Z *= st; ; ot++) {
            let nt = B[ot];
            if (!(Z > nt)) {
              if (ot == 0) Z /= nt;
              else {
                let ht = B[ot - 1];
                Z = ot + (Z - ht) / (nt - ht);
              }
              break;
            }
          }
          this.addCurvePosition(Z * 0.1, g, w, b, x, p, v, y, A, n, rt, i || et > 0 && ut == 0);
        }
        return n;
      }
      addBeforePosition(t, s, i, r, h) {
        let l = s[i], n = s[i + 1], a = s[i + 2] - l, o = s[i + 3] - n, c = Math.atan2(o, a);
        r[h] = l + t * Math.cos(c), r[h + 1] = n + t * Math.sin(c), r[h + 2] = c;
      }
      addAfterPosition(t, s, i, r, h) {
        let l = s[i + 2], n = s[i + 3], a = l - s[i], o = n - s[i + 1], c = Math.atan2(o, a);
        r[h] = l + t * Math.cos(c), r[h + 1] = n + t * Math.sin(c), r[h + 2] = c;
      }
      addCurvePosition(t, s, i, r, h, l, n, a, o, c, d, f) {
        if (t == 0 || isNaN(t)) {
          c[d] = s, c[d + 1] = i, c[d + 2] = Math.atan2(h - i, r - s);
          return;
        }
        let m = t * t, u = m * t, g = 1 - t, w = g * g, b = w * g, x = g * t, p = x * 3, v = g * p, y = p * t, A = s * b + r * v + l * y + a * u, C = i * b + h * v + n * y + o * u;
        c[d] = A, c[d + 1] = C, f && (t < 1e-3 ? c[d + 2] = Math.atan2(h - i, r - s) : c[d + 2] = Math.atan2(C - (i * w + h * x * 2 + n * m), A - (s * w + r * x * 2 + l * m)));
      }
    }, or = class {
      data;
      _bone = null;
      set bone(e) {
        this._bone = e;
      }
      get bone() {
        if (this._bone) return this._bone;
        throw new Error("Bone not set.");
      }
      inertia = 0;
      strength = 0;
      damping = 0;
      massInverse = 0;
      wind = 0;
      gravity = 0;
      mix = 0;
      _reset = true;
      ux = 0;
      uy = 0;
      cx = 0;
      cy = 0;
      tx = 0;
      ty = 0;
      xOffset = 0;
      xVelocity = 0;
      yOffset = 0;
      yVelocity = 0;
      rotateOffset = 0;
      rotateVelocity = 0;
      scaleOffset = 0;
      scaleVelocity = 0;
      active = false;
      skeleton;
      remaining = 0;
      lastTime = 0;
      constructor(e, t) {
        this.data = e, this.skeleton = t, this.bone = t.bones[e.bone.index], this.inertia = e.inertia, this.strength = e.strength, this.damping = e.damping, this.massInverse = e.massInverse, this.wind = e.wind, this.gravity = e.gravity, this.mix = e.mix;
      }
      reset() {
        this.remaining = 0, this.lastTime = this.skeleton.time, this._reset = true, this.xOffset = 0, this.xVelocity = 0, this.yOffset = 0, this.yVelocity = 0, this.rotateOffset = 0, this.rotateVelocity = 0, this.scaleOffset = 0, this.scaleVelocity = 0;
      }
      setToSetupPose() {
        const e = this.data;
        this.inertia = e.inertia, this.strength = e.strength, this.damping = e.damping, this.massInverse = e.massInverse, this.wind = e.wind, this.gravity = e.gravity, this.mix = e.mix;
      }
      isActive() {
        return this.active;
      }
      update(e) {
        const t = this.mix;
        if (t == 0) return;
        const s = this.data.x > 0, i = this.data.y > 0, r = this.data.rotate > 0 || this.data.shearX > 0, h = this.data.scaleX > 0, l = this.bone, n = l.data.length;
        switch (e) {
          case 0:
            return;
          case 1:
            this.reset();
          case 2:
            const a = this.skeleton, o = Math.max(this.skeleton.time - this.lastTime, 0);
            this.remaining += o, this.lastTime = a.time;
            const c = l.worldX, d = l.worldY;
            if (this._reset) this._reset = false, this.ux = c, this.uy = d;
            else {
              let f = this.remaining, m = this.inertia, u = this.data.step, g = this.skeleton.data.referenceScale, w = -1, b = this.data.limit * o, x = b * Math.abs(a.scaleY);
              if (b *= Math.abs(a.scaleX), s || i) {
                if (s) {
                  const p = (this.ux - c) * m;
                  this.xOffset += p > b ? b : p < -b ? -b : p, this.ux = c;
                }
                if (i) {
                  const p = (this.uy - d) * m;
                  this.yOffset += p > x ? x : p < -x ? -x : p, this.uy = d;
                }
                if (f >= u) {
                  w = Math.pow(this.damping, 60 * u);
                  const p = this.massInverse * u, v = this.strength, y = this.wind * g * a.scaleX, A = this.gravity * g * a.scaleY;
                  do
                    s && (this.xVelocity += (y - this.xOffset * v) * p, this.xOffset += this.xVelocity * u, this.xVelocity *= w), i && (this.yVelocity -= (A + this.yOffset * v) * p, this.yOffset += this.yVelocity * u, this.yVelocity *= w), f -= u;
                  while (f >= u);
                }
                s && (l.worldX += this.xOffset * t * this.data.x), i && (l.worldY += this.yOffset * t * this.data.y);
              }
              if (r || h) {
                let p = Math.atan2(l.c, l.a), v = 0, y = 0, A = 0, C = this.cx - l.worldX, S = this.cy - l.worldY;
                if (C > b ? C = b : C < -b && (C = -b), S > x ? S = x : S < -x && (S = -x), r) {
                  A = (this.data.rotate + this.data.shearX) * t;
                  let I = Math.atan2(S + this.ty, C + this.tx) - p - this.rotateOffset * A;
                  this.rotateOffset += (I - Math.ceil(I * P.invPI2 - 0.5) * P.PI2) * m, I = this.rotateOffset * A + p, v = Math.cos(I), y = Math.sin(I), h && (I = n * l.getWorldScaleX(), I > 0 && (this.scaleOffset += (C * v + S * y) * m / I));
                } else {
                  v = Math.cos(p), y = Math.sin(p);
                  const I = n * l.getWorldScaleX();
                  I > 0 && (this.scaleOffset += (C * v + S * y) * m / I);
                }
                if (f = this.remaining, f >= u) {
                  w == -1 && (w = Math.pow(this.damping, 60 * u));
                  const I = this.massInverse * u, Y = this.strength, k = this.wind, F = this.gravity, X = n / g;
                  for (; ; ) if (f -= u, h && (this.scaleVelocity += (k * v - F * y - this.scaleOffset * Y) * I, this.scaleOffset += this.scaleVelocity * u, this.scaleVelocity *= w), r) {
                    if (this.rotateVelocity -= ((k * y + F * v) * X + this.rotateOffset * Y) * I, this.rotateOffset += this.rotateVelocity * u, this.rotateVelocity *= w, f < u) break;
                    const E = this.rotateOffset * A + p;
                    v = Math.cos(E), y = Math.sin(E);
                  } else if (f < u) break;
                }
              }
              this.remaining = f;
            }
            this.cx = l.worldX, this.cy = l.worldY;
            break;
          case 3:
            s && (l.worldX += this.xOffset * t * this.data.x), i && (l.worldY += this.yOffset * t * this.data.y);
        }
        if (r) {
          let a = this.rotateOffset * t, o = 0, c = 0, d = 0;
          if (this.data.shearX > 0) {
            let f = 0;
            this.data.rotate > 0 && (f = a * this.data.rotate, o = Math.sin(f), c = Math.cos(f), d = l.b, l.b = c * d - o * l.d, l.d = o * d + c * l.d), f += a * this.data.shearX, o = Math.sin(f), c = Math.cos(f), d = l.a, l.a = c * d - o * l.c, l.c = o * d + c * l.c;
          } else a *= this.data.rotate, o = Math.sin(a), c = Math.cos(a), d = l.a, l.a = c * d - o * l.c, l.c = o * d + c * l.c, d = l.b, l.b = c * d - o * l.d, l.d = o * d + c * l.d;
        }
        if (h) {
          const a = 1 + this.scaleOffset * t * this.data.scaleX;
          l.a *= a, l.c *= a;
        }
        e != 3 && (this.tx = n * l.a, this.ty = n * l.c), l.updateAppliedTransform();
      }
      translate(e, t) {
        this.ux -= e, this.uy -= t, this.cx -= e, this.cy -= t;
      }
      rotate(e, t, s) {
        const i = s * P.degRad, r = Math.cos(i), h = Math.sin(i), l = this.cx - e, n = this.cy - t;
        this.translate(l * r - n * h - l, l * h + n * r - n);
      }
    }, ci = class {
      data;
      bone;
      color;
      darkColor = null;
      attachment = null;
      attachmentState = 0;
      sequenceIndex = -1;
      deform = new Array();
      constructor(e, t) {
        if (!e) throw new Error("data cannot be null.");
        if (!t) throw new Error("bone cannot be null.");
        this.data = e, this.bone = t, this.color = new tt(), this.darkColor = e.darkColor ? new tt() : null, this.setToSetupPose();
      }
      getSkeleton() {
        return this.bone.skeleton;
      }
      getAttachment() {
        return this.attachment;
      }
      setAttachment(e) {
        this.attachment != e && ((!(e instanceof Yt) || !(this.attachment instanceof Yt) || e.timelineAttachment != this.attachment.timelineAttachment) && (this.deform.length = 0), this.attachment = e, this.sequenceIndex = -1);
      }
      setToSetupPose() {
        this.color.setFromColor(this.data.color), this.darkColor && this.darkColor.setFromColor(this.data.darkColor), this.data.attachmentName ? (this.attachment = null, this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName))) : this.attachment = null;
      }
    }, di = class {
      data;
      bones;
      target;
      mixRotate = 0;
      mixX = 0;
      mixY = 0;
      mixScaleX = 0;
      mixScaleY = 0;
      mixShearY = 0;
      temp = new Vt();
      active = false;
      constructor(e, t) {
        if (!e) throw new Error("data cannot be null.");
        if (!t) throw new Error("skeleton cannot be null.");
        this.data = e, this.bones = new Array();
        for (let i = 0; i < e.bones.length; i++) {
          let r = t.findBone(e.bones[i].name);
          if (!r) throw new Error(`Couldn't find bone ${e.bones[i].name}.`);
          this.bones.push(r);
        }
        let s = t.findBone(e.target.name);
        if (!s) throw new Error(`Couldn't find target bone ${e.target.name}.`);
        this.target = s, this.mixRotate = e.mixRotate, this.mixX = e.mixX, this.mixY = e.mixY, this.mixScaleX = e.mixScaleX, this.mixScaleY = e.mixScaleY, this.mixShearY = e.mixShearY;
      }
      isActive() {
        return this.active;
      }
      setToSetupPose() {
        const e = this.data;
        this.mixRotate = e.mixRotate, this.mixX = e.mixX, this.mixY = e.mixY, this.mixScaleX = e.mixScaleX, this.mixScaleY = e.mixScaleY, this.mixShearY = e.mixShearY;
      }
      update(e) {
        this.mixRotate == 0 && this.mixX == 0 && this.mixY == 0 && this.mixScaleX == 0 && this.mixScaleY == 0 && this.mixShearY == 0 || (this.data.local ? this.data.relative ? this.applyRelativeLocal() : this.applyAbsoluteLocal() : this.data.relative ? this.applyRelativeWorld() : this.applyAbsoluteWorld());
      }
      applyAbsoluteWorld() {
        let e = this.mixRotate, t = this.mixX, s = this.mixY, i = this.mixScaleX, r = this.mixScaleY, h = this.mixShearY, l = t != 0 || s != 0, n = this.target, a = n.a, o = n.b, c = n.c, d = n.d, f = a * d - o * c > 0 ? P.degRad : -0.01745329277777778, m = this.data.offsetRotation * f, u = this.data.offsetShearY * f, g = this.bones;
        for (let w = 0, b = g.length; w < b; w++) {
          let x = g[w];
          if (e != 0) {
            let p = x.a, v = x.b, y = x.c, A = x.d, C = Math.atan2(c, a) - Math.atan2(y, p) + m;
            C > P.PI ? C -= P.PI2 : C < -3.1415927 && (C += P.PI2), C *= e;
            let S = Math.cos(C), I = Math.sin(C);
            x.a = S * p - I * y, x.b = S * v - I * A, x.c = I * p + S * y, x.d = I * v + S * A;
          }
          if (l) {
            let p = this.temp;
            n.localToWorld(p.set(this.data.offsetX, this.data.offsetY)), x.worldX += (p.x - x.worldX) * t, x.worldY += (p.y - x.worldY) * s;
          }
          if (i != 0) {
            let p = Math.sqrt(x.a * x.a + x.c * x.c);
            p != 0 && (p = (p + (Math.sqrt(a * a + c * c) - p + this.data.offsetScaleX) * i) / p), x.a *= p, x.c *= p;
          }
          if (r != 0) {
            let p = Math.sqrt(x.b * x.b + x.d * x.d);
            p != 0 && (p = (p + (Math.sqrt(o * o + d * d) - p + this.data.offsetScaleY) * r) / p), x.b *= p, x.d *= p;
          }
          if (h > 0) {
            let p = x.b, v = x.d, y = Math.atan2(v, p), A = Math.atan2(d, o) - Math.atan2(c, a) - (y - Math.atan2(x.c, x.a));
            A > P.PI ? A -= P.PI2 : A < -3.1415927 && (A += P.PI2), A = y + (A + u) * h;
            let C = Math.sqrt(p * p + v * v);
            x.b = Math.cos(A) * C, x.d = Math.sin(A) * C;
          }
          x.updateAppliedTransform();
        }
      }
      applyRelativeWorld() {
        let e = this.mixRotate, t = this.mixX, s = this.mixY, i = this.mixScaleX, r = this.mixScaleY, h = this.mixShearY, l = t != 0 || s != 0, n = this.target, a = n.a, o = n.b, c = n.c, d = n.d, f = a * d - o * c > 0 ? P.degRad : -0.01745329277777778, m = this.data.offsetRotation * f, u = this.data.offsetShearY * f, g = this.bones;
        for (let w = 0, b = g.length; w < b; w++) {
          let x = g[w];
          if (e != 0) {
            let p = x.a, v = x.b, y = x.c, A = x.d, C = Math.atan2(c, a) + m;
            C > P.PI ? C -= P.PI2 : C < -3.1415927 && (C += P.PI2), C *= e;
            let S = Math.cos(C), I = Math.sin(C);
            x.a = S * p - I * y, x.b = S * v - I * A, x.c = I * p + S * y, x.d = I * v + S * A;
          }
          if (l) {
            let p = this.temp;
            n.localToWorld(p.set(this.data.offsetX, this.data.offsetY)), x.worldX += p.x * t, x.worldY += p.y * s;
          }
          if (i != 0) {
            let p = (Math.sqrt(a * a + c * c) - 1 + this.data.offsetScaleX) * i + 1;
            x.a *= p, x.c *= p;
          }
          if (r != 0) {
            let p = (Math.sqrt(o * o + d * d) - 1 + this.data.offsetScaleY) * r + 1;
            x.b *= p, x.d *= p;
          }
          if (h > 0) {
            let p = Math.atan2(d, o) - Math.atan2(c, a);
            p > P.PI ? p -= P.PI2 : p < -3.1415927 && (p += P.PI2);
            let v = x.b, y = x.d;
            p = Math.atan2(y, v) + (p - P.PI / 2 + u) * h;
            let A = Math.sqrt(v * v + y * y);
            x.b = Math.cos(p) * A, x.d = Math.sin(p) * A;
          }
          x.updateAppliedTransform();
        }
      }
      applyAbsoluteLocal() {
        let e = this.mixRotate, t = this.mixX, s = this.mixY, i = this.mixScaleX, r = this.mixScaleY, h = this.mixShearY, l = this.target, n = this.bones;
        for (let a = 0, o = n.length; a < o; a++) {
          let c = n[a], d = c.arotation;
          e != 0 && (d += (l.arotation - d + this.data.offsetRotation) * e);
          let f = c.ax, m = c.ay;
          f += (l.ax - f + this.data.offsetX) * t, m += (l.ay - m + this.data.offsetY) * s;
          let u = c.ascaleX, g = c.ascaleY;
          i != 0 && u != 0 && (u = (u + (l.ascaleX - u + this.data.offsetScaleX) * i) / u), r != 0 && g != 0 && (g = (g + (l.ascaleY - g + this.data.offsetScaleY) * r) / g);
          let w = c.ashearY;
          h != 0 && (w += (l.ashearY - w + this.data.offsetShearY) * h), c.updateWorldTransformWith(f, m, d, u, g, c.ashearX, w);
        }
      }
      applyRelativeLocal() {
        let e = this.mixRotate, t = this.mixX, s = this.mixY, i = this.mixScaleX, r = this.mixScaleY, h = this.mixShearY, l = this.target, n = this.bones;
        for (let a = 0, o = n.length; a < o; a++) {
          let c = n[a], d = c.arotation + (l.arotation + this.data.offsetRotation) * e, f = c.ax + (l.ax + this.data.offsetX) * t, m = c.ay + (l.ay + this.data.offsetY) * s, u = c.ascaleX * ((l.ascaleX - 1 + this.data.offsetScaleX) * i + 1), g = c.ascaleY * ((l.ascaleY - 1 + this.data.offsetScaleY) * r + 1), w = c.ashearY + (l.ashearY + this.data.offsetShearY) * h;
          c.updateWorldTransformWith(f, m, d, u, g, c.ashearX, w);
        }
      }
    }, fi = class Ns {
      static quadTriangles = [0, 1, 2, 2, 3, 0];
      static yDown = false;
      data;
      bones;
      slots;
      drawOrder;
      ikConstraints;
      transformConstraints;
      pathConstraints;
      physicsConstraints;
      _updateCache = new Array();
      skin = null;
      color;
      scaleX = 1;
      _scaleY = 1;
      get scaleY() {
        return Ns.yDown ? -this._scaleY : this._scaleY;
      }
      set scaleY(t) {
        this._scaleY = t;
      }
      x = 0;
      y = 0;
      time = 0;
      constructor(t) {
        if (!t) throw new Error("data cannot be null.");
        this.data = t, this.bones = new Array();
        for (let s = 0; s < t.bones.length; s++) {
          let i = t.bones[s], r;
          if (!i.parent) r = new ms(i, this, null);
          else {
            let h = this.bones[i.parent.index];
            r = new ms(i, this, h), h.children.push(r);
          }
          this.bones.push(r);
        }
        this.slots = new Array(), this.drawOrder = new Array();
        for (let s = 0; s < t.slots.length; s++) {
          let i = t.slots[s], r = this.bones[i.boneData.index], h = new ci(i, r);
          this.slots.push(h), this.drawOrder.push(h);
        }
        this.ikConstraints = new Array();
        for (let s = 0; s < t.ikConstraints.length; s++) {
          let i = t.ikConstraints[s];
          this.ikConstraints.push(new oi(i, this));
        }
        this.transformConstraints = new Array();
        for (let s = 0; s < t.transformConstraints.length; s++) {
          let i = t.transformConstraints[s];
          this.transformConstraints.push(new di(i, this));
        }
        this.pathConstraints = new Array();
        for (let s = 0; s < t.pathConstraints.length; s++) {
          let i = t.pathConstraints[s];
          this.pathConstraints.push(new hi(i, this));
        }
        this.physicsConstraints = new Array();
        for (let s = 0; s < t.physicsConstraints.length; s++) {
          let i = t.physicsConstraints[s];
          this.physicsConstraints.push(new or(i, this));
        }
        this.color = new tt(1, 1, 1, 1), this.updateCache();
      }
      updateCache() {
        let t = this._updateCache;
        t.length = 0;
        let s = this.bones;
        for (let f = 0, m = s.length; f < m; f++) {
          let u = s[f];
          u.sorted = u.data.skinRequired, u.active = !u.sorted;
        }
        if (this.skin) {
          let f = this.skin.bones;
          for (let m = 0, u = this.skin.bones.length; m < u; m++) {
            let g = this.bones[f[m].index];
            do
              g.sorted = false, g.active = true, g = g.parent;
            while (g);
          }
        }
        let i = this.ikConstraints, r = this.transformConstraints, h = this.pathConstraints, l = this.physicsConstraints, n = i.length, a = r.length, o = h.length, c = this.physicsConstraints.length, d = n + a + o + c;
        t: for (let f = 0; f < d; f++) {
          for (let m = 0; m < n; m++) {
            let u = i[m];
            if (u.data.order == f) {
              this.sortIkConstraint(u);
              continue t;
            }
          }
          for (let m = 0; m < a; m++) {
            let u = r[m];
            if (u.data.order == f) {
              this.sortTransformConstraint(u);
              continue t;
            }
          }
          for (let m = 0; m < o; m++) {
            let u = h[m];
            if (u.data.order == f) {
              this.sortPathConstraint(u);
              continue t;
            }
          }
          for (let m = 0; m < c; m++) {
            const u = l[m];
            if (u.data.order == f) {
              this.sortPhysicsConstraint(u);
              continue t;
            }
          }
        }
        for (let f = 0, m = s.length; f < m; f++) this.sortBone(s[f]);
      }
      sortIkConstraint(t) {
        if (t.active = t.target.isActive() && (!t.data.skinRequired || this.skin && L.contains(this.skin.constraints, t.data, true)), !t.active) return;
        let s = t.target;
        this.sortBone(s);
        let i = t.bones, r = i[0];
        if (this.sortBone(r), i.length == 1) this._updateCache.push(t), this.sortReset(r.children);
        else {
          let h = i[i.length - 1];
          this.sortBone(h), this._updateCache.push(t), this.sortReset(r.children), h.sorted = true;
        }
      }
      sortPathConstraint(t) {
        if (t.active = t.target.bone.isActive() && (!t.data.skinRequired || this.skin && L.contains(this.skin.constraints, t.data, true)), !t.active) return;
        let s = t.target, i = s.data.index, r = s.bone;
        this.skin && this.sortPathConstraintAttachment(this.skin, i, r), this.data.defaultSkin && this.data.defaultSkin != this.skin && this.sortPathConstraintAttachment(this.data.defaultSkin, i, r);
        for (let a = 0, o = this.data.skins.length; a < o; a++) this.sortPathConstraintAttachment(this.data.skins[a], i, r);
        let h = s.getAttachment();
        h instanceof qt && this.sortPathConstraintAttachmentWith(h, r);
        let l = t.bones, n = l.length;
        for (let a = 0; a < n; a++) this.sortBone(l[a]);
        this._updateCache.push(t);
        for (let a = 0; a < n; a++) this.sortReset(l[a].children);
        for (let a = 0; a < n; a++) l[a].sorted = true;
      }
      sortTransformConstraint(t) {
        if (t.active = t.target.isActive() && (!t.data.skinRequired || this.skin && L.contains(this.skin.constraints, t.data, true)), !t.active) return;
        this.sortBone(t.target);
        let s = t.bones, i = s.length;
        if (t.data.local) for (let r = 0; r < i; r++) {
          let h = s[r];
          this.sortBone(h.parent), this.sortBone(h);
        }
        else for (let r = 0; r < i; r++) this.sortBone(s[r]);
        this._updateCache.push(t);
        for (let r = 0; r < i; r++) this.sortReset(s[r].children);
        for (let r = 0; r < i; r++) s[r].sorted = true;
      }
      sortPathConstraintAttachment(t, s, i) {
        let r = t.attachments[s];
        if (r) for (let h in r) this.sortPathConstraintAttachmentWith(r[h], i);
      }
      sortPathConstraintAttachmentWith(t, s) {
        if (!(t instanceof qt)) return;
        let i = t.bones;
        if (!i) this.sortBone(s);
        else {
          let r = this.bones;
          for (let h = 0, l = i.length; h < l; ) {
            let n = i[h++];
            for (n += h; h < n; ) this.sortBone(r[i[h++]]);
          }
        }
      }
      sortPhysicsConstraint(t) {
        const s = t.bone;
        t.active = s.active && (!t.data.skinRequired || this.skin != null && L.contains(this.skin.constraints, t.data, true)), t.active && (this.sortBone(s), this._updateCache.push(t), this.sortReset(s.children), s.sorted = true);
      }
      sortBone(t) {
        if (!t || t.sorted) return;
        let s = t.parent;
        s && this.sortBone(s), t.sorted = true, this._updateCache.push(t);
      }
      sortReset(t) {
        for (let s = 0, i = t.length; s < i; s++) {
          let r = t[s];
          r.active && (r.sorted && this.sortReset(r.children), r.sorted = false);
        }
      }
      updateWorldTransform(t) {
        if (t == null) throw new Error("physics is undefined");
        let s = this.bones;
        for (let r = 0, h = s.length; r < h; r++) {
          let l = s[r];
          l.ax = l.x, l.ay = l.y, l.arotation = l.rotation, l.ascaleX = l.scaleX, l.ascaleY = l.scaleY, l.ashearX = l.shearX, l.ashearY = l.shearY;
        }
        let i = this._updateCache;
        for (let r = 0, h = i.length; r < h; r++) i[r].update(t);
      }
      updateWorldTransformWith(t, s) {
        if (!s) throw new Error("parent cannot be null.");
        let i = this.bones;
        for (let w = 1, b = i.length; w < b; w++) {
          let x = i[w];
          x.ax = x.x, x.ay = x.y, x.arotation = x.rotation, x.ascaleX = x.scaleX, x.ascaleY = x.scaleY, x.ashearX = x.shearX, x.ashearY = x.shearY;
        }
        let r = this.getRootBone();
        if (!r) throw new Error("Root bone must not be null.");
        let h = s.a, l = s.b, n = s.c, a = s.d;
        r.worldX = h * this.x + l * this.y + s.worldX, r.worldY = n * this.x + a * this.y + s.worldY;
        const o = (r.rotation + r.shearX) * P.degRad, c = (r.rotation + 90 + r.shearY) * P.degRad, d = Math.cos(o) * r.scaleX, f = Math.cos(c) * r.scaleY, m = Math.sin(o) * r.scaleX, u = Math.sin(c) * r.scaleY;
        r.a = (h * d + l * m) * this.scaleX, r.b = (h * f + l * u) * this.scaleX, r.c = (n * d + a * m) * this.scaleY, r.d = (n * f + a * u) * this.scaleY;
        let g = this._updateCache;
        for (let w = 0, b = g.length; w < b; w++) {
          let x = g[w];
          x != r && x.update(t);
        }
      }
      setToSetupPose() {
        this.setBonesToSetupPose(), this.setSlotsToSetupPose();
      }
      setBonesToSetupPose() {
        for (const t of this.bones) t.setToSetupPose();
        for (const t of this.ikConstraints) t.setToSetupPose();
        for (const t of this.transformConstraints) t.setToSetupPose();
        for (const t of this.pathConstraints) t.setToSetupPose();
        for (const t of this.physicsConstraints) t.setToSetupPose();
      }
      setSlotsToSetupPose() {
        let t = this.slots;
        L.arrayCopy(t, 0, this.drawOrder, 0, t.length);
        for (let s = 0, i = t.length; s < i; s++) t[s].setToSetupPose();
      }
      getRootBone() {
        return this.bones.length == 0 ? null : this.bones[0];
      }
      findBone(t) {
        if (!t) throw new Error("boneName cannot be null.");
        let s = this.bones;
        for (let i = 0, r = s.length; i < r; i++) {
          let h = s[i];
          if (h.data.name == t) return h;
        }
        return null;
      }
      findSlot(t) {
        if (!t) throw new Error("slotName cannot be null.");
        let s = this.slots;
        for (let i = 0, r = s.length; i < r; i++) {
          let h = s[i];
          if (h.data.name == t) return h;
        }
        return null;
      }
      setSkinByName(t) {
        let s = this.data.findSkin(t);
        if (!s) throw new Error("Skin not found: " + t);
        this.setSkin(s);
      }
      setSkin(t) {
        if (t != this.skin) {
          if (t) if (this.skin) t.attachAll(this, this.skin);
          else {
            let s = this.slots;
            for (let i = 0, r = s.length; i < r; i++) {
              let h = s[i], l = h.data.attachmentName;
              if (l) {
                let n = t.getAttachment(i, l);
                n && h.setAttachment(n);
              }
            }
          }
          this.skin = t, this.updateCache();
        }
      }
      getAttachmentByName(t, s) {
        let i = this.data.findSlot(t);
        if (!i) throw new Error(`Can't find slot with name ${t}`);
        return this.getAttachment(i.index, s);
      }
      getAttachment(t, s) {
        if (!s) throw new Error("attachmentName cannot be null.");
        if (this.skin) {
          let i = this.skin.getAttachment(t, s);
          if (i) return i;
        }
        return this.data.defaultSkin ? this.data.defaultSkin.getAttachment(t, s) : null;
      }
      setAttachment(t, s) {
        if (!t) throw new Error("slotName cannot be null.");
        let i = this.slots;
        for (let r = 0, h = i.length; r < h; r++) {
          let l = i[r];
          if (l.data.name == t) {
            let n = null;
            if (s && (n = this.getAttachment(r, s), !n)) throw new Error("Attachment not found: " + s + ", for slot: " + t);
            l.setAttachment(n);
            return;
          }
        }
        throw new Error("Slot not found: " + t);
      }
      findIkConstraint(t) {
        if (!t) throw new Error("constraintName cannot be null.");
        return this.ikConstraints.find((s) => s.data.name == t) ?? null;
      }
      findTransformConstraint(t) {
        if (!t) throw new Error("constraintName cannot be null.");
        return this.transformConstraints.find((s) => s.data.name == t) ?? null;
      }
      findPathConstraint(t) {
        if (!t) throw new Error("constraintName cannot be null.");
        return this.pathConstraints.find((s) => s.data.name == t) ?? null;
      }
      findPhysicsConstraint(t) {
        if (t == null) throw new Error("constraintName cannot be null.");
        return this.physicsConstraints.find((s) => s.data.name == t) ?? null;
      }
      getBoundsRect(t) {
        let s = new Vt(), i = new Vt();
        return this.getBounds(s, i, void 0, t), { x: s.x, y: s.y, width: i.x, height: i.y };
      }
      getBounds(t, s, i = new Array(2), r = null) {
        if (!t) throw new Error("offset cannot be null.");
        if (!s) throw new Error("size cannot be null.");
        let h = this.drawOrder, l = Number.POSITIVE_INFINITY, n = Number.POSITIVE_INFINITY, a = Number.NEGATIVE_INFINITY, o = Number.NEGATIVE_INFINITY;
        for (let c = 0, d = h.length; c < d; c++) {
          let f = h[c];
          if (!f.bone.active) continue;
          let m = 0, u = null, g = null, w = f.getAttachment();
          if (w instanceof te) m = 8, u = L.setArraySize(i, m, 0), w.computeWorldVertices(f, u, 0, 2), g = Ns.quadTriangles;
          else if (w instanceof Wt) {
            let b = w;
            m = b.worldVerticesLength, u = L.setArraySize(i, m, 0), b.computeWorldVertices(f, 0, m, u, 0, 2), g = b.triangles;
          } else if (w instanceof $t && r != null) {
            r.clipStart(f, w);
            continue;
          }
          if (u && g) {
            r != null && r.isClipping() && (r.clipTriangles(u, g, g.length), u = r.clippedVertices, m = r.clippedVertices.length);
            for (let b = 0, x = u.length; b < x; b += 2) {
              let p = u[b], v = u[b + 1];
              l = Math.min(l, p), n = Math.min(n, v), a = Math.max(a, p), o = Math.max(o, v);
            }
          }
          r == null ? void 0 : r.clipEndWithSlot(f);
        }
        r == null ? void 0 : r.clipEnd(), t.set(l, n), s.set(a - l, o - n);
      }
      update(t) {
        this.time += t;
      }
      physicsTranslate(t, s) {
        const i = this.physicsConstraints;
        for (let r = 0, h = i.length; r < h; r++) i[r].translate(t, s);
      }
      physicsRotate(t, s, i) {
        const r = this.physicsConstraints;
        for (let h = 0, l = r.length; h < l; h++) r[h].rotate(t, s, i);
      }
    }, ui = ((e) => (e[e.none = 0] = "none", e[e.reset = 1] = "reset", e[e.update = 2] = "update", e[e.pose = 3] = "pose", e))(ui || {}), mi = class extends ee {
      _bone = null;
      set bone(e) {
        this._bone = e;
      }
      get bone() {
        if (this._bone) return this._bone;
        throw new Error("BoneData not set.");
      }
      x = 0;
      y = 0;
      rotate = 0;
      scaleX = 0;
      shearX = 0;
      limit = 0;
      step = 0;
      inertia = 0;
      strength = 0;
      damping = 0;
      massInverse = 0;
      wind = 0;
      gravity = 0;
      mix = 0;
      inertiaGlobal = false;
      strengthGlobal = false;
      dampingGlobal = false;
      massGlobal = false;
      windGlobal = false;
      gravityGlobal = false;
      mixGlobal = false;
      constructor(e) {
        super(e, 0, false);
      }
    }, Cs = class {
      name = null;
      bones = new Array();
      slots = new Array();
      skins = new Array();
      defaultSkin = null;
      events = new Array();
      animations = new Array();
      ikConstraints = new Array();
      transformConstraints = new Array();
      pathConstraints = new Array();
      physicsConstraints = new Array();
      x = 0;
      y = 0;
      width = 0;
      height = 0;
      referenceScale = 100;
      version = null;
      hash = null;
      fps = 0;
      imagesPath = null;
      audioPath = null;
      findBone(e) {
        if (!e) throw new Error("boneName cannot be null.");
        let t = this.bones;
        for (let s = 0, i = t.length; s < i; s++) {
          let r = t[s];
          if (r.name == e) return r;
        }
        return null;
      }
      findSlot(e) {
        if (!e) throw new Error("slotName cannot be null.");
        let t = this.slots;
        for (let s = 0, i = t.length; s < i; s++) {
          let r = t[s];
          if (r.name == e) return r;
        }
        return null;
      }
      findSkin(e) {
        if (!e) throw new Error("skinName cannot be null.");
        let t = this.skins;
        for (let s = 0, i = t.length; s < i; s++) {
          let r = t[s];
          if (r.name == e) return r;
        }
        return null;
      }
      findEvent(e) {
        if (!e) throw new Error("eventDataName cannot be null.");
        let t = this.events;
        for (let s = 0, i = t.length; s < i; s++) {
          let r = t[s];
          if (r.name == e) return r;
        }
        return null;
      }
      findAnimation(e) {
        if (!e) throw new Error("animationName cannot be null.");
        let t = this.animations;
        for (let s = 0, i = t.length; s < i; s++) {
          let r = t[s];
          if (r.name == e) return r;
        }
        return null;
      }
      findIkConstraint(e) {
        if (!e) throw new Error("constraintName cannot be null.");
        const t = this.ikConstraints;
        for (let s = 0, i = t.length; s < i; s++) {
          const r = t[s];
          if (r.name == e) return r;
        }
        return null;
      }
      findTransformConstraint(e) {
        if (!e) throw new Error("constraintName cannot be null.");
        const t = this.transformConstraints;
        for (let s = 0, i = t.length; s < i; s++) {
          const r = t[s];
          if (r.name == e) return r;
        }
        return null;
      }
      findPathConstraint(e) {
        if (!e) throw new Error("constraintName cannot be null.");
        const t = this.pathConstraints;
        for (let s = 0, i = t.length; s < i; s++) {
          const r = t[s];
          if (r.name == e) return r;
        }
        return null;
      }
      findPhysicsConstraint(e) {
        if (!e) throw new Error("constraintName cannot be null.");
        const t = this.physicsConstraints;
        for (let s = 0, i = t.length; s < i; s++) {
          const r = t[s];
          if (r.name == e) return r;
        }
        return null;
      }
    }, Ss = class {
      constructor(e = 0, t, s) {
        this.slotIndex = e, this.name = t, this.attachment = s;
      }
    }, fe = class {
      name;
      attachments = new Array();
      bones = Array();
      constraints = new Array();
      color = new tt(0.99607843, 0.61960787, 0.30980393, 1);
      constructor(e) {
        if (!e) throw new Error("name cannot be null.");
        this.name = e;
      }
      setAttachment(e, t, s) {
        if (!s) throw new Error("attachment cannot be null.");
        let i = this.attachments;
        e >= i.length && (i.length = e + 1), i[e] || (i[e] = {}), i[e][t] = s;
      }
      addSkin(e) {
        for (let i = 0; i < e.bones.length; i++) {
          let r = e.bones[i], h = false;
          for (let l = 0; l < this.bones.length; l++) if (this.bones[l] == r) {
            h = true;
            break;
          }
          h || this.bones.push(r);
        }
        for (let i = 0; i < e.constraints.length; i++) {
          let r = e.constraints[i], h = false;
          for (let l = 0; l < this.constraints.length; l++) if (this.constraints[l] == r) {
            h = true;
            break;
          }
          h || this.constraints.push(r);
        }
        let t = e.getAttachments();
        for (let i = 0; i < t.length; i++) {
          var s = t[i];
          this.setAttachment(s.slotIndex, s.name, s.attachment);
        }
      }
      copySkin(e) {
        for (let i = 0; i < e.bones.length; i++) {
          let r = e.bones[i], h = false;
          for (let l = 0; l < this.bones.length; l++) if (this.bones[l] == r) {
            h = true;
            break;
          }
          h || this.bones.push(r);
        }
        for (let i = 0; i < e.constraints.length; i++) {
          let r = e.constraints[i], h = false;
          for (let l = 0; l < this.constraints.length; l++) if (this.constraints[l] == r) {
            h = true;
            break;
          }
          h || this.constraints.push(r);
        }
        let t = e.getAttachments();
        for (let i = 0; i < t.length; i++) {
          var s = t[i];
          s.attachment && (s.attachment instanceof Wt ? (s.attachment = s.attachment.newLinkedMesh(), this.setAttachment(s.slotIndex, s.name, s.attachment)) : (s.attachment = s.attachment.copy(), this.setAttachment(s.slotIndex, s.name, s.attachment)));
        }
      }
      getAttachment(e, t) {
        let s = this.attachments[e];
        return s ? s[t] : null;
      }
      removeAttachment(e, t) {
        let s = this.attachments[e];
        s && delete s[t];
      }
      getAttachments() {
        let e = new Array();
        for (var t = 0; t < this.attachments.length; t++) {
          let s = this.attachments[t];
          if (s) for (let i in s) {
            let r = s[i];
            r && e.push(new Ss(t, i, r));
          }
        }
        return e;
      }
      getAttachmentsForSlot(e, t) {
        let s = this.attachments[e];
        if (s) for (let i in s) {
          let r = s[i];
          r && t.push(new Ss(e, i, r));
        }
      }
      clear() {
        this.attachments.length = 0, this.bones.length = 0, this.constraints.length = 0;
      }
      attachAll(e, t) {
        let s = 0;
        for (let i = 0; i < e.slots.length; i++) {
          let r = e.slots[i], h = r.getAttachment();
          if (h && s < t.attachments.length) {
            let l = t.attachments[s];
            for (let n in l) {
              let a = l[n];
              if (h == a) {
                let o = this.getAttachment(s, n);
                o && r.setAttachment(o);
                break;
              }
            }
          }
          s++;
        }
      }
    }, Ts = class {
      index = 0;
      name;
      boneData;
      color = new tt(1, 1, 1, 1);
      darkColor = null;
      attachmentName = null;
      blendMode = 0;
      visible = true;
      constructor(e, t, s) {
        if (e < 0) throw new Error("index must be >= 0.");
        if (!t) throw new Error("name cannot be null.");
        if (!s) throw new Error("boneData cannot be null.");
        this.index = e, this.name = t, this.boneData = s;
      }
    }, Is = ((e) => (e[e.Normal = 0] = "Normal", e[e.Additive = 1] = "Additive", e[e.Multiply = 2] = "Multiply", e[e.Screen = 3] = "Screen", e))(Is || {}), Ms = class extends ee {
      bones = new Array();
      _target = null;
      set target(e) {
        this._target = e;
      }
      get target() {
        if (this._target) return this._target;
        throw new Error("BoneData not set.");
      }
      mixRotate = 0;
      mixX = 0;
      mixY = 0;
      mixScaleX = 0;
      mixScaleY = 0;
      mixShearY = 0;
      offsetRotation = 0;
      offsetX = 0;
      offsetY = 0;
      offsetScaleX = 0;
      offsetScaleY = 0;
      offsetShearY = 0;
      relative = false;
      local = false;
      constructor(e) {
        super(e, 0, false);
      }
    }, hr = class {
      scale = 1;
      attachmentLoader;
      linkedMeshes = new Array();
      constructor(e) {
        this.attachmentLoader = e;
      }
      readSkeletonData(e) {
        let t = this.scale, s = new Cs();
        s.name = "";
        let i = new gi(e), r = i.readInt32(), h = i.readInt32();
        s.hash = h == 0 && r == 0 ? null : h.toString(16) + r.toString(16), s.version = i.readString(), s.x = i.readFloat(), s.y = i.readFloat(), s.width = i.readFloat(), s.height = i.readFloat(), s.referenceScale = i.readFloat() * t;
        let l = i.readBoolean();
        l && (s.fps = i.readFloat(), s.imagesPath = i.readString(), s.audioPath = i.readString());
        let n = 0;
        n = i.readInt(true);
        for (let o = 0; o < n; o++) {
          let c = i.readString();
          if (!c) throw new Error("String in string table must not be null.");
          i.strings.push(c);
        }
        n = i.readInt(true);
        for (let o = 0; o < n; o++) {
          let c = i.readString();
          if (!c) throw new Error("Bone name must not be null.");
          let d = o == 0 ? null : s.bones[i.readInt(true)], f = new us(o, c, d);
          f.rotation = i.readFloat(), f.x = i.readFloat() * t, f.y = i.readFloat() * t, f.scaleX = i.readFloat(), f.scaleY = i.readFloat(), f.shearX = i.readFloat(), f.shearY = i.readFloat(), f.length = i.readFloat() * t, f.inherit = i.readByte(), f.skinRequired = i.readBoolean(), l && (tt.rgba8888ToColor(f.color, i.readInt32()), f.icon = i.readString() ?? void 0, f.visible = i.readBoolean()), s.bones.push(f);
        }
        n = i.readInt(true);
        for (let o = 0; o < n; o++) {
          let c = i.readString();
          if (!c) throw new Error("Slot name must not be null.");
          let d = s.bones[i.readInt(true)], f = new Ts(o, c, d);
          tt.rgba8888ToColor(f.color, i.readInt32());
          let m = i.readInt32();
          m != -1 && tt.rgb888ToColor(f.darkColor = new tt(), m), f.attachmentName = i.readStringRef(), f.blendMode = i.readInt(true), l && (f.visible = i.readBoolean()), s.slots.push(f);
        }
        n = i.readInt(true);
        for (let o = 0, c; o < n; o++) {
          let d = i.readString();
          if (!d) throw new Error("IK constraint data name must not be null.");
          let f = new ws(d);
          f.order = i.readInt(true), c = i.readInt(true);
          for (let u = 0; u < c; u++) f.bones.push(s.bones[i.readInt(true)]);
          f.target = s.bones[i.readInt(true)];
          let m = i.readByte();
          f.skinRequired = (m & 1) != 0, f.bendDirection = (m & 2) != 0 ? 1 : -1, f.compress = (m & 4) != 0, f.stretch = (m & 8) != 0, f.uniform = (m & 16) != 0, (m & 32) != 0 && (f.mix = (m & 64) != 0 ? i.readFloat() : 1), (m & 128) != 0 && (f.softness = i.readFloat() * t), s.ikConstraints.push(f);
        }
        n = i.readInt(true);
        for (let o = 0, c; o < n; o++) {
          let d = i.readString();
          if (!d) throw new Error("Transform constraint data name must not be null.");
          let f = new Ms(d);
          f.order = i.readInt(true), c = i.readInt(true);
          for (let u = 0; u < c; u++) f.bones.push(s.bones[i.readInt(true)]);
          f.target = s.bones[i.readInt(true)];
          let m = i.readByte();
          f.skinRequired = (m & 1) != 0, f.local = (m & 2) != 0, f.relative = (m & 4) != 0, (m & 8) != 0 && (f.offsetRotation = i.readFloat()), (m & 16) != 0 && (f.offsetX = i.readFloat() * t), (m & 32) != 0 && (f.offsetY = i.readFloat() * t), (m & 64) != 0 && (f.offsetScaleX = i.readFloat()), (m & 128) != 0 && (f.offsetScaleY = i.readFloat()), m = i.readByte(), (m & 1) != 0 && (f.offsetShearY = i.readFloat()), (m & 2) != 0 && (f.mixRotate = i.readFloat()), (m & 4) != 0 && (f.mixX = i.readFloat()), (m & 8) != 0 && (f.mixY = i.readFloat()), (m & 16) != 0 && (f.mixScaleX = i.readFloat()), (m & 32) != 0 && (f.mixScaleY = i.readFloat()), (m & 64) != 0 && (f.mixShearY = i.readFloat()), s.transformConstraints.push(f);
        }
        n = i.readInt(true);
        for (let o = 0, c; o < n; o++) {
          let d = i.readString();
          if (!d) throw new Error("Path constraint data name must not be null.");
          let f = new bs(d);
          f.order = i.readInt(true), f.skinRequired = i.readBoolean(), c = i.readInt(true);
          for (let u = 0; u < c; u++) f.bones.push(s.bones[i.readInt(true)]);
          f.target = s.slots[i.readInt(true)];
          const m = i.readByte();
          f.positionMode = m & 1, f.spacingMode = m >> 1 & 3, f.rotateMode = m >> 3 & 3, (m & 128) != 0 && (f.offsetRotation = i.readFloat()), f.position = i.readFloat(), f.positionMode == 0 && (f.position *= t), f.spacing = i.readFloat(), (f.spacingMode == 0 || f.spacingMode == 1) && (f.spacing *= t), f.mixRotate = i.readFloat(), f.mixX = i.readFloat(), f.mixY = i.readFloat(), s.pathConstraints.push(f);
        }
        n = i.readInt(true);
        for (let o = 0, c; o < n; o++) {
          const d = i.readString();
          if (!d) throw new Error("Physics constraint data name must not be null.");
          const f = new mi(d);
          f.order = i.readInt(true), f.bone = s.bones[i.readInt(true)];
          let m = i.readByte();
          f.skinRequired = (m & 1) != 0, (m & 2) != 0 && (f.x = i.readFloat()), (m & 4) != 0 && (f.y = i.readFloat()), (m & 8) != 0 && (f.rotate = i.readFloat()), (m & 16) != 0 && (f.scaleX = i.readFloat()), (m & 32) != 0 && (f.shearX = i.readFloat()), f.limit = ((m & 64) != 0 ? i.readFloat() : 5e3) * t, f.step = 1 / i.readUnsignedByte(), f.inertia = i.readFloat(), f.strength = i.readFloat(), f.damping = i.readFloat(), f.massInverse = (m & 128) != 0 ? i.readFloat() : 1, f.wind = i.readFloat(), f.gravity = i.readFloat(), m = i.readByte(), (m & 1) != 0 && (f.inertiaGlobal = true), (m & 2) != 0 && (f.strengthGlobal = true), (m & 4) != 0 && (f.dampingGlobal = true), (m & 8) != 0 && (f.massGlobal = true), (m & 16) != 0 && (f.windGlobal = true), (m & 32) != 0 && (f.gravityGlobal = true), (m & 64) != 0 && (f.mixGlobal = true), f.mix = (m & 128) != 0 ? i.readFloat() : 1, s.physicsConstraints.push(f);
        }
        let a = this.readSkin(i, s, true, l);
        a && (s.defaultSkin = a, s.skins.push(a));
        {
          let o = s.skins.length;
          for (L.setArraySize(s.skins, n = o + i.readInt(true)); o < n; o++) {
            let c = this.readSkin(i, s, false, l);
            if (!c) throw new Error("readSkin() should not have returned null.");
            s.skins[o] = c;
          }
        }
        n = this.linkedMeshes.length;
        for (let o = 0; o < n; o++) {
          let c = this.linkedMeshes[o];
          const d = s.skins[c.skinIndex];
          if (!c.parent) throw new Error("Linked mesh parent must not be null");
          let f = d.getAttachment(c.slotIndex, c.parent);
          if (!f) throw new Error(`Parent mesh not found: ${c.parent}`);
          c.mesh.timelineAttachment = c.inheritTimeline ? f : c.mesh, c.mesh.setParentMesh(f), c.mesh.region != null && c.mesh.updateRegion();
        }
        this.linkedMeshes.length = 0, n = i.readInt(true);
        for (let o = 0; o < n; o++) {
          let c = i.readString();
          if (!c) throw new Error("Event data name must not be null");
          let d = new ps(c);
          d.intValue = i.readInt(false), d.floatValue = i.readFloat(), d.stringValue = i.readString(), d.audioPath = i.readString(), d.audioPath && (d.volume = i.readFloat(), d.balance = i.readFloat()), s.events.push(d);
        }
        n = i.readInt(true);
        for (let o = 0; o < n; o++) {
          let c = i.readString();
          if (!c) throw new Error("Animatio name must not be null.");
          s.animations.push(this.readAnimation(i, c, s));
        }
        return s;
      }
      readSkin(e, t, s, i) {
        let r = null, h = 0;
        if (s) {
          if (h = e.readInt(true), h == 0) return null;
          r = new fe("default");
        } else {
          let l = e.readString();
          if (!l) throw new Error("Skin name must not be null.");
          r = new fe(l), i && tt.rgba8888ToColor(r.color, e.readInt32()), r.bones.length = e.readInt(true);
          for (let n = 0, a = r.bones.length; n < a; n++) r.bones[n] = t.bones[e.readInt(true)];
          for (let n = 0, a = e.readInt(true); n < a; n++) r.constraints.push(t.ikConstraints[e.readInt(true)]);
          for (let n = 0, a = e.readInt(true); n < a; n++) r.constraints.push(t.transformConstraints[e.readInt(true)]);
          for (let n = 0, a = e.readInt(true); n < a; n++) r.constraints.push(t.pathConstraints[e.readInt(true)]);
          for (let n = 0, a = e.readInt(true); n < a; n++) r.constraints.push(t.physicsConstraints[e.readInt(true)]);
          h = e.readInt(true);
        }
        for (let l = 0; l < h; l++) {
          let n = e.readInt(true);
          for (let a = 0, o = e.readInt(true); a < o; a++) {
            let c = e.readStringRef();
            if (!c) throw new Error("Attachment name must not be null");
            let d = this.readAttachment(e, t, r, n, c, i);
            d && r.setAttachment(n, c, d);
          }
        }
        return r;
      }
      readAttachment(e, t, s, i, r, h) {
        let l = this.scale, n = e.readByte();
        const a = (n & 8) != 0 ? e.readStringRef() : r;
        if (!a) throw new Error("Attachment name must not be null");
        switch (n & 7) {
          case 0: {
            let o = (n & 16) != 0 ? e.readStringRef() : null;
            const c = (n & 32) != 0 ? e.readInt32() : 4294967295, d = (n & 64) != 0 ? this.readSequence(e) : null;
            let f = (n & 128) != 0 ? e.readFloat() : 0, m = e.readFloat(), u = e.readFloat(), g = e.readFloat(), w = e.readFloat(), b = e.readFloat(), x = e.readFloat();
            o || (o = a);
            let p = this.attachmentLoader.newRegionAttachment(s, a, o, d);
            return p ? (p.path = o, p.x = m * l, p.y = u * l, p.scaleX = g, p.scaleY = w, p.rotation = f, p.width = b * l, p.height = x * l, tt.rgba8888ToColor(p.color, c), p.sequence = d, d == null && p.updateRegion(), p) : null;
          }
          case 1: {
            let o = this.readVertices(e, (n & 16) != 0), c = h ? e.readInt32() : 0, d = this.attachmentLoader.newBoundingBoxAttachment(s, a);
            return d ? (d.worldVerticesLength = o.length, d.vertices = o.vertices, d.bones = o.bones, h && tt.rgba8888ToColor(d.color, c), d) : null;
          }
          case 2: {
            let o = (n & 16) != 0 ? e.readStringRef() : a;
            const c = (n & 32) != 0 ? e.readInt32() : 4294967295, d = (n & 64) != 0 ? this.readSequence(e) : null, f = e.readInt(true), m = this.readVertices(e, (n & 128) != 0), u = this.readFloatArray(e, m.length, 1), g = this.readShortArray(e, (m.length - f - 2) * 3);
            let w = [], b = 0, x = 0;
            h && (w = this.readShortArray(e, e.readInt(true)), b = e.readFloat(), x = e.readFloat()), o || (o = a);
            let p = this.attachmentLoader.newMeshAttachment(s, a, o, d);
            return p ? (p.path = o, tt.rgba8888ToColor(p.color, c), p.bones = m.bones, p.vertices = m.vertices, p.worldVerticesLength = m.length, p.triangles = g, p.regionUVs = u, d == null && p.updateRegion(), p.hullLength = f << 1, p.sequence = d, h && (p.edges = w, p.width = b * l, p.height = x * l), p) : null;
          }
          case 3: {
            const o = (n & 16) != 0 ? e.readStringRef() : a;
            if (o == null) throw new Error("Path of linked mesh must not be null");
            const c = (n & 32) != 0 ? e.readInt32() : 4294967295, d = (n & 64) != 0 ? this.readSequence(e) : null, f = (n & 128) != 0, m = e.readInt(true), u = e.readStringRef();
            let g = 0, w = 0;
            h && (g = e.readFloat(), w = e.readFloat());
            let b = this.attachmentLoader.newMeshAttachment(s, a, o, d);
            return b ? (b.path = o, tt.rgba8888ToColor(b.color, c), b.sequence = d, h && (b.width = g * l, b.height = w * l), this.linkedMeshes.push(new cr(b, m, i, u, f)), b) : null;
          }
          case 4: {
            const o = (n & 16) != 0, c = (n & 32) != 0, d = this.readVertices(e, (n & 64) != 0), f = L.newArray(d.length / 6, 0);
            for (let g = 0, w = f.length; g < w; g++) f[g] = e.readFloat() * l;
            const m = h ? e.readInt32() : 0, u = this.attachmentLoader.newPathAttachment(s, a);
            return u ? (u.closed = o, u.constantSpeed = c, u.worldVerticesLength = d.length, u.vertices = d.vertices, u.bones = d.bones, u.lengths = f, h && tt.rgba8888ToColor(u.color, m), u) : null;
          }
          case 5: {
            const o = e.readFloat(), c = e.readFloat(), d = e.readFloat(), f = h ? e.readInt32() : 0, m = this.attachmentLoader.newPointAttachment(s, a);
            return m ? (m.x = c * l, m.y = d * l, m.rotation = o, h && tt.rgba8888ToColor(m.color, f), m) : null;
          }
          case 6: {
            const o = e.readInt(true), c = this.readVertices(e, (n & 16) != 0);
            let d = h ? e.readInt32() : 0, f = this.attachmentLoader.newClippingAttachment(s, a);
            return f ? (f.endSlot = t.slots[o], f.worldVerticesLength = c.length, f.vertices = c.vertices, f.bones = c.bones, h && tt.rgba8888ToColor(f.color, d), f) : null;
          }
        }
        return null;
      }
      readSequence(e) {
        let t = new Hs(e.readInt(true));
        return t.start = e.readInt(true), t.digits = e.readInt(true), t.setupIndex = e.readInt(true), t;
      }
      readVertices(e, t) {
        const s = this.scale, i = e.readInt(true), r = new dr();
        if (r.length = i << 1, !t) return r.vertices = this.readFloatArray(e, r.length, s), r;
        let h = new Array(), l = new Array();
        for (let n = 0; n < i; n++) {
          let a = e.readInt(true);
          l.push(a);
          for (let o = 0; o < a; o++) l.push(e.readInt(true)), h.push(e.readFloat() * s), h.push(e.readFloat() * s), h.push(e.readFloat());
        }
        return r.vertices = L.toFloatArray(h), r.bones = l, r;
      }
      readFloatArray(e, t, s) {
        let i = new Array(t);
        if (s == 1) for (let r = 0; r < t; r++) i[r] = e.readFloat();
        else for (let r = 0; r < t; r++) i[r] = e.readFloat() * s;
        return i;
      }
      readShortArray(e, t) {
        let s = new Array(t);
        for (let i = 0; i < t; i++) s[i] = e.readInt(true);
        return s;
      }
      readAnimation(e, t, s) {
        e.readInt(true);
        let i = new Array(), r = this.scale;
        for (let a = 0, o = e.readInt(true); a < o; a++) {
          let c = e.readInt(true);
          for (let d = 0, f = e.readInt(true); d < f; d++) {
            let m = e.readByte(), u = e.readInt(true), g = u - 1;
            switch (m) {
              case Cr: {
                let w = new Ot(u, c);
                for (let b = 0; b < u; b++) w.setFrame(b, e.readFloat(), e.readStringRef());
                i.push(w);
                break;
              }
              case Sr: {
                let w = e.readInt(true), b = new Ne(u, w, c), x = e.readFloat(), p = e.readUnsignedByte() / 255, v = e.readUnsignedByte() / 255, y = e.readUnsignedByte() / 255, A = e.readUnsignedByte() / 255;
                for (let C = 0, S = 0; b.setFrame(C, x, p, v, y, A), C != g; C++) {
                  let I = e.readFloat(), Y = e.readUnsignedByte() / 255, k = e.readUnsignedByte() / 255, F = e.readUnsignedByte() / 255, X = e.readUnsignedByte() / 255;
                  switch (e.readByte()) {
                    case kt:
                      b.setStepped(C);
                      break;
                    case Ft:
                      at(e, b, S++, C, 0, x, I, p, Y, 1), at(e, b, S++, C, 1, x, I, v, k, 1), at(e, b, S++, C, 2, x, I, y, F, 1), at(e, b, S++, C, 3, x, I, A, X, 1);
                  }
                  x = I, p = Y, v = k, y = F, A = X;
                }
                i.push(b);
                break;
              }
              case Tr: {
                let w = e.readInt(true), b = new Ue(u, w, c), x = e.readFloat(), p = e.readUnsignedByte() / 255, v = e.readUnsignedByte() / 255, y = e.readUnsignedByte() / 255;
                for (let A = 0, C = 0; b.setFrame(A, x, p, v, y), A != g; A++) {
                  let S = e.readFloat(), I = e.readUnsignedByte() / 255, Y = e.readUnsignedByte() / 255, k = e.readUnsignedByte() / 255;
                  switch (e.readByte()) {
                    case kt:
                      b.setStepped(A);
                      break;
                    case Ft:
                      at(e, b, C++, A, 0, x, S, p, I, 1), at(e, b, C++, A, 1, x, S, v, Y, 1), at(e, b, C++, A, 2, x, S, y, k, 1);
                  }
                  x = S, p = I, v = Y, y = k;
                }
                i.push(b);
                break;
              }
              case Ir: {
                let w = e.readInt(true), b = new We(u, w, c), x = e.readFloat(), p = e.readUnsignedByte() / 255, v = e.readUnsignedByte() / 255, y = e.readUnsignedByte() / 255, A = e.readUnsignedByte() / 255, C = e.readUnsignedByte() / 255, S = e.readUnsignedByte() / 255, I = e.readUnsignedByte() / 255;
                for (let Y = 0, k = 0; b.setFrame(Y, x, p, v, y, A, C, S, I), Y != g; Y++) {
                  let F = e.readFloat(), X = e.readUnsignedByte() / 255, E = e.readUnsignedByte() / 255, R = e.readUnsignedByte() / 255, B = e.readUnsignedByte() / 255, st = e.readUnsignedByte() / 255, et = e.readUnsignedByte() / 255, rt = e.readUnsignedByte() / 255;
                  switch (e.readByte()) {
                    case kt:
                      b.setStepped(Y);
                      break;
                    case Ft:
                      at(e, b, k++, Y, 0, x, F, p, X, 1), at(e, b, k++, Y, 1, x, F, v, E, 1), at(e, b, k++, Y, 2, x, F, y, R, 1), at(e, b, k++, Y, 3, x, F, A, B, 1), at(e, b, k++, Y, 4, x, F, C, st, 1), at(e, b, k++, Y, 5, x, F, S, et, 1), at(e, b, k++, Y, 6, x, F, I, rt, 1);
                  }
                  x = F, p = X, v = E, y = R, A = B, C = st, S = et, I = rt;
                }
                i.push(b);
                break;
              }
              case Mr: {
                let w = e.readInt(true), b = new qe(u, w, c), x = e.readFloat(), p = e.readUnsignedByte() / 255, v = e.readUnsignedByte() / 255, y = e.readUnsignedByte() / 255, A = e.readUnsignedByte() / 255, C = e.readUnsignedByte() / 255, S = e.readUnsignedByte() / 255;
                for (let I = 0, Y = 0; b.setFrame(I, x, p, v, y, A, C, S), I != g; I++) {
                  let k = e.readFloat(), F = e.readUnsignedByte() / 255, X = e.readUnsignedByte() / 255, E = e.readUnsignedByte() / 255, R = e.readUnsignedByte() / 255, B = e.readUnsignedByte() / 255, st = e.readUnsignedByte() / 255;
                  switch (e.readByte()) {
                    case kt:
                      b.setStepped(I);
                      break;
                    case Ft:
                      at(e, b, Y++, I, 0, x, k, p, F, 1), at(e, b, Y++, I, 1, x, k, v, X, 1), at(e, b, Y++, I, 2, x, k, y, E, 1), at(e, b, Y++, I, 3, x, k, A, R, 1), at(e, b, Y++, I, 4, x, k, C, B, 1), at(e, b, Y++, I, 5, x, k, S, st, 1);
                  }
                  x = k, p = F, v = X, y = E, A = R, C = B, S = st;
                }
                i.push(b);
                break;
              }
              case Er: {
                let w = new ze(u, e.readInt(true), c), b = e.readFloat(), x = e.readUnsignedByte() / 255;
                for (let p = 0, v = 0; w.setFrame(p, b, x), p != g; p++) {
                  let y = e.readFloat(), A = e.readUnsignedByte() / 255;
                  switch (e.readByte()) {
                    case kt:
                      w.setStepped(p);
                      break;
                    case Ft:
                      at(e, w, v++, p, 0, b, y, x, A, 1);
                  }
                  b = y, x = A;
                }
                i.push(w);
              }
            }
          }
        }
        for (let a = 0, o = e.readInt(true); a < o; a++) {
          let c = e.readInt(true);
          for (let d = 0, f = e.readInt(true); d < f; d++) {
            let m = e.readByte(), u = e.readInt(true);
            if (m == Ar) {
              let w = new De(u, c);
              for (let b = 0; b < u; b++) w.setFrame(b, e.readFloat(), e.readByte());
              i.push(w);
              continue;
            }
            let g = e.readInt(true);
            switch (m) {
              case fr:
                i.push(gt(e, new Qt(u, g, c), 1));
                break;
              case ur:
                i.push(Es(e, new Ye(u, g, c), r));
                break;
              case mr:
                i.push(gt(e, new ke(u, g, c), r));
                break;
              case gr:
                i.push(gt(e, new Fe(u, g, c), r));
                break;
              case xr:
                i.push(Es(e, new Xe(u, g, c), 1));
                break;
              case pr:
                i.push(gt(e, new Pe(u, g, c), 1));
                break;
              case wr:
                i.push(gt(e, new Le(u, g, c), 1));
                break;
              case br:
                i.push(Es(e, new Be(u, g, c), 1));
                break;
              case vr:
                i.push(gt(e, new Ve(u, g, c), 1));
                break;
              case yr:
                i.push(gt(e, new Oe(u, g, c), 1));
            }
          }
        }
        for (let a = 0, o = e.readInt(true); a < o; a++) {
          let c = e.readInt(true), d = e.readInt(true), f = d - 1, m = new He(d, e.readInt(true), c), u = e.readByte(), g = e.readFloat(), w = (u & 1) != 0 ? (u & 2) != 0 ? e.readFloat() : 1 : 0, b = (u & 4) != 0 ? e.readFloat() * r : 0;
          for (let x = 0, p = 0; m.setFrame(x, g, w, b, (u & 8) != 0 ? 1 : -1, (u & 16) != 0, (u & 32) != 0), x != f; x++) {
            u = e.readByte();
            const v = e.readFloat(), y = (u & 1) != 0 ? (u & 2) != 0 ? e.readFloat() : 1 : 0, A = (u & 4) != 0 ? e.readFloat() * r : 0;
            (u & 64) != 0 ? m.setStepped(x) : (u & 128) != 0 && (at(e, m, p++, x, 0, g, v, w, y, 1), at(e, m, p++, x, 1, g, v, b, A, r)), g = v, w = y, b = A;
          }
          i.push(m);
        }
        for (let a = 0, o = e.readInt(true); a < o; a++) {
          let c = e.readInt(true), d = e.readInt(true), f = d - 1, m = new _e(d, e.readInt(true), c), u = e.readFloat(), g = e.readFloat(), w = e.readFloat(), b = e.readFloat(), x = e.readFloat(), p = e.readFloat(), v = e.readFloat();
          for (let y = 0, A = 0; m.setFrame(y, u, g, w, b, x, p, v), y != f; y++) {
            let C = e.readFloat(), S = e.readFloat(), I = e.readFloat(), Y = e.readFloat(), k = e.readFloat(), F = e.readFloat(), X = e.readFloat();
            switch (e.readByte()) {
              case kt:
                m.setStepped(y);
                break;
              case Ft:
                at(e, m, A++, y, 0, u, C, g, S, 1), at(e, m, A++, y, 1, u, C, w, I, 1), at(e, m, A++, y, 2, u, C, b, Y, 1), at(e, m, A++, y, 3, u, C, x, k, 1), at(e, m, A++, y, 4, u, C, p, F, 1), at(e, m, A++, y, 5, u, C, v, X, 1);
            }
            u = C, g = S, w = I, b = Y, x = k, p = F, v = X;
          }
          i.push(m);
        }
        for (let a = 0, o = e.readInt(true); a < o; a++) {
          let c = e.readInt(true), d = s.pathConstraints[c];
          for (let f = 0, m = e.readInt(true); f < m; f++) {
            const u = e.readByte(), g = e.readInt(true), w = e.readInt(true);
            switch (u) {
              case kr:
                i.push(gt(e, new je(g, w, c), d.positionMode == 0 ? r : 1));
                break;
              case Fr:
                i.push(gt(e, new Ze(g, w, c), d.spacingMode == 0 || d.spacingMode == 1 ? r : 1));
                break;
              case Xr:
                let b = new Ke(g, w, c), x = e.readFloat(), p = e.readFloat(), v = e.readFloat(), y = e.readFloat();
                for (let A = 0, C = 0, S = b.getFrameCount() - 1; b.setFrame(A, x, p, v, y), A != S; A++) {
                  let I = e.readFloat(), Y = e.readFloat(), k = e.readFloat(), F = e.readFloat();
                  switch (e.readByte()) {
                    case kt:
                      b.setStepped(A);
                      break;
                    case Ft:
                      at(e, b, C++, A, 0, x, I, p, Y, 1), at(e, b, C++, A, 1, x, I, v, k, 1), at(e, b, C++, A, 2, x, I, y, F, 1);
                  }
                  x = I, p = Y, v = k, y = F;
                }
                i.push(b);
            }
          }
        }
        for (let a = 0, o = e.readInt(true); a < o; a++) {
          const c = e.readInt(true) - 1;
          for (let d = 0, f = e.readInt(true); d < f; d++) {
            const m = e.readByte(), u = e.readInt(true);
            if (m == Ur) {
              const w = new rs(u, c);
              for (let b = 0; b < u; b++) w.setFrame(b, e.readFloat());
              i.push(w);
              continue;
            }
            const g = e.readInt(true);
            switch (m) {
              case Pr:
                i.push(gt(e, new Je(u, g, c), 1));
                break;
              case Lr:
                i.push(gt(e, new Qe(u, g, c), 1));
                break;
              case Br:
                i.push(gt(e, new $e(u, g, c), 1));
                break;
              case Vr:
                i.push(gt(e, new ts(u, g, c), 1));
                break;
              case Or:
                i.push(gt(e, new es(u, g, c), 1));
                break;
              case Dr:
                i.push(gt(e, new ss(u, g, c), 1));
                break;
              case Nr:
                i.push(gt(e, new is(u, g, c), 1));
            }
          }
        }
        for (let a = 0, o = e.readInt(true); a < o; a++) {
          let c = s.skins[e.readInt(true)];
          for (let d = 0, f = e.readInt(true); d < f; d++) {
            let m = e.readInt(true);
            for (let u = 0, g = e.readInt(true); u < g; u++) {
              let w = e.readStringRef();
              if (!w) throw new Error("attachmentName must not be null.");
              let b = c.getAttachment(m, w), x = e.readByte(), p = e.readInt(true), v = p - 1;
              switch (x) {
                case Rr: {
                  let y = b, A = y.bones, C = y.vertices, S = A ? C.length / 3 * 2 : C.length, I = e.readInt(true), Y = new Ge(p, I, m, y), k = e.readFloat();
                  for (let F = 0, X = 0; ; F++) {
                    let E, R = e.readInt(true);
                    if (R == 0) E = A ? L.newFloatArray(S) : C;
                    else {
                      E = L.newFloatArray(S);
                      let st = e.readInt(true);
                      if (R += st, r == 1) for (let et = st; et < R; et++) E[et] = e.readFloat();
                      else for (let et = st; et < R; et++) E[et] = e.readFloat() * r;
                      if (!A) for (let et = 0, rt = E.length; et < rt; et++) E[et] += C[et];
                    }
                    if (Y.setFrame(F, k, E), F == v) break;
                    let B = e.readFloat();
                    switch (e.readByte()) {
                      case kt:
                        Y.setStepped(F);
                        break;
                      case Ft:
                        at(e, Y, X++, F, 0, k, B, 0, 1, 1);
                    }
                    k = B;
                  }
                  i.push(Y);
                  break;
                }
                case Yr: {
                  let y = new ns(p, m, b);
                  for (let A = 0; A < p; A++) {
                    let C = e.readFloat(), S = e.readInt32();
                    y.setFrame(A, C, js[S & 15], S >> 4, e.readFloat());
                  }
                  i.push(y);
                  break;
                }
              }
            }
          }
        }
        let h = e.readInt(true);
        if (h > 0) {
          let a = new zt(h), o = s.slots.length;
          for (let c = 0; c < h; c++) {
            let d = e.readFloat(), f = e.readInt(true), m = L.newArray(o, 0);
            for (let b = o - 1; b >= 0; b--) m[b] = -1;
            let u = L.newArray(o - f, 0), g = 0, w = 0;
            for (let b = 0; b < f; b++) {
              let x = e.readInt(true);
              for (; g != x; ) u[w++] = g++;
              m[g + e.readInt(true)] = g++;
            }
            for (; g < o; ) u[w++] = g++;
            for (let b = o - 1; b >= 0; b--) m[b] == -1 && (m[b] = u[--w]);
            a.setFrame(c, d, m);
          }
          i.push(a);
        }
        let l = e.readInt(true);
        if (l > 0) {
          let a = new le(l);
          for (let o = 0; o < l; o++) {
            let c = e.readFloat(), d = s.events[e.readInt(true)], f = new xs(c, d);
            f.intValue = e.readInt(false), f.floatValue = e.readFloat(), f.stringValue = e.readString(), f.stringValue == null && (f.stringValue = d.stringValue), f.data.audioPath && (f.volume = e.readFloat(), f.balance = e.readFloat()), a.setFrame(o, f);
          }
          i.push(a);
        }
        let n = 0;
        for (let a = 0, o = i.length; a < o; a++) n = Math.max(n, i[a].getDuration());
        return new ne(t, i, n);
      }
    }, gi = class {
      constructor(e, t = new Array(), s = 0, i = new DataView(e instanceof ArrayBuffer ? e : e.buffer)) {
        this.strings = t, this.index = s, this.buffer = i;
      }
      readByte() {
        return this.buffer.getInt8(this.index++);
      }
      readUnsignedByte() {
        return this.buffer.getUint8(this.index++);
      }
      readShort() {
        let e = this.buffer.getInt16(this.index);
        return this.index += 2, e;
      }
      readInt32() {
        let e = this.buffer.getInt32(this.index);
        return this.index += 4, e;
      }
      readInt(e) {
        let t = this.readByte(), s = t & 127;
        return (t & 128) != 0 && (t = this.readByte(), s |= (t & 127) << 7, (t & 128) != 0 && (t = this.readByte(), s |= (t & 127) << 14, (t & 128) != 0 && (t = this.readByte(), s |= (t & 127) << 21, (t & 128) != 0 && (t = this.readByte(), s |= (t & 127) << 28)))), e ? s : s >>> 1 ^ -(s & 1);
      }
      readStringRef() {
        let e = this.readInt(true);
        return e == 0 ? null : this.strings[e - 1];
      }
      readString() {
        let e = this.readInt(true);
        switch (e) {
          case 0:
            return null;
          case 1:
            return "";
        }
        e--;
        let t = "";
        for (let i = 0; i < e; ) {
          let r = this.readUnsignedByte();
          switch (r >> 4) {
            case 12:
            case 13:
              t += String.fromCharCode((r & 31) << 6 | this.readByte() & 63), i += 2;
              break;
            case 14:
              t += String.fromCharCode((r & 15) << 12 | (this.readByte() & 63) << 6 | this.readByte() & 63), i += 3;
              break;
            default:
              t += String.fromCharCode(r), i++;
          }
        }
        return t;
      }
      readFloat() {
        let e = this.buffer.getFloat32(this.index);
        return this.index += 4, e;
      }
      readBoolean() {
        return this.readByte() != 0;
      }
    }, cr = class {
      parent;
      skinIndex;
      slotIndex;
      mesh;
      inheritTimeline;
      constructor(e, t, s, i, r) {
        this.mesh = e, this.skinIndex = t, this.slotIndex = s, this.parent = i, this.inheritTimeline = r;
      }
    }, dr = class {
      constructor(e = null, t = null, s = 0) {
        this.bones = e, this.vertices = t, this.length = s;
      }
    };
    function gt(e, t, s) {
      let i = e.readFloat(), r = e.readFloat() * s;
      for (let h = 0, l = 0, n = t.getFrameCount() - 1; t.setFrame(h, i, r), h != n; h++) {
        let a = e.readFloat(), o = e.readFloat() * s;
        switch (e.readByte()) {
          case kt:
            t.setStepped(h);
            break;
          case Ft:
            at(e, t, l++, h, 0, i, a, r, o, s);
        }
        i = a, r = o;
      }
      return t;
    }
    function Es(e, t, s) {
      let i = e.readFloat(), r = e.readFloat() * s, h = e.readFloat() * s;
      for (let l = 0, n = 0, a = t.getFrameCount() - 1; t.setFrame(l, i, r, h), l != a; l++) {
        let o = e.readFloat(), c = e.readFloat() * s, d = e.readFloat() * s;
        switch (e.readByte()) {
          case kt:
            t.setStepped(l);
            break;
          case Ft:
            at(e, t, n++, l, 0, i, o, r, c, s), at(e, t, n++, l, 1, i, o, h, d, s);
        }
        i = o, r = c, h = d;
      }
      return t;
    }
    function at(e, t, s, i, r, h, l, n, a, o) {
      t.setBezier(s, i, r, h, n, e.readFloat(), e.readFloat() * o, e.readFloat(), e.readFloat() * o, l, a);
    }
    var fr = 0, ur = 1, mr = 2, gr = 3, xr = 4, pr = 5, wr = 6, br = 7, vr = 8, yr = 9, Ar = 10, Cr = 0, Sr = 1, Tr = 2, Ir = 3, Mr = 4, Er = 5, Rr = 0, Yr = 1, kr = 0, Fr = 1, Xr = 2, Pr = 0, Lr = 1, Br = 2, Vr = 4, Or = 5, Dr = 6, Nr = 7, Ur = 8, kt = 1, Ft = 2, xi = class {
      minX = 0;
      minY = 0;
      maxX = 0;
      maxY = 0;
      boundingBoxes = new Array();
      polygons = new Array();
      polygonPool = new Jt(() => L.newFloatArray(16));
      update(e, t) {
        if (!e) throw new Error("skeleton cannot be null.");
        let s = this.boundingBoxes, i = this.polygons, r = this.polygonPool, h = e.slots, l = h.length;
        s.length = 0, r.freeAll(i), i.length = 0;
        for (let n = 0; n < l; n++) {
          let a = h[n];
          if (!a.bone.active) continue;
          let o = a.getAttachment();
          if (o instanceof hs) {
            let c = o;
            s.push(c);
            let d = r.obtain();
            d.length != c.worldVerticesLength && (d = L.newFloatArray(c.worldVerticesLength)), i.push(d), c.computeWorldVertices(a, 0, c.worldVerticesLength, d, 0, 2);
          }
        }
        t ? this.aabbCompute() : (this.minX = Number.POSITIVE_INFINITY, this.minY = Number.POSITIVE_INFINITY, this.maxX = Number.NEGATIVE_INFINITY, this.maxY = Number.NEGATIVE_INFINITY);
      }
      aabbCompute() {
        let e = Number.POSITIVE_INFINITY, t = Number.POSITIVE_INFINITY, s = Number.NEGATIVE_INFINITY, i = Number.NEGATIVE_INFINITY, r = this.polygons;
        for (let h = 0, l = r.length; h < l; h++) {
          let n = r[h], a = n;
          for (let o = 0, c = n.length; o < c; o += 2) {
            let d = a[o], f = a[o + 1];
            e = Math.min(e, d), t = Math.min(t, f), s = Math.max(s, d), i = Math.max(i, f);
          }
        }
        this.minX = e, this.minY = t, this.maxX = s, this.maxY = i;
      }
      aabbContainsPoint(e, t) {
        return e >= this.minX && e <= this.maxX && t >= this.minY && t <= this.maxY;
      }
      aabbIntersectsSegment(e, t, s, i) {
        let r = this.minX, h = this.minY, l = this.maxX, n = this.maxY;
        if (e <= r && s <= r || t <= h && i <= h || e >= l && s >= l || t >= n && i >= n) return false;
        let a = (i - t) / (s - e), o = a * (r - e) + t;
        if (o > h && o < n || (o = a * (l - e) + t, o > h && o < n)) return true;
        let c = (h - t) / a + e;
        return c > r && c < l || (c = (n - t) / a + e, c > r && c < l);
      }
      aabbIntersectsSkeleton(e) {
        return this.minX < e.maxX && this.maxX > e.minX && this.minY < e.maxY && this.maxY > e.minY;
      }
      containsPoint(e, t) {
        let s = this.polygons;
        for (let i = 0, r = s.length; i < r; i++) if (this.containsPointPolygon(s[i], e, t)) return this.boundingBoxes[i];
        return null;
      }
      containsPointPolygon(e, t, s) {
        let i = e, r = e.length, h = r - 2, l = false;
        for (let n = 0; n < r; n += 2) {
          let a = i[n + 1], o = i[h + 1];
          if (a < s && o >= s || o < s && a >= s) {
            let c = i[n];
            c + (s - a) / (o - a) * (i[h] - c) < t && (l = !l);
          }
          h = n;
        }
        return l;
      }
      intersectsSegment(e, t, s, i) {
        let r = this.polygons;
        for (let h = 0, l = r.length; h < l; h++) if (this.intersectsSegmentPolygon(r[h], e, t, s, i)) return this.boundingBoxes[h];
        return null;
      }
      intersectsSegmentPolygon(e, t, s, i, r) {
        let h = e, l = e.length, n = t - i, a = s - r, o = t * r - s * i, c = h[l - 2], d = h[l - 1];
        for (let f = 0; f < l; f += 2) {
          let m = h[f], u = h[f + 1], g = c * u - d * m, w = c - m, b = d - u, x = n * b - a * w, p = (o * w - n * g) / x;
          if ((p >= c && p <= m || p >= m && p <= c) && (p >= t && p <= i || p >= i && p <= t)) {
            let v = (o * b - a * g) / x;
            if ((v >= d && v <= u || v >= u && v <= d) && (v >= s && v <= r || v >= r && v <= s)) return true;
          }
          c = m, d = u;
        }
        return false;
      }
      getPolygon(e) {
        if (!e) throw new Error("boundingBox cannot be null.");
        let t = this.boundingBoxes.indexOf(e);
        return t == -1 ? null : this.polygons[t];
      }
      getWidth() {
        return this.maxX - this.minX;
      }
      getHeight() {
        return this.maxY - this.minY;
      }
    }, pi = class vt {
      convexPolygons = new Array();
      convexPolygonsIndices = new Array();
      indicesArray = new Array();
      isConcaveArray = new Array();
      triangles = new Array();
      polygonPool = new Jt(() => new Array());
      polygonIndicesPool = new Jt(() => new Array());
      triangulate(t) {
        let s = t, i = t.length >> 1, r = this.indicesArray;
        r.length = 0;
        for (let n = 0; n < i; n++) r[n] = n;
        let h = this.isConcaveArray;
        h.length = 0;
        for (let n = 0, a = i; n < a; ++n) h[n] = vt.isConcave(n, i, s, r);
        let l = this.triangles;
        for (l.length = 0; i > 3; ) {
          let n = i - 1, a = 0, o = 1;
          for (; ; ) {
            t: if (!h[a]) {
              let f = r[n] << 1, m = r[a] << 1, u = r[o] << 1, g = s[f], w = s[f + 1], b = s[m], x = s[m + 1], p = s[u], v = s[u + 1];
              for (let y = (o + 1) % i; y != n; y = (y + 1) % i) {
                if (!h[y]) continue;
                let A = r[y] << 1, C = s[A], S = s[A + 1];
                if (vt.positiveArea(p, v, g, w, C, S) && vt.positiveArea(g, w, b, x, C, S) && vt.positiveArea(b, x, p, v, C, S)) break t;
              }
              break;
            }
            if (o == 0) {
              do {
                if (!h[a]) break;
                a--;
              } while (a > 0);
              break;
            }
            n = a, a = o, o = (o + 1) % i;
          }
          l.push(r[(i + a - 1) % i]), l.push(r[a]), l.push(r[(a + 1) % i]), r.splice(a, 1), h.splice(a, 1), i--;
          let c = (i + a - 1) % i, d = a == i ? 0 : a;
          h[c] = vt.isConcave(c, i, s, r), h[d] = vt.isConcave(d, i, s, r);
        }
        return i == 3 && (l.push(r[2]), l.push(r[0]), l.push(r[1])), l;
      }
      decompose(t, s) {
        let i = t, r = this.convexPolygons;
        this.polygonPool.freeAll(r), r.length = 0;
        let h = this.convexPolygonsIndices;
        this.polygonIndicesPool.freeAll(h), h.length = 0;
        let l = this.polygonIndicesPool.obtain();
        l.length = 0;
        let n = this.polygonPool.obtain();
        n.length = 0;
        let a = -1, o = 0;
        for (let c = 0, d = s.length; c < d; c += 3) {
          let f = s[c] << 1, m = s[c + 1] << 1, u = s[c + 2] << 1, g = i[f], w = i[f + 1], b = i[m], x = i[m + 1], p = i[u], v = i[u + 1], y = false;
          if (a == f) {
            let A = n.length - 4, C = vt.winding(n[A], n[A + 1], n[A + 2], n[A + 3], p, v), S = vt.winding(p, v, n[0], n[1], n[2], n[3]);
            C == o && S == o && (n.push(p), n.push(v), l.push(u), y = true);
          }
          y || (n.length > 0 ? (r.push(n), h.push(l)) : (this.polygonPool.free(n), this.polygonIndicesPool.free(l)), n = this.polygonPool.obtain(), n.length = 0, n.push(g), n.push(w), n.push(b), n.push(x), n.push(p), n.push(v), l = this.polygonIndicesPool.obtain(), l.length = 0, l.push(f), l.push(m), l.push(u), o = vt.winding(g, w, b, x, p, v), a = f);
        }
        n.length > 0 && (r.push(n), h.push(l));
        for (let c = 0, d = r.length; c < d; c++) {
          if (l = h[c], l.length == 0) continue;
          let f = l[0], m = l[l.length - 1];
          n = r[c];
          let u = n.length - 4, g = n[u], w = n[u + 1], b = n[u + 2], x = n[u + 3], p = n[0], v = n[1], y = n[2], A = n[3], C = vt.winding(g, w, b, x, p, v);
          for (let S = 0; S < d; S++) {
            if (S == c) continue;
            let I = h[S];
            if (I.length != 3) continue;
            let Y = I[0], k = I[1], F = I[2], X = r[S], E = X[X.length - 2], R = X[X.length - 1];
            if (Y != f || k != m) continue;
            let B = vt.winding(g, w, b, x, E, R), st = vt.winding(E, R, p, v, y, A);
            B == C && st == C && (X.length = 0, I.length = 0, n.push(E), n.push(R), l.push(F), g = b, w = x, b = E, x = R, S = 0);
          }
        }
        for (let c = r.length - 1; c >= 0; c--) n = r[c], n.length == 0 && (r.splice(c, 1), this.polygonPool.free(n), l = h[c], h.splice(c, 1), this.polygonIndicesPool.free(l));
        return r;
      }
      static isConcave(t, s, i, r) {
        let h = r[(s + t - 1) % s] << 1, l = r[t] << 1, n = r[(t + 1) % s] << 1;
        return !this.positiveArea(i[h], i[h + 1], i[l], i[l + 1], i[n], i[n + 1]);
      }
      static positiveArea(t, s, i, r, h, l) {
        return t * (l - r) + i * (s - l) + h * (r - s) >= 0;
      }
      static winding(t, s, i, r, h, l) {
        let n = i - t, a = r - s;
        return h * a - l * n + n * s - t * a >= 0 ? 1 : -1;
      }
    }, wi = class Us {
      triangulator = new pi();
      clippingPolygon = new Array();
      clipOutput = new Array();
      clippedVertices = new Array();
      clippedUVs = new Array();
      clippedTriangles = new Array();
      scratch = new Array();
      clipAttachment = null;
      clippingPolygons = null;
      clipStart(t, s) {
        if (this.clipAttachment) return 0;
        this.clipAttachment = s;
        let i = s.worldVerticesLength, r = L.setArraySize(this.clippingPolygon, i);
        s.computeWorldVertices(t, 0, i, r, 0, 2);
        let h = this.clippingPolygon;
        Us.makeClockwise(h);
        let l = this.clippingPolygons = this.triangulator.decompose(h, this.triangulator.triangulate(h));
        for (let n = 0, a = l.length; n < a; n++) {
          let o = l[n];
          Us.makeClockwise(o), o.push(o[0]), o.push(o[1]);
        }
        return l.length;
      }
      clipEndWithSlot(t) {
        this.clipAttachment && this.clipAttachment.endSlot == t.data && this.clipEnd();
      }
      clipEnd() {
        this.clipAttachment && (this.clipAttachment = null, this.clippingPolygons = null, this.clippedVertices.length = 0, this.clippedTriangles.length = 0, this.clippingPolygon.length = 0);
      }
      isClipping() {
        return this.clipAttachment != null;
      }
      clipTriangles(t, s, i, r, h, l, n, a) {
        let o, c, d, f, m, u;
        typeof s == "number" ? (o = i, c = r, d = h, f = l, m = n, u = a) : (o = s, c = i, d = r, f = h, m = l, u = n), d && f && m && typeof u == "boolean" ? this.clipTrianglesRender(t, o, c, d, f, m, u) : this.clipTrianglesNoRender(t, o, c);
      }
      clipTrianglesNoRender(t, s, i) {
        let r = this.clipOutput, h = this.clippedVertices, l = this.clippedTriangles, n = this.clippingPolygons, a = n.length, o = 0;
        h.length = 0, l.length = 0;
        for (let c = 0; c < i; c += 3) {
          let d = s[c] << 1, f = t[d], m = t[d + 1];
          d = s[c + 1] << 1;
          let u = t[d], g = t[d + 1];
          d = s[c + 2] << 1;
          let w = t[d], b = t[d + 1];
          for (let x = 0; x < a; x++) {
            let p = h.length;
            if (this.clip(f, m, u, g, w, b, n[x], r)) {
              let v = r.length;
              if (v == 0) continue;
              let y = v >> 1, A = this.clipOutput, C = L.setArraySize(h, p + y * 2);
              for (let I = 0; I < v; I += 2, p += 2) {
                let Y = A[I], k = A[I + 1];
                C[p] = Y, C[p + 1] = k;
              }
              p = l.length;
              let S = L.setArraySize(l, p + 3 * (y - 2));
              y--;
              for (let I = 1; I < y; I++, p += 3) S[p] = o, S[p + 1] = o + I, S[p + 2] = o + I + 1;
              o += y + 1;
            } else {
              let v = L.setArraySize(h, p + 6);
              v[p] = f, v[p + 1] = m, v[p + 2] = u, v[p + 3] = g, v[p + 4] = w, v[p + 5] = b, p = l.length;
              let y = L.setArraySize(l, p + 3);
              y[p] = o, y[p + 1] = o + 1, y[p + 2] = o + 2, o += 3;
              break;
            }
          }
        }
      }
      clipTrianglesRender(t, s, i, r, h, l, n) {
        let a = this.clipOutput, o = this.clippedVertices, c = this.clippedTriangles, d = this.clippingPolygons, f = d.length, m = n ? 12 : 8, u = 0;
        o.length = 0, c.length = 0;
        for (let g = 0; g < i; g += 3) {
          let w = s[g] << 1, b = t[w], x = t[w + 1], p = r[w], v = r[w + 1];
          w = s[g + 1] << 1;
          let y = t[w], A = t[w + 1], C = r[w], S = r[w + 1];
          w = s[g + 2] << 1;
          let I = t[w], Y = t[w + 1], k = r[w], F = r[w + 1];
          for (let X = 0; X < f; X++) {
            let E = o.length;
            if (this.clip(b, x, y, A, I, Y, d[X], a)) {
              let R = a.length;
              if (R == 0) continue;
              let B = A - Y, st = I - y, et = b - I, rt = Y - x, ct = 1 / (B * et + st * (x - Y)), ot = R >> 1, ut = this.clipOutput, Z = L.setArraySize(o, E + ot * m);
              for (let ht = 0; ht < R; ht += 2, E += m) {
                let bt = ut[ht], mt = ut[ht + 1];
                Z[E] = bt, Z[E + 1] = mt, Z[E + 2] = h.r, Z[E + 3] = h.g, Z[E + 4] = h.b, Z[E + 5] = h.a;
                let pt = bt - I, wt = mt - Y, Mt = (B * pt + st * wt) * ct, jt = (rt * pt + et * wt) * ct, ie = 1 - Mt - jt;
                Z[E + 6] = p * Mt + C * jt + k * ie, Z[E + 7] = v * Mt + S * jt + F * ie, n && (Z[E + 8] = l.r, Z[E + 9] = l.g, Z[E + 10] = l.b, Z[E + 11] = l.a);
              }
              E = c.length;
              let nt = L.setArraySize(c, E + 3 * (ot - 2));
              ot--;
              for (let ht = 1; ht < ot; ht++, E += 3) nt[E] = u, nt[E + 1] = u + ht, nt[E + 2] = u + ht + 1;
              u += ot + 1;
            } else {
              let R = L.setArraySize(o, E + 3 * m);
              R[E] = b, R[E + 1] = x, R[E + 2] = h.r, R[E + 3] = h.g, R[E + 4] = h.b, R[E + 5] = h.a, n ? (R[E + 6] = p, R[E + 7] = v, R[E + 8] = l.r, R[E + 9] = l.g, R[E + 10] = l.b, R[E + 11] = l.a, R[E + 12] = y, R[E + 13] = A, R[E + 14] = h.r, R[E + 15] = h.g, R[E + 16] = h.b, R[E + 17] = h.a, R[E + 18] = C, R[E + 19] = S, R[E + 20] = l.r, R[E + 21] = l.g, R[E + 22] = l.b, R[E + 23] = l.a, R[E + 24] = I, R[E + 25] = Y, R[E + 26] = h.r, R[E + 27] = h.g, R[E + 28] = h.b, R[E + 29] = h.a, R[E + 30] = k, R[E + 31] = F, R[E + 32] = l.r, R[E + 33] = l.g, R[E + 34] = l.b, R[E + 35] = l.a) : (R[E + 6] = p, R[E + 7] = v, R[E + 8] = y, R[E + 9] = A, R[E + 10] = h.r, R[E + 11] = h.g, R[E + 12] = h.b, R[E + 13] = h.a, R[E + 14] = C, R[E + 15] = S, R[E + 16] = I, R[E + 17] = Y, R[E + 18] = h.r, R[E + 19] = h.g, R[E + 20] = h.b, R[E + 21] = h.a, R[E + 22] = k, R[E + 23] = F), E = c.length;
              let B = L.setArraySize(c, E + 3);
              B[E] = u, B[E + 1] = u + 1, B[E + 2] = u + 2, u += 3;
              break;
            }
          }
        }
      }
      clipTrianglesUnpacked(t, s, i, r) {
        let h = this.clipOutput, l = this.clippedVertices, n = this.clippedUVs, a = this.clippedTriangles, o = this.clippingPolygons, c = o.length, d = 0;
        l.length = 0, n.length = 0, a.length = 0;
        for (let f = 0; f < i; f += 3) {
          let m = s[f] << 1, u = t[m], g = t[m + 1], w = r[m], b = r[m + 1];
          m = s[f + 1] << 1;
          let x = t[m], p = t[m + 1], v = r[m], y = r[m + 1];
          m = s[f + 2] << 1;
          let A = t[m], C = t[m + 1], S = r[m], I = r[m + 1];
          for (let Y = 0; Y < c; Y++) {
            let k = l.length;
            if (this.clip(u, g, x, p, A, C, o[Y], h)) {
              let F = h.length;
              if (F == 0) continue;
              let X = p - C, E = A - x, R = u - A, B = C - g, st = 1 / (X * R + E * (g - C)), et = F >> 1, rt = this.clipOutput, ct = L.setArraySize(l, k + et * 2), ot = L.setArraySize(n, k + et * 2);
              for (let Z = 0; Z < F; Z += 2, k += 2) {
                let nt = rt[Z], ht = rt[Z + 1];
                ct[k] = nt, ct[k + 1] = ht;
                let bt = nt - A, mt = ht - C, pt = (X * bt + E * mt) * st, wt = (B * bt + R * mt) * st, Mt = 1 - pt - wt;
                ot[k] = w * pt + v * wt + S * Mt, ot[k + 1] = b * pt + y * wt + I * Mt;
              }
              k = a.length;
              let ut = L.setArraySize(a, k + 3 * (et - 2));
              et--;
              for (let Z = 1; Z < et; Z++, k += 3) ut[k] = d, ut[k + 1] = d + Z, ut[k + 2] = d + Z + 1;
              d += et + 1;
            } else {
              let F = L.setArraySize(l, k + 6);
              F[k] = u, F[k + 1] = g, F[k + 2] = x, F[k + 3] = p, F[k + 4] = A, F[k + 5] = C;
              let X = L.setArraySize(n, k + 3 * 2);
              X[k] = w, X[k + 1] = b, X[k + 2] = v, X[k + 3] = y, X[k + 4] = S, X[k + 5] = I, k = a.length;
              let E = L.setArraySize(a, k + 3);
              E[k] = d, E[k + 1] = d + 1, E[k + 2] = d + 2, d += 3;
              break;
            }
          }
        }
      }
      clip(t, s, i, r, h, l, n, a) {
        let o = a, c = false, d;
        n.length % 4 >= 2 ? (d = a, a = this.scratch) : d = this.scratch, d.length = 0, d.push(t), d.push(s), d.push(i), d.push(r), d.push(h), d.push(l), d.push(t), d.push(s), a.length = 0;
        let f = n.length - 4, m = n;
        for (let u = 0; ; u += 2) {
          let g = m[u], w = m[u + 1], b = g - m[u + 2], x = w - m[u + 3], p = a.length, v = d;
          for (let A = 0, C = d.length - 2; A < C; ) {
            let S = v[A], I = v[A + 1];
            A += 2;
            let Y = v[A], k = v[A + 1], F = x * (g - Y) > b * (w - k), X = x * (g - S) - b * (w - I);
            if (X > 0) {
              if (F) {
                a.push(Y), a.push(k);
                continue;
              }
              let E = Y - S, R = k - I, B = X / (E * x - R * b);
              if (B >= 0 && B <= 1) a.push(S + E * B), a.push(I + R * B);
              else {
                a.push(Y), a.push(k);
                continue;
              }
            } else if (F) {
              let E = Y - S, R = k - I, B = X / (E * x - R * b);
              if (B >= 0 && B <= 1) a.push(S + E * B), a.push(I + R * B), a.push(Y), a.push(k);
              else {
                a.push(Y), a.push(k);
                continue;
              }
            }
            c = true;
          }
          if (p == a.length) return o.length = 0, true;
          if (a.push(a[0]), a.push(a[1]), u == f) break;
          let y = a;
          a = d, a.length = 0, d = y;
        }
        if (o != a) {
          o.length = 0;
          for (let u = 0, g = a.length - 2; u < g; u++) o[u] = a[u];
        } else o.length = o.length - 2;
        return c;
      }
      static makeClockwise(t) {
        let s = t, i = t.length, r = s[i - 2] * s[1] - s[0] * s[i - 1], h = 0, l = 0, n = 0, a = 0;
        for (let o = 0, c = i - 3; o < c; o += 2) h = s[o], l = s[o + 1], n = s[o + 2], a = s[o + 3], r += h * a - n * l;
        if (!(r < 0)) for (let o = 0, c = i - 2, d = i >> 1; o < d; o += 2) {
          let f = s[o], m = s[o + 1], u = c - o;
          s[o] = s[u], s[o + 1] = s[u + 1], s[u] = f, s[u + 1] = m;
        }
      }
    }, zr = class {
      attachmentLoader;
      scale = 1;
      linkedMeshes = new Array();
      constructor(e) {
        this.attachmentLoader = e;
      }
      readSkeletonData(e) {
        let t = this.scale, s = new Cs(), i = typeof e == "string" ? JSON.parse(e) : e, r = i.skeleton;
        if (r && (s.hash = r.hash, s.version = r.spine, s.x = r.x, s.y = r.y, s.width = r.width, s.height = r.height, s.referenceScale = M(r, "referenceScale", 100) * t, s.fps = r.fps, s.imagesPath = r.images ?? null, s.audioPath = r.audio ?? null), i.bones) for (let h = 0; h < i.bones.length; h++) {
          let l = i.bones[h], n = null, a = M(l, "parent", null);
          a && (n = s.findBone(a));
          let o = new us(s.bones.length, l.name, n);
          o.length = M(l, "length", 0) * t, o.x = M(l, "x", 0) * t, o.y = M(l, "y", 0) * t, o.rotation = M(l, "rotation", 0), o.scaleX = M(l, "scaleX", 1), o.scaleY = M(l, "scaleY", 1), o.shearX = M(l, "shearX", 0), o.shearY = M(l, "shearY", 0), o.inherit = L.enumValue(de, M(l, "inherit", "Normal")), o.skinRequired = M(l, "skin", false);
          let c = M(l, "color", null);
          c && o.color.setFromString(c), s.bones.push(o);
        }
        if (i.slots) for (let h = 0; h < i.slots.length; h++) {
          let l = i.slots[h], n = l.name, a = s.findBone(l.bone);
          if (!a) throw new Error(`Couldn't find bone ${l.bone} for slot ${n}`);
          let o = new Ts(s.slots.length, n, a), c = M(l, "color", null);
          c && o.color.setFromString(c);
          let d = M(l, "dark", null);
          d && (o.darkColor = tt.fromString(d)), o.attachmentName = M(l, "attachment", null), o.blendMode = L.enumValue(Is, M(l, "blend", "normal")), o.visible = M(l, "visible", true), s.slots.push(o);
        }
        if (i.ik) for (let h = 0; h < i.ik.length; h++) {
          let l = i.ik[h], n = new ws(l.name);
          n.order = M(l, "order", 0), n.skinRequired = M(l, "skin", false);
          for (let o = 0; o < l.bones.length; o++) {
            let c = s.findBone(l.bones[o]);
            if (!c) throw new Error(`Couldn't find bone ${l.bones[o]} for IK constraint ${l.name}.`);
            n.bones.push(c);
          }
          let a = s.findBone(l.target);
          if (!a) throw new Error(`Couldn't find target bone ${l.target} for IK constraint ${l.name}.`);
          n.target = a, n.mix = M(l, "mix", 1), n.softness = M(l, "softness", 0) * t, n.bendDirection = M(l, "bendPositive", true) ? 1 : -1, n.compress = M(l, "compress", false), n.stretch = M(l, "stretch", false), n.uniform = M(l, "uniform", false), s.ikConstraints.push(n);
        }
        if (i.transform) for (let h = 0; h < i.transform.length; h++) {
          let l = i.transform[h], n = new Ms(l.name);
          n.order = M(l, "order", 0), n.skinRequired = M(l, "skin", false);
          for (let c = 0; c < l.bones.length; c++) {
            let d = l.bones[c], f = s.findBone(d);
            if (!f) throw new Error(`Couldn't find bone ${d} for transform constraint ${l.name}.`);
            n.bones.push(f);
          }
          let a = l.target, o = s.findBone(a);
          if (!o) throw new Error(`Couldn't find target bone ${a} for transform constraint ${l.name}.`);
          n.target = o, n.local = M(l, "local", false), n.relative = M(l, "relative", false), n.offsetRotation = M(l, "rotation", 0), n.offsetX = M(l, "x", 0) * t, n.offsetY = M(l, "y", 0) * t, n.offsetScaleX = M(l, "scaleX", 0), n.offsetScaleY = M(l, "scaleY", 0), n.offsetShearY = M(l, "shearY", 0), n.mixRotate = M(l, "mixRotate", 1), n.mixX = M(l, "mixX", 1), n.mixY = M(l, "mixY", n.mixX), n.mixScaleX = M(l, "mixScaleX", 1), n.mixScaleY = M(l, "mixScaleY", n.mixScaleX), n.mixShearY = M(l, "mixShearY", 1), s.transformConstraints.push(n);
        }
        if (i.path) for (let h = 0; h < i.path.length; h++) {
          let l = i.path[h], n = new bs(l.name);
          n.order = M(l, "order", 0), n.skinRequired = M(l, "skin", false);
          for (let c = 0; c < l.bones.length; c++) {
            let d = l.bones[c], f = s.findBone(d);
            if (!f) throw new Error(`Couldn't find bone ${d} for path constraint ${l.name}.`);
            n.bones.push(f);
          }
          let a = l.target, o = s.findSlot(a);
          if (!o) throw new Error(`Couldn't find target slot ${a} for path constraint ${l.name}.`);
          n.target = o, n.positionMode = L.enumValue(vs, M(l, "positionMode", "Percent")), n.spacingMode = L.enumValue(ys, M(l, "spacingMode", "Length")), n.rotateMode = L.enumValue(As, M(l, "rotateMode", "Tangent")), n.offsetRotation = M(l, "rotation", 0), n.position = M(l, "position", 0), n.positionMode == 0 && (n.position *= t), n.spacing = M(l, "spacing", 0), (n.spacingMode == 0 || n.spacingMode == 1) && (n.spacing *= t), n.mixRotate = M(l, "mixRotate", 1), n.mixX = M(l, "mixX", 1), n.mixY = M(l, "mixY", n.mixX), s.pathConstraints.push(n);
        }
        if (i.physics) for (let h = 0; h < i.physics.length; h++) {
          const l = i.physics[h], n = new mi(l.name);
          n.order = M(l, "order", 0), n.skinRequired = M(l, "skin", false);
          const a = l.bone, o = s.findBone(a);
          if (o == null) throw new Error("Physics bone not found: " + a);
          n.bone = o, n.x = M(l, "x", 0), n.y = M(l, "y", 0), n.rotate = M(l, "rotate", 0), n.scaleX = M(l, "scaleX", 0), n.shearX = M(l, "shearX", 0), n.limit = M(l, "limit", 5e3) * t, n.step = 1 / M(l, "fps", 60), n.inertia = M(l, "inertia", 1), n.strength = M(l, "strength", 100), n.damping = M(l, "damping", 1), n.massInverse = 1 / M(l, "mass", 1), n.wind = M(l, "wind", 0), n.gravity = M(l, "gravity", 0), n.mix = M(l, "mix", 1), n.inertiaGlobal = M(l, "inertiaGlobal", false), n.strengthGlobal = M(l, "strengthGlobal", false), n.dampingGlobal = M(l, "dampingGlobal", false), n.massGlobal = M(l, "massGlobal", false), n.windGlobal = M(l, "windGlobal", false), n.gravityGlobal = M(l, "gravityGlobal", false), n.mixGlobal = M(l, "mixGlobal", false), s.physicsConstraints.push(n);
        }
        if (i.skins) for (let h = 0; h < i.skins.length; h++) {
          let l = i.skins[h], n = new fe(l.name);
          if (l.bones) for (let a = 0; a < l.bones.length; a++) {
            let o = l.bones[a], c = s.findBone(o);
            if (!c) throw new Error(`Couldn't find bone ${o} for skin ${l.name}.`);
            n.bones.push(c);
          }
          if (l.ik) for (let a = 0; a < l.ik.length; a++) {
            let o = l.ik[a], c = s.findIkConstraint(o);
            if (!c) throw new Error(`Couldn't find IK constraint ${o} for skin ${l.name}.`);
            n.constraints.push(c);
          }
          if (l.transform) for (let a = 0; a < l.transform.length; a++) {
            let o = l.transform[a], c = s.findTransformConstraint(o);
            if (!c) throw new Error(`Couldn't find transform constraint ${o} for skin ${l.name}.`);
            n.constraints.push(c);
          }
          if (l.path) for (let a = 0; a < l.path.length; a++) {
            let o = l.path[a], c = s.findPathConstraint(o);
            if (!c) throw new Error(`Couldn't find path constraint ${o} for skin ${l.name}.`);
            n.constraints.push(c);
          }
          if (l.physics) for (let a = 0; a < l.physics.length; a++) {
            let o = l.physics[a], c = s.findPhysicsConstraint(o);
            if (!c) throw new Error(`Couldn't find physics constraint ${o} for skin ${l.name}.`);
            n.constraints.push(c);
          }
          for (let a in l.attachments) {
            let o = s.findSlot(a);
            if (!o) throw new Error(`Couldn't find slot ${a} for skin ${l.name}.`);
            let c = l.attachments[a];
            for (let d in c) {
              let f = this.readAttachment(c[d], n, o.index, d, s);
              f && n.setAttachment(o.index, d, f);
            }
          }
          s.skins.push(n), n.name == "default" && (s.defaultSkin = n);
        }
        for (let h = 0, l = this.linkedMeshes.length; h < l; h++) {
          let n = this.linkedMeshes[h], a = n.skin ? s.findSkin(n.skin) : s.defaultSkin;
          if (!a) throw new Error(`Skin not found: ${n.skin}`);
          let o = a.getAttachment(n.slotIndex, n.parent);
          if (!o) throw new Error(`Parent mesh not found: ${n.parent}`);
          n.mesh.timelineAttachment = n.inheritTimeline ? o : n.mesh, n.mesh.setParentMesh(o), n.mesh.region != null && n.mesh.updateRegion();
        }
        if (this.linkedMeshes.length = 0, i.events) for (let h in i.events) {
          let l = i.events[h], n = new ps(h);
          n.intValue = M(l, "int", 0), n.floatValue = M(l, "float", 0), n.stringValue = M(l, "string", ""), n.audioPath = M(l, "audio", null), n.audioPath && (n.volume = M(l, "volume", 1), n.balance = M(l, "balance", 0)), s.events.push(n);
        }
        if (i.animations) for (let h in i.animations) {
          let l = i.animations[h];
          this.readAnimation(l, h, s);
        }
        return s;
      }
      readAttachment(e, t, s, i, r) {
        let h = this.scale;
        switch (i = M(e, "name", i), M(e, "type", "region")) {
          case "region": {
            let l = M(e, "path", i), n = this.readSequence(M(e, "sequence", null)), a = this.attachmentLoader.newRegionAttachment(t, i, l, n);
            if (!a) return null;
            a.path = l, a.x = M(e, "x", 0) * h, a.y = M(e, "y", 0) * h, a.scaleX = M(e, "scaleX", 1), a.scaleY = M(e, "scaleY", 1), a.rotation = M(e, "rotation", 0), a.width = e.width * h, a.height = e.height * h, a.sequence = n;
            let o = M(e, "color", null);
            return o && a.color.setFromString(o), a.region != null && a.updateRegion(), a;
          }
          case "boundingbox": {
            let l = this.attachmentLoader.newBoundingBoxAttachment(t, i);
            if (!l) return null;
            this.readVertices(e, l, e.vertexCount << 1);
            let n = M(e, "color", null);
            return n && l.color.setFromString(n), l;
          }
          case "mesh":
          case "linkedmesh": {
            let l = M(e, "path", i), n = this.readSequence(M(e, "sequence", null)), a = this.attachmentLoader.newMeshAttachment(t, i, l, n);
            if (!a) return null;
            a.path = l;
            let o = M(e, "color", null);
            o && a.color.setFromString(o), a.width = M(e, "width", 0) * h, a.height = M(e, "height", 0) * h, a.sequence = n;
            let c = M(e, "parent", null);
            if (c) return this.linkedMeshes.push(new Wr(a, M(e, "skin", null), s, c, M(e, "timelines", true))), a;
            let d = e.uvs;
            return this.readVertices(e, a, d.length), a.triangles = e.triangles, a.regionUVs = d, a.region != null && a.updateRegion(), a.edges = M(e, "edges", null), a.hullLength = M(e, "hull", 0) * 2, a;
          }
          case "path": {
            let l = this.attachmentLoader.newPathAttachment(t, i);
            if (!l) return null;
            l.closed = M(e, "closed", false), l.constantSpeed = M(e, "constantSpeed", true);
            let n = e.vertexCount;
            this.readVertices(e, l, n << 1);
            let a = L.newArray(n / 3, 0);
            for (let c = 0; c < e.lengths.length; c++) a[c] = e.lengths[c] * h;
            l.lengths = a;
            let o = M(e, "color", null);
            return o && l.color.setFromString(o), l;
          }
          case "point": {
            let l = this.attachmentLoader.newPointAttachment(t, i);
            if (!l) return null;
            l.x = M(e, "x", 0) * h, l.y = M(e, "y", 0) * h, l.rotation = M(e, "rotation", 0);
            let n = M(e, "color", null);
            return n && l.color.setFromString(n), l;
          }
          case "clipping": {
            let l = this.attachmentLoader.newClippingAttachment(t, i);
            if (!l) return null;
            let n = M(e, "end", null);
            n && (l.endSlot = r.findSlot(n));
            let a = e.vertexCount;
            this.readVertices(e, l, a << 1);
            let o = M(e, "color", null);
            return o && l.color.setFromString(o), l;
          }
        }
        return null;
      }
      readSequence(e) {
        if (e == null) return null;
        let t = new Hs(M(e, "count", 0));
        return t.start = M(e, "start", 1), t.digits = M(e, "digits", 0), t.setupIndex = M(e, "setup", 0), t;
      }
      readVertices(e, t, s) {
        let i = this.scale;
        t.worldVerticesLength = s;
        let r = e.vertices;
        if (s == r.length) {
          let n = L.toFloatArray(r);
          if (i != 1) for (let a = 0, o = r.length; a < o; a++) n[a] *= i;
          t.vertices = n;
          return;
        }
        let h = new Array(), l = new Array();
        for (let n = 0, a = r.length; n < a; ) {
          let o = r[n++];
          l.push(o);
          for (let c = n + o * 4; n < c; n += 4) l.push(r[n]), h.push(r[n + 1] * i), h.push(r[n + 2] * i), h.push(r[n + 3]);
        }
        t.bones = l, t.vertices = L.toFloatArray(h);
      }
      readAnimation(e, t, s) {
        let i = this.scale, r = new Array();
        if (e.slots) for (let l in e.slots) {
          let n = e.slots[l], a = s.findSlot(l);
          if (!a) throw new Error("Slot not found: " + l);
          let o = a.index;
          for (let c in n) {
            let d = n[c];
            if (!d) continue;
            let f = d.length;
            if (c == "attachment") {
              let m = new Ot(f, o);
              for (let u = 0; u < f; u++) {
                let g = d[u];
                m.setFrame(u, M(g, "time", 0), M(g, "name", null));
              }
              r.push(m);
            } else if (c == "rgba") {
              let m = new Ne(f, f << 2, o), u = d[0], g = M(u, "time", 0), w = tt.fromString(u.color);
              for (let b = 0, x = 0; ; b++) {
                m.setFrame(b, g, w.r, w.g, w.b, w.a);
                let p = d[b + 1];
                if (!p) {
                  m.shrink(x);
                  break;
                }
                let v = M(p, "time", 0), y = tt.fromString(p.color), A = u.curve;
                A && (x = lt(A, m, x, b, 0, g, v, w.r, y.r, 1), x = lt(A, m, x, b, 1, g, v, w.g, y.g, 1), x = lt(A, m, x, b, 2, g, v, w.b, y.b, 1), x = lt(A, m, x, b, 3, g, v, w.a, y.a, 1)), g = v, w = y, u = p;
              }
              r.push(m);
            } else if (c == "rgb") {
              let m = new Ue(f, f * 3, o), u = d[0], g = M(u, "time", 0), w = tt.fromString(u.color);
              for (let b = 0, x = 0; ; b++) {
                m.setFrame(b, g, w.r, w.g, w.b);
                let p = d[b + 1];
                if (!p) {
                  m.shrink(x);
                  break;
                }
                let v = M(p, "time", 0), y = tt.fromString(p.color), A = u.curve;
                A && (x = lt(A, m, x, b, 0, g, v, w.r, y.r, 1), x = lt(A, m, x, b, 1, g, v, w.g, y.g, 1), x = lt(A, m, x, b, 2, g, v, w.b, y.b, 1)), g = v, w = y, u = p;
              }
              r.push(m);
            } else if (c == "alpha") r.push(St(d, new ze(f, f, o), 0, 1));
            else if (c == "rgba2") {
              let m = new We(f, f * 7, o), u = d[0], g = M(u, "time", 0), w = tt.fromString(u.light), b = tt.fromString(u.dark);
              for (let x = 0, p = 0; ; x++) {
                m.setFrame(x, g, w.r, w.g, w.b, w.a, b.r, b.g, b.b);
                let v = d[x + 1];
                if (!v) {
                  m.shrink(p);
                  break;
                }
                let y = M(v, "time", 0), A = tt.fromString(v.light), C = tt.fromString(v.dark), S = u.curve;
                S && (p = lt(S, m, p, x, 0, g, y, w.r, A.r, 1), p = lt(S, m, p, x, 1, g, y, w.g, A.g, 1), p = lt(S, m, p, x, 2, g, y, w.b, A.b, 1), p = lt(S, m, p, x, 3, g, y, w.a, A.a, 1), p = lt(S, m, p, x, 4, g, y, b.r, C.r, 1), p = lt(S, m, p, x, 5, g, y, b.g, C.g, 1), p = lt(S, m, p, x, 6, g, y, b.b, C.b, 1)), g = y, w = A, b = C, u = v;
              }
              r.push(m);
            } else if (c == "rgb2") {
              let m = new qe(f, f * 6, o), u = d[0], g = M(u, "time", 0), w = tt.fromString(u.light), b = tt.fromString(u.dark);
              for (let x = 0, p = 0; ; x++) {
                m.setFrame(x, g, w.r, w.g, w.b, b.r, b.g, b.b);
                let v = d[x + 1];
                if (!v) {
                  m.shrink(p);
                  break;
                }
                let y = M(v, "time", 0), A = tt.fromString(v.light), C = tt.fromString(v.dark), S = u.curve;
                S && (p = lt(S, m, p, x, 0, g, y, w.r, A.r, 1), p = lt(S, m, p, x, 1, g, y, w.g, A.g, 1), p = lt(S, m, p, x, 2, g, y, w.b, A.b, 1), p = lt(S, m, p, x, 3, g, y, b.r, C.r, 1), p = lt(S, m, p, x, 4, g, y, b.g, C.g, 1), p = lt(S, m, p, x, 5, g, y, b.b, C.b, 1)), g = y, w = A, b = C, u = v;
              }
              r.push(m);
            }
          }
        }
        if (e.bones) for (let l in e.bones) {
          let n = e.bones[l], a = s.findBone(l);
          if (!a) throw new Error("Bone not found: " + l);
          let o = a.index;
          for (let c in n) {
            let d = n[c], f = d.length;
            if (f != 0) {
              if (c === "rotate") r.push(St(d, new Qt(f, f, o), 0, 1));
              else if (c === "translate") {
                let m = new Ye(f, f << 1, o);
                r.push(Rs(d, m, "x", "y", 0, i));
              } else if (c === "translatex") {
                let m = new ke(f, f, o);
                r.push(St(d, m, 0, i));
              } else if (c === "translatey") {
                let m = new Fe(f, f, o);
                r.push(St(d, m, 0, i));
              } else if (c === "scale") {
                let m = new Xe(f, f << 1, o);
                r.push(Rs(d, m, "x", "y", 1, 1));
              } else if (c === "scalex") {
                let m = new Pe(f, f, o);
                r.push(St(d, m, 1, 1));
              } else if (c === "scaley") {
                let m = new Le(f, f, o);
                r.push(St(d, m, 1, 1));
              } else if (c === "shear") {
                let m = new Be(f, f << 1, o);
                r.push(Rs(d, m, "x", "y", 0, 1));
              } else if (c === "shearx") {
                let m = new Ve(f, f, o);
                r.push(St(d, m, 0, 1));
              } else if (c === "sheary") {
                let m = new Oe(f, f, o);
                r.push(St(d, m, 0, 1));
              } else if (c === "inherit") {
                let m = new De(f, a.index);
                for (let u = 0; u < d.length; u++) {
                  let g = d[u];
                  m.setFrame(u, M(g, "time", 0), L.enumValue(de, M(g, "inherit", "Normal")));
                }
                r.push(m);
              }
            }
          }
        }
        if (e.ik) for (let l in e.ik) {
          let n = e.ik[l], a = n[0];
          if (!a) continue;
          let o = s.findIkConstraint(l);
          if (!o) throw new Error("IK Constraint not found: " + l);
          let c = s.ikConstraints.indexOf(o), d = new He(n.length, n.length << 1, c), f = M(a, "time", 0), m = M(a, "mix", 1), u = M(a, "softness", 0) * i;
          for (let g = 0, w = 0; ; g++) {
            d.setFrame(g, f, m, u, M(a, "bendPositive", true) ? 1 : -1, M(a, "compress", false), M(a, "stretch", false));
            let b = n[g + 1];
            if (!b) {
              d.shrink(w);
              break;
            }
            let x = M(b, "time", 0), p = M(b, "mix", 1), v = M(b, "softness", 0) * i, y = a.curve;
            y && (w = lt(y, d, w, g, 0, f, x, m, p, 1), w = lt(y, d, w, g, 1, f, x, u, v, i)), f = x, m = p, u = v, a = b;
          }
          r.push(d);
        }
        if (e.transform) for (let l in e.transform) {
          let n = e.transform[l], a = n[0];
          if (!a) continue;
          let o = s.findTransformConstraint(l);
          if (!o) throw new Error("Transform constraint not found: " + l);
          let c = s.transformConstraints.indexOf(o), d = new _e(n.length, n.length * 6, c), f = M(a, "time", 0), m = M(a, "mixRotate", 1), u = M(a, "mixX", 1), g = M(a, "mixY", u), w = M(a, "mixScaleX", 1), b = M(a, "mixScaleY", w), x = M(a, "mixShearY", 1);
          for (let p = 0, v = 0; ; p++) {
            d.setFrame(p, f, m, u, g, w, b, x);
            let y = n[p + 1];
            if (!y) {
              d.shrink(v);
              break;
            }
            let A = M(y, "time", 0), C = M(y, "mixRotate", 1), S = M(y, "mixX", 1), I = M(y, "mixY", S), Y = M(y, "mixScaleX", 1), k = M(y, "mixScaleY", Y), F = M(y, "mixShearY", 1), X = a.curve;
            X && (v = lt(X, d, v, p, 0, f, A, m, C, 1), v = lt(X, d, v, p, 1, f, A, u, S, 1), v = lt(X, d, v, p, 2, f, A, g, I, 1), v = lt(X, d, v, p, 3, f, A, w, Y, 1), v = lt(X, d, v, p, 4, f, A, b, k, 1), v = lt(X, d, v, p, 5, f, A, x, F, 1)), f = A, m = C, u = S, g = I, w = Y, b = k, w = Y, a = y;
          }
          r.push(d);
        }
        if (e.path) for (let l in e.path) {
          let n = e.path[l], a = s.findPathConstraint(l);
          if (!a) throw new Error("Path constraint not found: " + l);
          let o = s.pathConstraints.indexOf(a);
          for (let c in n) {
            let d = n[c], f = d[0];
            if (!f) continue;
            let m = d.length;
            if (c === "position") {
              let u = new je(m, m, o);
              r.push(St(d, u, 0, a.positionMode == 0 ? i : 1));
            } else if (c === "spacing") {
              let u = new Ze(m, m, o);
              r.push(St(d, u, 0, a.spacingMode == 0 || a.spacingMode == 1 ? i : 1));
            } else if (c === "mix") {
              let u = new Ke(m, m * 3, o), g = M(f, "time", 0), w = M(f, "mixRotate", 1), b = M(f, "mixX", 1), x = M(f, "mixY", b);
              for (let p = 0, v = 0; ; p++) {
                u.setFrame(p, g, w, b, x);
                let y = d[p + 1];
                if (!y) {
                  u.shrink(v);
                  break;
                }
                let A = M(y, "time", 0), C = M(y, "mixRotate", 1), S = M(y, "mixX", 1), I = M(y, "mixY", S), Y = f.curve;
                Y && (v = lt(Y, u, v, p, 0, g, A, w, C, 1), v = lt(Y, u, v, p, 1, g, A, b, S, 1), v = lt(Y, u, v, p, 2, g, A, x, I, 1)), g = A, w = C, b = S, x = I, f = y;
              }
              r.push(u);
            }
          }
        }
        if (e.physics) for (let l in e.physics) {
          let n = e.physics[l], a = -1;
          if (l.length > 0) {
            let o = s.findPhysicsConstraint(l);
            if (!o) throw new Error("Physics constraint not found: " + l);
            a = s.physicsConstraints.indexOf(o);
          }
          for (let o in n) {
            let c = n[o], d = c[0];
            if (!d) continue;
            let f = c.length;
            if (o == "reset") {
              const u = new rs(f, a);
              for (let g = 0; d != null; d = c[g + 1], g++) u.setFrame(g, M(d, "time", 0));
              r.push(u);
              continue;
            }
            let m;
            if (o == "inertia") m = new Je(f, f, a);
            else if (o == "strength") m = new Qe(f, f, a);
            else if (o == "damping") m = new $e(f, f, a);
            else if (o == "mass") m = new ts(f, f, a);
            else if (o == "wind") m = new es(f, f, a);
            else if (o == "gravity") m = new ss(f, f, a);
            else if (o == "mix") m = new is(f, f, a);
            else continue;
            r.push(St(c, m, 0, 1));
          }
        }
        if (e.attachments) for (let l in e.attachments) {
          let n = e.attachments[l], a = s.findSkin(l);
          if (!a) throw new Error("Skin not found: " + l);
          for (let o in n) {
            let c = n[o], d = s.findSlot(o);
            if (!d) throw new Error("Slot not found: " + o);
            let f = d.index;
            for (let m in c) {
              let u = c[m], g = a.getAttachment(f, m);
              for (let w in u) {
                let b = u[w], x = b[0];
                if (x) {
                  if (w == "deform") {
                    let p = g.bones, v = g.vertices, y = p ? v.length / 3 * 2 : v.length, A = new Ge(b.length, b.length, f, g), C = M(x, "time", 0);
                    for (let S = 0, I = 0; ; S++) {
                      let Y, k = M(x, "vertices", null);
                      if (!k) Y = p ? L.newFloatArray(y) : v;
                      else {
                        Y = L.newFloatArray(y);
                        let R = M(x, "offset", 0);
                        if (L.arrayCopy(k, 0, Y, R, k.length), i != 1) for (let B = R, st = B + k.length; B < st; B++) Y[B] *= i;
                        if (!p) for (let B = 0; B < y; B++) Y[B] += v[B];
                      }
                      A.setFrame(S, C, Y);
                      let F = b[S + 1];
                      if (!F) {
                        A.shrink(I);
                        break;
                      }
                      let X = M(F, "time", 0), E = x.curve;
                      E && (I = lt(E, A, I, S, 0, C, X, 0, 1, 1)), C = X, x = F;
                    }
                    r.push(A);
                  } else if (w == "sequence") {
                    let p = new ns(b.length, f, g), v = 0;
                    for (let y = 0; y < b.length; y++) {
                      let A = M(x, "delay", v), C = M(x, "time", 0), S = _s[M(x, "mode", "hold")], I = M(x, "index", 0);
                      p.setFrame(y, C, S, I, A), v = A, x = b[y + 1];
                    }
                    r.push(p);
                  }
                }
              }
            }
          }
        }
        if (e.drawOrder) {
          let l = new zt(e.drawOrder.length), n = s.slots.length, a = 0;
          for (let o = 0; o < e.drawOrder.length; o++, a++) {
            let c = e.drawOrder[o], d = null, f = M(c, "offsets", null);
            if (f) {
              d = L.newArray(n, -1);
              let m = L.newArray(n - f.length, 0), u = 0, g = 0;
              for (let w = 0; w < f.length; w++) {
                let b = f[w], x = s.findSlot(b.slot);
                if (!x) throw new Error("Slot not found: " + x);
                let p = x.index;
                for (; u != p; ) m[g++] = u++;
                d[u + b.offset] = u++;
              }
              for (; u < n; ) m[g++] = u++;
              for (let w = n - 1; w >= 0; w--) d[w] == -1 && (d[w] = m[--g]);
            }
            l.setFrame(a, M(c, "time", 0), d);
          }
          r.push(l);
        }
        if (e.events) {
          let l = new le(e.events.length), n = 0;
          for (let a = 0; a < e.events.length; a++, n++) {
            let o = e.events[a], c = s.findEvent(o.name);
            if (!c) throw new Error("Event not found: " + o.name);
            let d = new xs(L.toSinglePrecision(M(o, "time", 0)), c);
            d.intValue = M(o, "int", c.intValue), d.floatValue = M(o, "float", c.floatValue), d.stringValue = M(o, "string", c.stringValue), d.data.audioPath && (d.volume = M(o, "volume", 1), d.balance = M(o, "balance", 0)), l.setFrame(n, d);
          }
          r.push(l);
        }
        let h = 0;
        for (let l = 0, n = r.length; l < n; l++) h = Math.max(h, r[l].getDuration());
        s.animations.push(new ne(t, r, h));
      }
    }, Wr = class {
      parent;
      skin;
      slotIndex;
      mesh;
      inheritTimeline;
      constructor(e, t, s, i, r) {
        this.mesh = e, this.skin = t, this.slotIndex = s, this.parent = i, this.inheritTimeline = r;
      }
    };
    function St(e, t, s, i) {
      let r = e[0], h = M(r, "time", 0), l = M(r, "value", s) * i, n = 0;
      for (let a = 0; ; a++) {
        t.setFrame(a, h, l);
        let o = e[a + 1];
        if (!o) return t.shrink(n), t;
        let c = M(o, "time", 0), d = M(o, "value", s) * i;
        r.curve && (n = lt(r.curve, t, n, a, 0, h, c, l, d, i)), h = c, l = d, r = o;
      }
    }
    function Rs(e, t, s, i, r, h) {
      let l = e[0], n = M(l, "time", 0), a = M(l, s, r) * h, o = M(l, i, r) * h, c = 0;
      for (let d = 0; ; d++) {
        t.setFrame(d, n, a, o);
        let f = e[d + 1];
        if (!f) return t.shrink(c), t;
        let m = M(f, "time", 0), u = M(f, s, r) * h, g = M(f, i, r) * h, w = l.curve;
        w && (c = lt(w, t, c, d, 0, n, m, a, u, h), c = lt(w, t, c, d, 1, n, m, o, g, h)), n = m, a = u, o = g, l = f;
      }
    }
    function lt(e, t, s, i, r, h, l, n, a, o) {
      if (e == "stepped") return t.setStepped(i), s;
      let c = r << 2, d = e[c], f = e[c + 1] * o, m = e[c + 2], u = e[c + 3] * o;
      return t.setBezier(s, i, r, h, n, d, f, m, u, l, a), s + 1;
    }
    function M(e, t, s) {
      return e[t] !== void 0 ? e[t] : s;
    }
    typeof Math.fround > "u" && (Math.fround = /* @__PURE__ */ (function(e) {
      return function(t) {
        return e[0] = t, e[0];
      };
    })(new Float32Array(1)));
    var xt = class {
      canvas;
      gl;
      restorables = [];
      constructor(e, t = { alpha: true }) {
        if (e instanceof WebGLRenderingContext || typeof WebGL2RenderingContext < "u" && e instanceof WebGL2RenderingContext) this.gl = e, this.canvas = this.gl.canvas;
        else {
          const s = e;
          this.gl = s.getContext("webgl2", t) || s.getContext("webgl", t), this.canvas = s, s.addEventListener("webglcontextlost", this.contextLostHandler), s.addEventListener("webglcontextrestored", this.contextRestoredHandler);
        }
      }
      contextLostHandler = (e) => {
        e && e.preventDefault();
      };
      contextRestoredHandler = () => {
        for (let e = 0, t = this.restorables.length; e < t; e++) this.restorables[e].restore();
      };
      dispose() {
        this.canvas.removeEventListener("webglcontextlost", this.contextLostHandler), this.canvas.removeEventListener("webglcontextrestored", this.contextRestoredHandler);
      }
      addRestorable(e) {
        this.restorables.push(e);
      }
      removeRestorable(e) {
        const t = this.restorables.indexOf(e);
        t > -1 && this.restorables.splice(t, 1);
      }
    }, Gt = class Te extends cs {
      context;
      texture = null;
      boundUnit = 0;
      useMipMaps = false;
      static DISABLE_UNPACK_PREMULTIPLIED_ALPHA_WEBGL = false;
      constructor(t, s, i = false) {
        super(s), this.context = t instanceof xt ? t : new xt(t), this.useMipMaps = i, this.restore(), this.context.addRestorable(this);
      }
      setFilters(t, s) {
        let i = this.context.gl;
        this.bind(), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, t), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, Te.validateMagFilter(s)), this.useMipMaps = Te.usesMipMaps(t), this.useMipMaps && i.generateMipmap(i.TEXTURE_2D);
      }
      static validateMagFilter(t) {
        switch (t) {
          case 9987:
          case 9985:
          case 9986:
          case 9984:
            return 9729;
          default:
            return t;
        }
      }
      static usesMipMaps(t) {
        switch (t) {
          case 9987:
          case 9985:
          case 9986:
          case 9984:
            return true;
          default:
            return false;
        }
      }
      setWraps(t, s) {
        let i = this.context.gl;
        this.bind(), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, t), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, s);
      }
      update(t) {
        let s = this.context.gl;
        this.texture || (this.texture = this.context.gl.createTexture()), this.bind(), s.texImage2D(s.TEXTURE_2D, 0, s.RGBA, s.RGBA, s.UNSIGNED_BYTE, this._image), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MAG_FILTER, s.LINEAR), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MIN_FILTER, t ? s.LINEAR_MIPMAP_LINEAR : s.LINEAR), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE), t && s.generateMipmap(s.TEXTURE_2D);
      }
      restore() {
        this.texture = null, this.update(this.useMipMaps);
      }
      bind(t = 0) {
        let s = this.context.gl;
        this.boundUnit = t, s.activeTexture(s.TEXTURE0 + t), s.bindTexture(s.TEXTURE_2D, this.texture);
      }
      unbind() {
        let t = this.context.gl;
        t.activeTexture(t.TEXTURE0 + this.boundUnit), t.bindTexture(t.TEXTURE_2D, null);
      }
      dispose() {
        this.context.removeRestorable(this), this.context.gl.deleteTexture(this.texture);
      }
    }, bi = class extends ai {
      constructor(e, t = "", s = new gs()) {
        super((i) => new Gt(e, i), t, s);
      }
    }, At = class {
      x = 0;
      y = 0;
      z = 0;
      constructor(e = 0, t = 0, s = 0) {
        this.x = e, this.y = t, this.z = s;
      }
      setFrom(e) {
        return this.x = e.x, this.y = e.y, this.z = e.z, this;
      }
      set(e, t, s) {
        return this.x = e, this.y = t, this.z = s, this;
      }
      add(e) {
        return this.x += e.x, this.y += e.y, this.z += e.z, this;
      }
      sub(e) {
        return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
      }
      scale(e) {
        return this.x *= e, this.y *= e, this.z *= e, this;
      }
      normalize() {
        let e = this.length();
        return e == 0 ? this : (e = 1 / e, this.x *= e, this.y *= e, this.z *= e, this);
      }
      cross(e) {
        return this.set(this.y * e.z - this.z * e.y, this.z * e.x - this.x * e.z, this.x * e.y - this.y * e.x);
      }
      multiply(e) {
        let t = e.values;
        return this.set(this.x * t[V] + this.y * t[W] + this.z * t[q] + t[O], this.x * t[G] + this.y * t[D] + this.z * t[H] + t[N], this.x * t[_] + this.y * t[j] + this.z * t[U] + t[z]);
      }
      project(e) {
        let t = e.values, s = 1 / (this.x * t[J] + this.y * t[Q] + this.z * t[$] + t[K]);
        return this.set((this.x * t[V] + this.y * t[W] + this.z * t[q] + t[O]) * s, (this.x * t[G] + this.y * t[D] + this.z * t[H] + t[N]) * s, (this.x * t[_] + this.y * t[j] + this.z * t[U] + t[z]) * s);
      }
      dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      }
      distance(e) {
        let t = e.x - this.x, s = e.y - this.y, i = e.z - this.z;
        return Math.sqrt(t * t + s * s + i * i);
      }
    }, V = 0, W = 4, q = 8, O = 12, G = 1, D = 5, H = 9, N = 13, _ = 2, j = 6, U = 10, z = 14, J = 3, Q = 7, $ = 11, K = 15, se = class Rt {
      temp = new Float32Array(16);
      values = new Float32Array(16);
      static xAxis = new At();
      static yAxis = new At();
      static zAxis = new At();
      static tmpMatrix = new Rt();
      constructor() {
        let t = this.values;
        t[V] = 1, t[D] = 1, t[U] = 1, t[K] = 1;
      }
      set(t) {
        return this.values.set(t), this;
      }
      transpose() {
        let t = this.temp, s = this.values;
        return t[V] = s[V], t[W] = s[G], t[q] = s[_], t[O] = s[J], t[G] = s[W], t[D] = s[D], t[H] = s[j], t[N] = s[Q], t[_] = s[q], t[j] = s[H], t[U] = s[U], t[z] = s[$], t[J] = s[O], t[Q] = s[N], t[$] = s[z], t[K] = s[K], this.set(t);
      }
      identity() {
        let t = this.values;
        return t[V] = 1, t[W] = 0, t[q] = 0, t[O] = 0, t[G] = 0, t[D] = 1, t[H] = 0, t[N] = 0, t[_] = 0, t[j] = 0, t[U] = 1, t[z] = 0, t[J] = 0, t[Q] = 0, t[$] = 0, t[K] = 1, this;
      }
      invert() {
        let t = this.values, s = this.temp, i = t[J] * t[j] * t[H] * t[O] - t[_] * t[Q] * t[H] * t[O] - t[J] * t[D] * t[U] * t[O] + t[G] * t[Q] * t[U] * t[O] + t[_] * t[D] * t[$] * t[O] - t[G] * t[j] * t[$] * t[O] - t[J] * t[j] * t[q] * t[N] + t[_] * t[Q] * t[q] * t[N] + t[J] * t[W] * t[U] * t[N] - t[V] * t[Q] * t[U] * t[N] - t[_] * t[W] * t[$] * t[N] + t[V] * t[j] * t[$] * t[N] + t[J] * t[D] * t[q] * t[z] - t[G] * t[Q] * t[q] * t[z] - t[J] * t[W] * t[H] * t[z] + t[V] * t[Q] * t[H] * t[z] + t[G] * t[W] * t[$] * t[z] - t[V] * t[D] * t[$] * t[z] - t[_] * t[D] * t[q] * t[K] + t[G] * t[j] * t[q] * t[K] + t[_] * t[W] * t[H] * t[K] - t[V] * t[j] * t[H] * t[K] - t[G] * t[W] * t[U] * t[K] + t[V] * t[D] * t[U] * t[K];
        if (i == 0) throw new Error("non-invertible matrix");
        let r = 1 / i;
        return s[V] = t[H] * t[z] * t[Q] - t[N] * t[U] * t[Q] + t[N] * t[j] * t[$] - t[D] * t[z] * t[$] - t[H] * t[j] * t[K] + t[D] * t[U] * t[K], s[W] = t[O] * t[U] * t[Q] - t[q] * t[z] * t[Q] - t[O] * t[j] * t[$] + t[W] * t[z] * t[$] + t[q] * t[j] * t[K] - t[W] * t[U] * t[K], s[q] = t[q] * t[N] * t[Q] - t[O] * t[H] * t[Q] + t[O] * t[D] * t[$] - t[W] * t[N] * t[$] - t[q] * t[D] * t[K] + t[W] * t[H] * t[K], s[O] = t[O] * t[H] * t[j] - t[q] * t[N] * t[j] - t[O] * t[D] * t[U] + t[W] * t[N] * t[U] + t[q] * t[D] * t[z] - t[W] * t[H] * t[z], s[G] = t[N] * t[U] * t[J] - t[H] * t[z] * t[J] - t[N] * t[_] * t[$] + t[G] * t[z] * t[$] + t[H] * t[_] * t[K] - t[G] * t[U] * t[K], s[D] = t[q] * t[z] * t[J] - t[O] * t[U] * t[J] + t[O] * t[_] * t[$] - t[V] * t[z] * t[$] - t[q] * t[_] * t[K] + t[V] * t[U] * t[K], s[H] = t[O] * t[H] * t[J] - t[q] * t[N] * t[J] - t[O] * t[G] * t[$] + t[V] * t[N] * t[$] + t[q] * t[G] * t[K] - t[V] * t[H] * t[K], s[N] = t[q] * t[N] * t[_] - t[O] * t[H] * t[_] + t[O] * t[G] * t[U] - t[V] * t[N] * t[U] - t[q] * t[G] * t[z] + t[V] * t[H] * t[z], s[_] = t[D] * t[z] * t[J] - t[N] * t[j] * t[J] + t[N] * t[_] * t[Q] - t[G] * t[z] * t[Q] - t[D] * t[_] * t[K] + t[G] * t[j] * t[K], s[j] = t[O] * t[j] * t[J] - t[W] * t[z] * t[J] - t[O] * t[_] * t[Q] + t[V] * t[z] * t[Q] + t[W] * t[_] * t[K] - t[V] * t[j] * t[K], s[U] = t[W] * t[N] * t[J] - t[O] * t[D] * t[J] + t[O] * t[G] * t[Q] - t[V] * t[N] * t[Q] - t[W] * t[G] * t[K] + t[V] * t[D] * t[K], s[z] = t[O] * t[D] * t[_] - t[W] * t[N] * t[_] - t[O] * t[G] * t[j] + t[V] * t[N] * t[j] + t[W] * t[G] * t[z] - t[V] * t[D] * t[z], s[J] = t[H] * t[j] * t[J] - t[D] * t[U] * t[J] - t[H] * t[_] * t[Q] + t[G] * t[U] * t[Q] + t[D] * t[_] * t[$] - t[G] * t[j] * t[$], s[Q] = t[W] * t[U] * t[J] - t[q] * t[j] * t[J] + t[q] * t[_] * t[Q] - t[V] * t[U] * t[Q] - t[W] * t[_] * t[$] + t[V] * t[j] * t[$], s[$] = t[q] * t[D] * t[J] - t[W] * t[H] * t[J] - t[q] * t[G] * t[Q] + t[V] * t[H] * t[Q] + t[W] * t[G] * t[$] - t[V] * t[D] * t[$], s[K] = t[W] * t[H] * t[_] - t[q] * t[D] * t[_] + t[q] * t[G] * t[j] - t[V] * t[H] * t[j] - t[W] * t[G] * t[U] + t[V] * t[D] * t[U], t[V] = s[V] * r, t[W] = s[W] * r, t[q] = s[q] * r, t[O] = s[O] * r, t[G] = s[G] * r, t[D] = s[D] * r, t[H] = s[H] * r, t[N] = s[N] * r, t[_] = s[_] * r, t[j] = s[j] * r, t[U] = s[U] * r, t[z] = s[z] * r, t[J] = s[J] * r, t[Q] = s[Q] * r, t[$] = s[$] * r, t[K] = s[K] * r, this;
      }
      determinant() {
        let t = this.values;
        return t[J] * t[j] * t[H] * t[O] - t[_] * t[Q] * t[H] * t[O] - t[J] * t[D] * t[U] * t[O] + t[G] * t[Q] * t[U] * t[O] + t[_] * t[D] * t[$] * t[O] - t[G] * t[j] * t[$] * t[O] - t[J] * t[j] * t[q] * t[N] + t[_] * t[Q] * t[q] * t[N] + t[J] * t[W] * t[U] * t[N] - t[V] * t[Q] * t[U] * t[N] - t[_] * t[W] * t[$] * t[N] + t[V] * t[j] * t[$] * t[N] + t[J] * t[D] * t[q] * t[z] - t[G] * t[Q] * t[q] * t[z] - t[J] * t[W] * t[H] * t[z] + t[V] * t[Q] * t[H] * t[z] + t[G] * t[W] * t[$] * t[z] - t[V] * t[D] * t[$] * t[z] - t[_] * t[D] * t[q] * t[K] + t[G] * t[j] * t[q] * t[K] + t[_] * t[W] * t[H] * t[K] - t[V] * t[j] * t[H] * t[K] - t[G] * t[W] * t[U] * t[K] + t[V] * t[D] * t[U] * t[K];
      }
      translate(t, s, i) {
        let r = this.values;
        return r[O] += t, r[N] += s, r[z] += i, this;
      }
      copy() {
        return new Rt().set(this.values);
      }
      projection(t, s, i, r) {
        this.identity();
        let h = 1 / Math.tan(i * (Math.PI / 180) / 2), l = (s + t) / (t - s), n = 2 * s * t / (t - s), a = this.values;
        return a[V] = h / r, a[G] = 0, a[_] = 0, a[J] = 0, a[W] = 0, a[D] = h, a[j] = 0, a[Q] = 0, a[q] = 0, a[H] = 0, a[U] = l, a[$] = -1, a[O] = 0, a[N] = 0, a[z] = n, a[K] = 0, this;
      }
      ortho2d(t, s, i, r) {
        return this.ortho(t, t + i, s, s + r, 0, 1);
      }
      ortho(t, s, i, r, h, l) {
        this.identity();
        let n = 2 / (s - t), a = 2 / (r - i), o = -2 / (l - h), c = -(s + t) / (s - t), d = -(r + i) / (r - i), f = -(l + h) / (l - h), m = this.values;
        return m[V] = n, m[G] = 0, m[_] = 0, m[J] = 0, m[W] = 0, m[D] = a, m[j] = 0, m[Q] = 0, m[q] = 0, m[H] = 0, m[U] = o, m[$] = 0, m[O] = c, m[N] = d, m[z] = f, m[K] = 1, this;
      }
      multiply(t) {
        let s = this.temp, i = this.values, r = t.values;
        return s[V] = i[V] * r[V] + i[W] * r[G] + i[q] * r[_] + i[O] * r[J], s[W] = i[V] * r[W] + i[W] * r[D] + i[q] * r[j] + i[O] * r[Q], s[q] = i[V] * r[q] + i[W] * r[H] + i[q] * r[U] + i[O] * r[$], s[O] = i[V] * r[O] + i[W] * r[N] + i[q] * r[z] + i[O] * r[K], s[G] = i[G] * r[V] + i[D] * r[G] + i[H] * r[_] + i[N] * r[J], s[D] = i[G] * r[W] + i[D] * r[D] + i[H] * r[j] + i[N] * r[Q], s[H] = i[G] * r[q] + i[D] * r[H] + i[H] * r[U] + i[N] * r[$], s[N] = i[G] * r[O] + i[D] * r[N] + i[H] * r[z] + i[N] * r[K], s[_] = i[_] * r[V] + i[j] * r[G] + i[U] * r[_] + i[z] * r[J], s[j] = i[_] * r[W] + i[j] * r[D] + i[U] * r[j] + i[z] * r[Q], s[U] = i[_] * r[q] + i[j] * r[H] + i[U] * r[U] + i[z] * r[$], s[z] = i[_] * r[O] + i[j] * r[N] + i[U] * r[z] + i[z] * r[K], s[J] = i[J] * r[V] + i[Q] * r[G] + i[$] * r[_] + i[K] * r[J], s[Q] = i[J] * r[W] + i[Q] * r[D] + i[$] * r[j] + i[K] * r[Q], s[$] = i[J] * r[q] + i[Q] * r[H] + i[$] * r[U] + i[K] * r[$], s[K] = i[J] * r[O] + i[Q] * r[N] + i[$] * r[z] + i[K] * r[K], this.set(this.temp);
      }
      multiplyLeft(t) {
        let s = this.temp, i = this.values, r = t.values;
        return s[V] = r[V] * i[V] + r[W] * i[G] + r[q] * i[_] + r[O] * i[J], s[W] = r[V] * i[W] + r[W] * i[D] + r[q] * i[j] + r[O] * i[Q], s[q] = r[V] * i[q] + r[W] * i[H] + r[q] * i[U] + r[O] * i[$], s[O] = r[V] * i[O] + r[W] * i[N] + r[q] * i[z] + r[O] * i[K], s[G] = r[G] * i[V] + r[D] * i[G] + r[H] * i[_] + r[N] * i[J], s[D] = r[G] * i[W] + r[D] * i[D] + r[H] * i[j] + r[N] * i[Q], s[H] = r[G] * i[q] + r[D] * i[H] + r[H] * i[U] + r[N] * i[$], s[N] = r[G] * i[O] + r[D] * i[N] + r[H] * i[z] + r[N] * i[K], s[_] = r[_] * i[V] + r[j] * i[G] + r[U] * i[_] + r[z] * i[J], s[j] = r[_] * i[W] + r[j] * i[D] + r[U] * i[j] + r[z] * i[Q], s[U] = r[_] * i[q] + r[j] * i[H] + r[U] * i[U] + r[z] * i[$], s[z] = r[_] * i[O] + r[j] * i[N] + r[U] * i[z] + r[z] * i[K], s[J] = r[J] * i[V] + r[Q] * i[G] + r[$] * i[_] + r[K] * i[J], s[Q] = r[J] * i[W] + r[Q] * i[D] + r[$] * i[j] + r[K] * i[Q], s[$] = r[J] * i[q] + r[Q] * i[H] + r[$] * i[U] + r[K] * i[$], s[K] = r[J] * i[O] + r[Q] * i[N] + r[$] * i[z] + r[K] * i[K], this.set(this.temp);
      }
      lookAt(t, s, i) {
        let r = Rt.xAxis, h = Rt.yAxis, l = Rt.zAxis;
        l.setFrom(s).normalize(), r.setFrom(s).normalize(), r.cross(i).normalize(), h.setFrom(r).cross(l).normalize(), this.identity();
        let n = this.values;
        return n[V] = r.x, n[W] = r.y, n[q] = r.z, n[G] = h.x, n[D] = h.y, n[H] = h.z, n[_] = -l.x, n[j] = -l.y, n[U] = -l.z, Rt.tmpMatrix.identity(), Rt.tmpMatrix.values[O] = -t.x, Rt.tmpMatrix.values[N] = -t.y, Rt.tmpMatrix.values[z] = -t.z, this.multiply(Rt.tmpMatrix), this;
      }
    }, vi = class {
      position = new At(0, 0, 0);
      direction = new At(0, 0, -1);
      up = new At(0, 1, 0);
      near = 0;
      far = 100;
      zoom = 1;
      viewportWidth = 0;
      viewportHeight = 0;
      projectionView = new se();
      inverseProjectionView = new se();
      projection = new se();
      view = new se();
      constructor(e, t) {
        this.viewportWidth = e, this.viewportHeight = t, this.update();
      }
      update() {
        let e = this.projection, t = this.view, s = this.projectionView, i = this.inverseProjectionView, r = this.zoom, h = this.viewportWidth, l = this.viewportHeight;
        e.ortho(r * (-h / 2), r * (h / 2), r * (-l / 2), r * (l / 2), this.near, this.far), t.lookAt(this.position, this.direction, this.up), s.set(e.values), s.multiply(t), i.set(s.values).invert();
      }
      screenToWorld(e, t, s) {
        let i = e.x, r = s - e.y - 1;
        return e.x = 2 * i / t - 1, e.y = 2 * r / s - 1, e.z = 2 * e.z - 1, e.project(this.inverseProjectionView), e;
      }
      worldToScreen(e, t, s) {
        return e.project(this.projectionView), e.x = t * (e.x + 1) / 2, e.y = s * (e.y + 1) / 2, e.z = (e.z + 1) / 2, e;
      }
      setViewport(e, t) {
        this.viewportWidth = e, this.viewportHeight = t;
      }
    }, Ys = class {
      element;
      mouseX = 0;
      mouseY = 0;
      buttonDown = false;
      touch0 = null;
      touch1 = null;
      initialPinchDistance = 0;
      listeners = new Array();
      autoPreventDefault;
      isTouch = false;
      callbacks;
      constructor(e, t = true) {
        this.element = e, this.autoPreventDefault = t, this.callbacks = this.setupCallbacks(e);
      }
      setupCallbacks(e) {
        const t = (a) => {
          if (a instanceof MouseEvent && !this.isTouch) {
            let o = e.getBoundingClientRect();
            this.mouseX = a.clientX - o.left, this.mouseY = a.clientY - o.top, this.buttonDown = true, this.listeners.map((c) => {
              c.down && c.down(this.mouseX, this.mouseY, a);
            });
          }
        }, s = (a) => {
          if (a instanceof MouseEvent && !this.isTouch) {
            let o = e.getBoundingClientRect();
            this.mouseX = a.clientX - o.left, this.mouseY = a.clientY - o.top, this.listeners.map((c) => {
              this.buttonDown ? c.dragged && c.dragged(this.mouseX, this.mouseY, a) : c.moved && c.moved(this.mouseX, this.mouseY, a);
            });
          }
        }, i = (a) => {
          if (a instanceof MouseEvent && !this.isTouch) {
            let o = e.getBoundingClientRect();
            this.mouseX = a.clientX - o.left, this.mouseY = a.clientY - o.top, this.buttonDown = false, this.listeners.map((c) => {
              c.up && c.up(this.mouseX, this.mouseY, a);
            });
          }
        }, r = (a) => {
          this.autoPreventDefault && a.preventDefault();
          let o = a.deltaY;
          a.deltaMode == WheelEvent.DOM_DELTA_LINE && (o *= 8), a.deltaMode == WheelEvent.DOM_DELTA_PAGE && (o *= 24), this.listeners.map((c) => {
            c.wheel && c.wheel(a.deltaY, a);
          });
        }, h = (a) => {
          if (this.isTouch = true, !this.touch0 || !this.touch1) {
            var o = a.changedTouches;
            let c = o.item(0);
            if (!c) return;
            let d = e.getBoundingClientRect(), f = c.clientX - d.left, m = c.clientY - d.top, u = new yi(c.identifier, f, m);
            if (this.mouseX = f, this.mouseY = m, this.buttonDown = true, !this.touch0) this.touch0 = u, this.listeners.map((g) => {
              g.down && g.down(u.x, u.y, a);
            });
            else if (!this.touch1) {
              this.touch1 = u;
              let g = this.touch1.x - this.touch0.x, w = this.touch1.x - this.touch0.x;
              this.initialPinchDistance = Math.sqrt(g * g + w * w), this.listeners.map((b) => {
                b.zoom && b.zoom(this.initialPinchDistance, this.initialPinchDistance, a);
              });
            }
          }
          this.autoPreventDefault && a.preventDefault();
        }, l = (a) => {
          if (this.isTouch = true, this.touch0) {
            var o = a.changedTouches;
            let f = e.getBoundingClientRect();
            for (var c = 0; c < o.length; c++) {
              var d = o[c];
              let m = d.clientX - f.left, u = d.clientY - f.top;
              this.touch0.identifier === d.identifier && (this.touch0.x = this.mouseX = m, this.touch0.y = this.mouseY = u, this.listeners.map((g) => {
                g.dragged && g.dragged(m, u, a);
              })), this.touch1 && this.touch1.identifier === d.identifier && (this.touch1.x = this.mouseX = m, this.touch1.y = this.mouseY = u);
            }
            if (this.touch0 && this.touch1) {
              let m = this.touch1.x - this.touch0.x, u = this.touch1.x - this.touch0.x, g = Math.sqrt(m * m + u * u);
              this.listeners.map((w) => {
                w.zoom && w.zoom(this.initialPinchDistance, g, a);
              });
            }
          }
          this.autoPreventDefault && a.preventDefault();
        }, n = (a) => {
          if (this.isTouch = true, this.touch0) {
            var o = a.changedTouches;
            let f = e.getBoundingClientRect();
            for (var c = 0; c < o.length; c++) {
              var d = o[c];
              let m = d.clientX - f.left, u = d.clientY - f.top;
              if (this.touch0.identifier === d.identifier) if (this.touch0 = null, this.mouseX = m, this.mouseY = u, this.listeners.map((g) => {
                g.up && g.up(m, u, a);
              }), this.touch1) this.touch0 = this.touch1, this.touch1 = null, this.mouseX = this.touch0.x, this.mouseX = this.touch0.x, this.buttonDown = true, this.listeners.map((g) => {
                g.down && g.down(this.touch0.x, this.touch0.y, a);
              });
              else {
                this.buttonDown = false;
                break;
              }
              this.touch1 && this.touch1.identifier && (this.touch1 = null);
            }
          }
          this.autoPreventDefault && a.preventDefault();
        };
        return e.addEventListener("mousedown", t, true), e.addEventListener("mousemove", s, true), e.addEventListener("mouseup", i, true), e.addEventListener("wheel", r, true), e.addEventListener("touchstart", h, { passive: false, capture: false }), e.addEventListener("touchmove", l, { passive: false, capture: false }), e.addEventListener("touchend", n, { passive: false, capture: false }), e.addEventListener("touchcancel", n), { mouseDown: t, mouseMove: s, mouseUp: i, mouseWheel: r, touchStart: h, touchMove: l, touchEnd: n };
      }
      dispose() {
        const e = this.element;
        e.removeEventListener("mousedown", this.callbacks.mouseDown, true), e.removeEventListener("mousemove", this.callbacks.mouseMove, true), e.removeEventListener("mouseup", this.callbacks.mouseUp, true), e.removeEventListener("wheel", this.callbacks.mouseWheel, true), e.removeEventListener("touchstart", this.callbacks.touchStart, { capture: false }), e.removeEventListener("touchmove", this.callbacks.touchMove, { capture: false }), e.removeEventListener("touchend", this.callbacks.touchEnd, { capture: false }), e.removeEventListener("touchcancel", this.callbacks.touchEnd), this.listeners.length = 0;
      }
      addListener(e) {
        this.listeners.push(e);
      }
      removeListener(e) {
        let t = this.listeners.indexOf(e);
        t > -1 && this.listeners.splice(t, 1);
      }
    }, yi = class {
      constructor(e, t, s) {
        this.identifier = e, this.x = t, this.y = s;
      }
    }, qr = class {
      constructor(e, t) {
        this.canvas = e, this.camera = t;
        let s = 0, i = 0, h = 0, l = 0, n = 0, a = 0, o = 0;
        new Ys(e).addListener({ down: (c, d) => {
          s = t.position.x, i = t.position.y, h = n = c, l = a = d, o = t.zoom;
        }, dragged: (c, d) => {
          let f = c - h, m = d - l, u = t.screenToWorld(new At(0, 0), e.clientWidth, e.clientHeight), g = t.screenToWorld(new At(f, m), e.clientWidth, e.clientHeight).sub(u);
          t.position.set(s - g.x, i - g.y, 0), t.update(), n = c, a = d;
        }, wheel: (c) => {
          let d = c / 200 * t.zoom, f = t.zoom + d;
          if (f > 0) {
            let m = 0, u = 0;
            if (c < 0) m = n, u = a;
            else {
              let b = new At(e.clientWidth / 2 + 15, e.clientHeight / 2), x = n - b.x, p = e.clientHeight - 1 - a - b.y;
              m = b.x - x, u = e.clientHeight - 1 - b.y + p;
            }
            let g = t.screenToWorld(new At(m, u), e.clientWidth, e.clientHeight);
            t.zoom = f, t.update();
            let w = t.screenToWorld(new At(m, u), e.clientWidth, e.clientHeight);
            t.position.add(g.sub(w)), t.update();
          }
        }, zoom: (c, d) => {
          let f = c / d;
          t.zoom = o * f;
        }, up: (c, d) => {
          n = c, a = d;
        }, moved: (c, d) => {
          n = c, a = d;
        } });
      }
    }, Tt = class dt {
      constructor(t, s, i) {
        this.vertexShader = s, this.fragmentShader = i, this.vsSource = s, this.fsSource = i, this.context = t instanceof xt ? t : new xt(t), this.context.addRestorable(this), this.compile();
      }
      static MVP_MATRIX = "u_projTrans";
      static POSITION = "a_position";
      static COLOR = "a_color";
      static COLOR2 = "a_color2";
      static TEXCOORDS = "a_texCoords";
      static SAMPLER = "u_texture";
      context;
      vs = null;
      vsSource;
      fs = null;
      fsSource;
      program = null;
      tmp2x2 = new Float32Array(2 * 2);
      tmp3x3 = new Float32Array(3 * 3);
      tmp4x4 = new Float32Array(4 * 4);
      getProgram() {
        return this.program;
      }
      getVertexShader() {
        return this.vertexShader;
      }
      getFragmentShader() {
        return this.fragmentShader;
      }
      getVertexShaderSource() {
        return this.vsSource;
      }
      getFragmentSource() {
        return this.fsSource;
      }
      compile() {
        let t = this.context.gl;
        try {
          if (this.vs = this.compileShader(t.VERTEX_SHADER, this.vertexShader), !this.vs) throw new Error("Couldn't compile vertex shader.");
          if (this.fs = this.compileShader(t.FRAGMENT_SHADER, this.fragmentShader), !this.fs) throw new Error("Couldn#t compile fragment shader.");
          this.program = this.compileProgram(this.vs, this.fs);
        } catch (s) {
          throw this.dispose(), s;
        }
      }
      compileShader(t, s) {
        let i = this.context.gl, r = i.createShader(t);
        if (!r) throw new Error("Couldn't create shader.");
        if (i.shaderSource(r, s), i.compileShader(r), !i.getShaderParameter(r, i.COMPILE_STATUS)) {
          let h = "Couldn't compile shader: " + i.getShaderInfoLog(r);
          if (i.deleteShader(r), !i.isContextLost()) throw new Error(h);
        }
        return r;
      }
      compileProgram(t, s) {
        let i = this.context.gl, r = i.createProgram();
        if (!r) throw new Error("Couldn't compile program.");
        if (i.attachShader(r, t), i.attachShader(r, s), i.linkProgram(r), !i.getProgramParameter(r, i.LINK_STATUS)) {
          let h = "Couldn't compile shader program: " + i.getProgramInfoLog(r);
          if (i.deleteProgram(r), !i.isContextLost()) throw new Error(h);
        }
        return r;
      }
      restore() {
        this.compile();
      }
      bind() {
        this.context.gl.useProgram(this.program);
      }
      unbind() {
        this.context.gl.useProgram(null);
      }
      setUniformi(t, s) {
        this.context.gl.uniform1i(this.getUniformLocation(t), s);
      }
      setUniformf(t, s) {
        this.context.gl.uniform1f(this.getUniformLocation(t), s);
      }
      setUniform2f(t, s, i) {
        this.context.gl.uniform2f(this.getUniformLocation(t), s, i);
      }
      setUniform3f(t, s, i, r) {
        this.context.gl.uniform3f(this.getUniformLocation(t), s, i, r);
      }
      setUniform4f(t, s, i, r, h) {
        this.context.gl.uniform4f(this.getUniformLocation(t), s, i, r, h);
      }
      setUniform2x2f(t, s) {
        let i = this.context.gl;
        this.tmp2x2.set(s), i.uniformMatrix2fv(this.getUniformLocation(t), false, this.tmp2x2);
      }
      setUniform3x3f(t, s) {
        let i = this.context.gl;
        this.tmp3x3.set(s), i.uniformMatrix3fv(this.getUniformLocation(t), false, this.tmp3x3);
      }
      setUniform4x4f(t, s) {
        let i = this.context.gl;
        this.tmp4x4.set(s), i.uniformMatrix4fv(this.getUniformLocation(t), false, this.tmp4x4);
      }
      getUniformLocation(t) {
        let s = this.context.gl;
        if (!this.program) throw new Error("Shader not compiled.");
        let i = s.getUniformLocation(this.program, t);
        if (!i && !s.isContextLost()) throw new Error(`Couldn't find location for uniform ${t}`);
        return i;
      }
      getAttributeLocation(t) {
        let s = this.context.gl;
        if (!this.program) throw new Error("Shader not compiled.");
        let i = s.getAttribLocation(this.program, t);
        if (i == -1 && !s.isContextLost()) throw new Error(`Couldn't find location for attribute ${t}`);
        return i;
      }
      dispose() {
        this.context.removeRestorable(this);
        let t = this.context.gl;
        this.vs && (t.deleteShader(this.vs), this.vs = null), this.fs && (t.deleteShader(this.fs), this.fs = null), this.program && (t.deleteProgram(this.program), this.program = null);
      }
      static newColoredTextured(t) {
        let s = `
attribute vec4 ${dt.POSITION};
attribute vec4 ${dt.COLOR};
attribute vec2 ${dt.TEXCOORDS};
uniform mat4 ${dt.MVP_MATRIX};
varying vec4 v_color;
varying vec2 v_texCoords;

void main () {
	v_color = ${dt.COLOR};
	v_texCoords = ${dt.TEXCOORDS};
	gl_Position = ${dt.MVP_MATRIX} * ${dt.POSITION};
}
`, i = `
#ifdef GL_ES
	#define LOWP lowp
	precision mediump float;
#else
	#define LOWP
#endif
varying LOWP vec4 v_color;
varying vec2 v_texCoords;
uniform sampler2D u_texture;

void main () {
	gl_FragColor = v_color * texture2D(u_texture, v_texCoords);
}
`;
        return new dt(t, s, i);
      }
      static newTwoColoredTextured(t) {
        let s = `
attribute vec4 ${dt.POSITION};
attribute vec4 ${dt.COLOR};
attribute vec4 ${dt.COLOR2};
attribute vec2 ${dt.TEXCOORDS};
uniform mat4 ${dt.MVP_MATRIX};
varying vec4 v_light;
varying vec4 v_dark;
varying vec2 v_texCoords;

void main () {
	v_light = ${dt.COLOR};
	v_dark = ${dt.COLOR2};
	v_texCoords = ${dt.TEXCOORDS};
	gl_Position = ${dt.MVP_MATRIX} * ${dt.POSITION};
}
`, i = `
#ifdef GL_ES
	#define LOWP lowp
	precision mediump float;
#else
	#define LOWP
#endif
varying LOWP vec4 v_light;
varying LOWP vec4 v_dark;
varying vec2 v_texCoords;
uniform sampler2D u_texture;

void main () {
	vec4 texColor = texture2D(u_texture, v_texCoords);
	gl_FragColor.a = texColor.a * v_light.a;
	gl_FragColor.rgb = ((texColor.a - 1.0) * v_dark.a + 1.0 - texColor.rgb) * v_dark.rgb + texColor.rgb * v_light.rgb;
}
`;
        return new dt(t, s, i);
      }
      static newColored(t) {
        let s = `
attribute vec4 ${dt.POSITION};
attribute vec4 ${dt.COLOR};
uniform mat4 ${dt.MVP_MATRIX};
varying vec4 v_color;

void main () {
	v_color = ${dt.COLOR};
	gl_Position = ${dt.MVP_MATRIX} * ${dt.POSITION};
}
`, i = `
#ifdef GL_ES
	#define LOWP lowp
	precision mediump float;
#else
	#define LOWP
#endif
varying LOWP vec4 v_color;

void main () {
	gl_FragColor = v_color;
}
`;
        return new dt(t, s, i);
      }
    }, ks = class {
      constructor(e, t, s, i) {
        this.attributes = t, this.context = e instanceof xt ? e : new xt(e), this.elementsPerVertex = 0;
        for (let r = 0; r < t.length; r++) this.elementsPerVertex += t[r].numElements;
        this.vertices = new Float32Array(s * this.elementsPerVertex), this.indices = new Uint16Array(i), this.context.addRestorable(this);
      }
      context;
      vertices;
      verticesBuffer = null;
      verticesLength = 0;
      dirtyVertices = false;
      indices;
      indicesBuffer = null;
      indicesLength = 0;
      dirtyIndices = false;
      elementsPerVertex = 0;
      getAttributes() {
        return this.attributes;
      }
      maxVertices() {
        return this.vertices.length / this.elementsPerVertex;
      }
      numVertices() {
        return this.verticesLength / this.elementsPerVertex;
      }
      setVerticesLength(e) {
        this.dirtyVertices = true, this.verticesLength = e;
      }
      getVertices() {
        return this.vertices;
      }
      maxIndices() {
        return this.indices.length;
      }
      numIndices() {
        return this.indicesLength;
      }
      setIndicesLength(e) {
        this.dirtyIndices = true, this.indicesLength = e;
      }
      getIndices() {
        return this.indices;
      }
      getVertexSizeInFloats() {
        let e = 0;
        for (var t = 0; t < this.attributes.length; t++) {
          let s = this.attributes[t];
          e += s.numElements;
        }
        return e;
      }
      setVertices(e) {
        if (this.dirtyVertices = true, e.length > this.vertices.length) throw Error("Mesh can't store more than " + this.maxVertices() + " vertices");
        this.vertices.set(e, 0), this.verticesLength = e.length;
      }
      setIndices(e) {
        if (this.dirtyIndices = true, e.length > this.indices.length) throw Error("Mesh can't store more than " + this.maxIndices() + " indices");
        this.indices.set(e, 0), this.indicesLength = e.length;
      }
      draw(e, t) {
        this.drawWithOffset(e, t, 0, this.indicesLength > 0 ? this.indicesLength : this.verticesLength / this.elementsPerVertex);
      }
      drawWithOffset(e, t, s, i) {
        let r = this.context.gl;
        (this.dirtyVertices || this.dirtyIndices) && this.update(), this.bind(e), this.indicesLength > 0 ? r.drawElements(t, i, r.UNSIGNED_SHORT, s * 2) : r.drawArrays(t, s, i), this.unbind(e);
      }
      bind(e) {
        let t = this.context.gl;
        t.bindBuffer(t.ARRAY_BUFFER, this.verticesBuffer);
        let s = 0;
        for (let i = 0; i < this.attributes.length; i++) {
          let r = this.attributes[i], h = e.getAttributeLocation(r.name);
          t.enableVertexAttribArray(h), t.vertexAttribPointer(h, r.numElements, t.FLOAT, false, this.elementsPerVertex * 4, s * 4), s += r.numElements;
        }
        this.indicesLength > 0 && t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);
      }
      unbind(e) {
        let t = this.context.gl;
        for (let s = 0; s < this.attributes.length; s++) {
          let i = this.attributes[s], r = e.getAttributeLocation(i.name);
          t.disableVertexAttribArray(r);
        }
        t.bindBuffer(t.ARRAY_BUFFER, null), this.indicesLength > 0 && t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, null);
      }
      update() {
        let e = this.context.gl;
        this.dirtyVertices && (this.verticesBuffer || (this.verticesBuffer = e.createBuffer()), e.bindBuffer(e.ARRAY_BUFFER, this.verticesBuffer), e.bufferData(e.ARRAY_BUFFER, this.vertices.subarray(0, this.verticesLength), e.DYNAMIC_DRAW), this.dirtyVertices = false), this.dirtyIndices && (this.indicesBuffer || (this.indicesBuffer = e.createBuffer()), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.indicesBuffer), e.bufferData(e.ELEMENT_ARRAY_BUFFER, this.indices.subarray(0, this.indicesLength), e.DYNAMIC_DRAW), this.dirtyIndices = false);
      }
      restore() {
        this.verticesBuffer = null, this.indicesBuffer = null, this.update();
      }
      dispose() {
        this.context.removeRestorable(this);
        let e = this.context.gl;
        e.deleteBuffer(this.verticesBuffer), e.deleteBuffer(this.indicesBuffer);
      }
    }, Ht = class {
      constructor(e, t, s) {
        this.name = e, this.type = t, this.numElements = s;
      }
    }, ue = class extends Ht {
      constructor() {
        super(Tt.POSITION, 0, 2);
      }
    }, Gr = class extends Ht {
      constructor() {
        super(Tt.POSITION, 0, 3);
      }
    }, Fs = class extends Ht {
      constructor(e = 0) {
        super(Tt.TEXCOORDS + (e == 0 ? "" : e), 0, 2);
      }
    }, me = class extends Ht {
      constructor() {
        super(Tt.COLOR, 0, 4);
      }
    }, Ai = class extends Ht {
      constructor() {
        super(Tt.COLOR2, 0, 4);
      }
    }, Ci = ((e) => (e[e.Float = 0] = "Float", e))(Ci || {}), Xt = 1, Hr = 769, Si = 770, Ti = 771, Ii = 774, Xs = class Ut {
      static disableCulling = false;
      context;
      drawCalls = 0;
      static globalDrawCalls = 0;
      isDrawing = false;
      mesh;
      shader = null;
      lastTexture = null;
      verticesLength = 0;
      indicesLength = 0;
      srcColorBlend;
      srcAlphaBlend;
      dstBlend;
      cullWasEnabled = false;
      constructor(t, s = true, i = 10920) {
        if (i > 10920) throw new Error("Can't have more than 10920 triangles per batch: " + i);
        this.context = t instanceof xt ? t : new xt(t);
        let r = s ? [new ue(), new me(), new Fs(), new Ai()] : [new ue(), new me(), new Fs()];
        this.mesh = new ks(t, r, i, i * 3);
        let h = this.context.gl;
        this.srcColorBlend = h.SRC_ALPHA, this.srcAlphaBlend = h.ONE, this.dstBlend = h.ONE_MINUS_SRC_ALPHA;
      }
      begin(t) {
        if (this.isDrawing) throw new Error("PolygonBatch is already drawing. Call PolygonBatch.end() before calling PolygonBatch.begin()");
        this.drawCalls = 0, this.shader = t, this.lastTexture = null, this.isDrawing = true;
        let s = this.context.gl;
        s.enable(s.BLEND), s.blendFuncSeparate(this.srcColorBlend, this.dstBlend, this.srcAlphaBlend, this.dstBlend);
      }
      static blendModesGL = [{ srcRgb: Si, srcRgbPma: Xt, dstRgb: Ti, srcAlpha: Xt }, { srcRgb: Si, srcRgbPma: Xt, dstRgb: Xt, srcAlpha: Xt }, { srcRgb: Ii, srcRgbPma: Ii, dstRgb: Ti, srcAlpha: Xt }, { srcRgb: Xt, srcRgbPma: Xt, dstRgb: Hr, srcAlpha: Xt }];
      setBlendMode(t, s) {
        const i = Ut.blendModesGL[t], r = s ? i.srcRgbPma : i.srcRgb, h = i.srcAlpha, l = i.dstRgb;
        if (this.srcColorBlend == r && this.srcAlphaBlend == h && this.dstBlend == l) return;
        this.srcColorBlend = r, this.srcAlphaBlend = h, this.dstBlend = l, this.isDrawing && this.flush(), this.context.gl.blendFuncSeparate(r, l, h, l);
      }
      draw(t, s, i) {
        t != this.lastTexture ? (this.flush(), this.lastTexture = t) : (this.verticesLength + s.length > this.mesh.getVertices().length || this.indicesLength + i.length > this.mesh.getIndices().length) && this.flush();
        let r = this.mesh.numVertices();
        this.mesh.getVertices().set(s, this.verticesLength), this.verticesLength += s.length, this.mesh.setVerticesLength(this.verticesLength);
        let h = this.mesh.getIndices();
        for (let l = this.indicesLength, n = 0; n < i.length; l++, n++) h[l] = i[n] + r;
        this.indicesLength += i.length, this.mesh.setIndicesLength(this.indicesLength);
      }
      flush() {
        if (this.verticesLength != 0) {
          if (!this.lastTexture) throw new Error("No texture set.");
          if (!this.shader) throw new Error("No shader set.");
          this.lastTexture.bind(), this.mesh.draw(this.shader, this.context.gl.TRIANGLES), this.verticesLength = 0, this.indicesLength = 0, this.mesh.setVerticesLength(0), this.mesh.setIndicesLength(0), this.drawCalls++, Ut.globalDrawCalls++;
        }
      }
      end() {
        if (!this.isDrawing) throw new Error("PolygonBatch is not drawing. Call PolygonBatch.begin() before calling PolygonBatch.end()");
        (this.verticesLength > 0 || this.indicesLength > 0) && this.flush(), this.shader = null, this.lastTexture = null, this.isDrawing = false;
        let t = this.context.gl;
        t.disable(t.BLEND);
      }
      getDrawCalls() {
        return this.drawCalls;
      }
      static getAndResetGlobalDrawCalls() {
        let t = Ut.globalDrawCalls;
        return Ut.globalDrawCalls = 0, t;
      }
      dispose() {
        this.mesh.dispose();
      }
    }, Ps = class {
      context;
      isDrawing = false;
      mesh;
      shapeType = 4;
      color = new tt(1, 1, 1, 1);
      shader = null;
      vertexIndex = 0;
      tmp = new Vt();
      srcColorBlend;
      srcAlphaBlend;
      dstBlend;
      constructor(e, t = 10920) {
        if (t > 10920) throw new Error("Can't have more than 10920 triangles per batch: " + t);
        this.context = e instanceof xt ? e : new xt(e), this.mesh = new ks(e, [new ue(), new me()], t, 0);
        let s = this.context.gl;
        this.srcColorBlend = s.SRC_ALPHA, this.srcAlphaBlend = s.ONE, this.dstBlend = s.ONE_MINUS_SRC_ALPHA;
      }
      begin(e) {
        if (this.isDrawing) throw new Error("ShapeRenderer.begin() has already been called");
        this.shader = e, this.vertexIndex = 0, this.isDrawing = true;
        let t = this.context.gl;
        t.enable(t.BLEND), t.blendFuncSeparate(this.srcColorBlend, this.dstBlend, this.srcAlphaBlend, this.dstBlend);
      }
      setBlendMode(e, t, s) {
        this.srcColorBlend = e, this.srcAlphaBlend = t, this.dstBlend = s, this.isDrawing && (this.flush(), this.context.gl.blendFuncSeparate(e, s, t, s));
      }
      setColor(e) {
        this.color.setFromColor(e);
      }
      setColorWith(e, t, s, i) {
        this.color.set(e, t, s, i);
      }
      point(e, t, s) {
        this.check(0, 1), s || (s = this.color), this.vertex(e, t, s);
      }
      line(e, t, s, i, r) {
        this.check(1, 2);
        this.mesh.getVertices(); this.vertexIndex;
        r || (r = this.color), this.vertex(e, t, r), this.vertex(s, i, r);
      }
      triangle(e, t, s, i, r, h, l, n, a, o) {
        this.check(e ? 4 : 1, 3);
        this.mesh.getVertices(); this.vertexIndex;
        n || (n = this.color), a || (a = this.color), o || (o = this.color), e ? (this.vertex(t, s, n), this.vertex(i, r, a), this.vertex(h, l, o)) : (this.vertex(t, s, n), this.vertex(i, r, a), this.vertex(i, r, n), this.vertex(h, l, a), this.vertex(h, l, n), this.vertex(t, s, a));
      }
      quad(e, t, s, i, r, h, l, n, a, o, c, d, f) {
        this.check(e ? 4 : 1, 3);
        this.mesh.getVertices(); this.vertexIndex;
        o || (o = this.color), c || (c = this.color), d || (d = this.color), f || (f = this.color), e ? (this.vertex(t, s, o), this.vertex(i, r, c), this.vertex(h, l, d), this.vertex(h, l, d), this.vertex(n, a, f), this.vertex(t, s, o)) : (this.vertex(t, s, o), this.vertex(i, r, c), this.vertex(i, r, c), this.vertex(h, l, d), this.vertex(h, l, d), this.vertex(n, a, f), this.vertex(n, a, f), this.vertex(t, s, o));
      }
      rect(e, t, s, i, r, h) {
        this.quad(e, t, s, t + i, s, t + i, s + r, t, s + r, h, h, h, h);
      }
      rectLine(e, t, s, i, r, h, l) {
        this.check(e ? 4 : 1, 8), l || (l = this.color);
        let n = this.tmp.set(r - s, t - i);
        n.normalize(), h *= 0.5;
        let a = n.x * h, o = n.y * h;
        e ? (this.vertex(t + a, s + o, l), this.vertex(t - a, s - o, l), this.vertex(i + a, r + o, l), this.vertex(i - a, r - o, l), this.vertex(i + a, r + o, l), this.vertex(t - a, s - o, l)) : (this.vertex(t + a, s + o, l), this.vertex(t - a, s - o, l), this.vertex(i + a, r + o, l), this.vertex(i - a, r - o, l), this.vertex(i + a, r + o, l), this.vertex(t + a, s + o, l), this.vertex(i - a, r - o, l), this.vertex(t - a, s - o, l));
      }
      x(e, t, s) {
        this.line(e - s, t - s, e + s, t + s), this.line(e - s, t + s, e + s, t - s);
      }
      polygon(e, t, s, i) {
        if (s < 3) throw new Error("Polygon must contain at least 3 vertices");
        this.check(1, s * 2), i || (i = this.color);
        this.mesh.getVertices(); this.vertexIndex;
        t <<= 1, s <<= 1;
        let l = e[t], n = e[t + 1], a = t + s;
        for (let o = t, c = t + s - 2; o < c; o += 2) {
          let d = e[o], f = e[o + 1], m = 0, u = 0;
          o + 2 >= a ? (m = l, u = n) : (m = e[o + 2], u = e[o + 3]), this.vertex(d, f, i), this.vertex(m, u, i);
        }
      }
      circle(e, t, s, i, r, h = 0) {
        if (h == 0 && (h = Math.max(1, 6 * P.cbrt(i) | 0)), h <= 0) throw new Error("segments must be > 0.");
        r || (r = this.color);
        let l = 2 * P.PI / h, n = Math.cos(l), a = Math.sin(l), o = i, c = 0;
        if (e) {
          this.check(4, h * 3 + 3), h--;
          for (let f = 0; f < h; f++) {
            this.vertex(t, s, r), this.vertex(t + o, s + c, r);
            let m = o;
            o = n * o - a * c, c = a * m + n * c, this.vertex(t + o, s + c, r);
          }
          this.vertex(t, s, r), this.vertex(t + o, s + c, r);
        } else {
          this.check(1, h * 2 + 2);
          for (let f = 0; f < h; f++) {
            this.vertex(t + o, s + c, r);
            let m = o;
            o = n * o - a * c, c = a * m + n * c, this.vertex(t + o, s + c, r);
          }
          this.vertex(t + o, s + c, r);
        }
        o = i, c = 0, this.vertex(t + o, s + c, r);
      }
      curve(e, t, s, i, r, h, l, n, a, o) {
        this.check(1, a * 2 + 2), o || (o = this.color);
        let c = 1 / a, d = c * c, f = c * c * c, m = 3 * c, u = 3 * d, g = 6 * d, w = 6 * f, b = e - s * 2 + r, x = t - i * 2 + h, p = (s - r) * 3 - e + l, v = (i - h) * 3 - t + n, y = e, A = t, C = (s - e) * m + b * u + p * f, S = (i - t) * m + x * u + v * f, I = b * g + p * w, Y = x * g + v * w, k = p * w, F = v * w;
        for (; a-- > 0; ) this.vertex(y, A, o), y += C, A += S, C += I, S += Y, I += k, Y += F, this.vertex(y, A, o);
        this.vertex(y, A, o), this.vertex(l, n, o);
      }
      vertex(e, t, s) {
        let i = this.vertexIndex, r = this.mesh.getVertices();
        r[i++] = e, r[i++] = t, r[i++] = s.r, r[i++] = s.g, r[i++] = s.b, r[i++] = s.a, this.vertexIndex = i;
      }
      end() {
        if (!this.isDrawing) throw new Error("ShapeRenderer.begin() has not been called");
        this.flush();
        let e = this.context.gl;
        e.disable(e.BLEND), this.isDrawing = false;
      }
      flush() {
        if (this.vertexIndex != 0) {
          if (!this.shader) throw new Error("No shader set.");
          this.mesh.setVerticesLength(this.vertexIndex), this.mesh.draw(this.shader, this.shapeType), this.vertexIndex = 0;
        }
      }
      check(e, t) {
        if (!this.isDrawing) throw new Error("ShapeRenderer.begin() has not been called");
        if (this.shapeType == e) if (this.mesh.maxVertices() - this.mesh.numVertices() < t) this.flush();
        else return;
        else this.flush(), this.shapeType = e;
      }
      dispose() {
        this.mesh.dispose();
      }
    }, Mi = ((e) => (e[e.Point = 0] = "Point", e[e.Line = 1] = "Line", e[e.Filled = 4] = "Filled", e))(Mi || {}), Ei = class zs {
      boneLineColor = new tt(1, 0, 0, 1);
      boneOriginColor = new tt(0, 1, 0, 1);
      attachmentLineColor = new tt(0, 0, 1, 0.5);
      triangleLineColor = new tt(1, 0.64, 0, 0.5);
      pathColor = new tt().setFromString("FF7F00");
      clipColor = new tt(0.8, 0, 0, 2);
      aabbColor = new tt(0, 1, 0, 0.5);
      drawBones = true;
      drawRegionAttachments = true;
      drawBoundingBoxes = true;
      drawMeshHull = true;
      drawMeshTriangles = true;
      drawPaths = true;
      drawSkeletonXY = false;
      drawClipping = true;
      premultipliedAlpha = false;
      scale = 1;
      boneWidth = 2;
      context;
      bounds = new xi();
      temp = new Array();
      vertices = L.newFloatArray(2 * 1024);
      static LIGHT_GRAY = new tt(192 / 255, 192 / 255, 192 / 255, 1);
      static GREEN = new tt(0, 1, 0, 1);
      constructor(t) {
        this.context = t instanceof xt ? t : new xt(t);
      }
      draw(t, s, i) {
        let r = s.x, h = s.y, l = this.context.gl, n = this.premultipliedAlpha ? l.ONE : l.SRC_ALPHA;
        t.setBlendMode(n, l.ONE, l.ONE_MINUS_SRC_ALPHA);
        let a = s.bones;
        if (this.drawBones) {
          t.setColor(this.boneLineColor);
          for (let o = 0, c = a.length; o < c; o++) {
            let d = a[o];
            if (i && i.indexOf(d.data.name) > -1 || !d.parent) continue;
            let f = d.data.length * d.a + d.worldX, m = d.data.length * d.c + d.worldY;
            t.rectLine(true, d.worldX, d.worldY, f, m, this.boneWidth * this.scale);
          }
          this.drawSkeletonXY && t.x(r, h, 4 * this.scale);
        }
        if (this.drawRegionAttachments) {
          t.setColor(this.attachmentLineColor);
          let o = s.slots;
          for (let c = 0, d = o.length; c < d; c++) {
            let f = o[c], m = f.getAttachment();
            if (m instanceof te) {
              let u = m, g = this.vertices;
              u.computeWorldVertices(f, g, 0, 2), t.line(g[0], g[1], g[2], g[3]), t.line(g[2], g[3], g[4], g[5]), t.line(g[4], g[5], g[6], g[7]), t.line(g[6], g[7], g[0], g[1]);
            }
          }
        }
        if (this.drawMeshHull || this.drawMeshTriangles) {
          let o = s.slots;
          for (let c = 0, d = o.length; c < d; c++) {
            let f = o[c];
            if (!f.bone.active) continue;
            let m = f.getAttachment();
            if (!(m instanceof Wt)) continue;
            let u = m, g = this.vertices;
            u.computeWorldVertices(f, 0, u.worldVerticesLength, g, 0, 2);
            let w = u.triangles, b = u.hullLength;
            if (this.drawMeshTriangles) {
              t.setColor(this.triangleLineColor);
              for (let x = 0, p = w.length; x < p; x += 3) {
                let v = w[x] * 2, y = w[x + 1] * 2, A = w[x + 2] * 2;
                t.triangle(false, g[v], g[v + 1], g[y], g[y + 1], g[A], g[A + 1]);
              }
            }
            if (this.drawMeshHull && b > 0) {
              t.setColor(this.attachmentLineColor), b = (b >> 1) * 2;
              let x = g[b - 2], p = g[b - 1];
              for (let v = 0, y = b; v < y; v += 2) {
                let A = g[v], C = g[v + 1];
                t.line(A, C, x, p), x = A, p = C;
              }
            }
          }
        }
        if (this.drawBoundingBoxes) {
          let o = this.bounds;
          o.update(s, true), t.setColor(this.aabbColor), t.rect(false, o.minX, o.minY, o.getWidth(), o.getHeight());
          let c = o.polygons, d = o.boundingBoxes;
          for (let f = 0, m = c.length; f < m; f++) {
            let u = c[f];
            t.setColor(d[f].color), t.polygon(u, 0, u.length);
          }
        }
        if (this.drawPaths) {
          let o = s.slots;
          for (let c = 0, d = o.length; c < d; c++) {
            let f = o[c];
            if (!f.bone.active) continue;
            let m = f.getAttachment();
            if (!(m instanceof qt)) continue;
            let u = m, g = u.worldVerticesLength, w = this.temp = L.setArraySize(this.temp, g, 0);
            u.computeWorldVertices(f, 0, g, w, 0, 2);
            let b = this.pathColor, x = w[2], p = w[3], v = 0, y = 0;
            if (u.closed) {
              t.setColor(b);
              let A = w[0], C = w[1], S = w[g - 2], I = w[g - 1];
              v = w[g - 4], y = w[g - 3], t.curve(x, p, A, C, S, I, v, y, 32), t.setColor(zs.LIGHT_GRAY), t.line(x, p, A, C), t.line(v, y, S, I);
            }
            g -= 4;
            for (let A = 4; A < g; A += 6) {
              let C = w[A], S = w[A + 1], I = w[A + 2], Y = w[A + 3];
              v = w[A + 4], y = w[A + 5], t.setColor(b), t.curve(x, p, C, S, I, Y, v, y, 32), t.setColor(zs.LIGHT_GRAY), t.line(x, p, C, S), t.line(v, y, I, Y), x = v, p = y;
            }
          }
        }
        if (this.drawBones) {
          t.setColor(this.boneOriginColor);
          for (let o = 0, c = a.length; o < c; o++) {
            let d = a[o];
            i && i.indexOf(d.data.name) > -1 || t.circle(true, d.worldX, d.worldY, 3 * this.scale, this.boneOriginColor, 8);
          }
        }
        if (this.drawClipping) {
          let o = s.slots;
          t.setColor(this.clipColor);
          for (let c = 0, d = o.length; c < d; c++) {
            let f = o[c];
            if (!f.bone.active) continue;
            let m = f.getAttachment();
            if (!(m instanceof $t)) continue;
            let u = m, g = u.worldVerticesLength, w = this.temp = L.setArraySize(this.temp, g, 0);
            u.computeWorldVertices(f, 0, g, w, 0, 2);
            for (let b = 0, x = w.length; b < x; b += 2) {
              let p = w[b], v = w[b + 1], y = w[(b + 2) % w.length], A = w[(b + 3) % w.length];
              t.line(p, v, y, A);
            }
          }
        }
      }
      dispose() {
      }
    }, _r = class {
      constructor(e, t, s) {
        this.vertices = e, this.numVertices = t, this.numFloats = s;
      }
    }, Ri = class Gi {
      static QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0];
      premultipliedAlpha = false;
      tempColor = new tt();
      tempColor2 = new tt();
      vertices;
      vertexSize = 8;
      twoColorTint = false;
      renderable = new _r([], 0, 0);
      clipper = new wi();
      temp = new Vt();
      temp2 = new Vt();
      temp3 = new tt();
      temp4 = new tt();
      constructor(t, s = true) {
        this.twoColorTint = s, s && (this.vertexSize += 4), this.vertices = L.newFloatArray(this.vertexSize * 1024);
      }
      draw(t, s, i = -1, r = -1, h = null) {
        let l = this.clipper, n = this.premultipliedAlpha, a = this.twoColorTint, o = null, c = this.renderable, d, f, m = s.drawOrder, u, g = s.color, w = a ? 12 : 8, b = false;
        i == -1 && (b = true);
        for (let x = 0, p = m.length; x < p; x++) {
          let v = l.isClipping() ? 2 : w, y = m[x];
          if (!y.bone.active) {
            l.clipEndWithSlot(y);
            continue;
          }
          if (i >= 0 && i == y.data.index && (b = true), !b) {
            l.clipEndWithSlot(y);
            continue;
          }
          r >= 0 && r == y.data.index && (b = false);
          let A = y.getAttachment(), C;
          if (A instanceof te) {
            let S = A;
            c.vertices = this.vertices, c.numVertices = 4, c.numFloats = v << 2, S.computeWorldVertices(y, c.vertices, 0, v), f = Gi.QUAD_TRIANGLES, d = S.uvs, C = S.region.texture, u = S.color;
          } else if (A instanceof Wt) {
            let S = A;
            c.vertices = this.vertices, c.numVertices = S.worldVerticesLength >> 1, c.numFloats = c.numVertices * v, c.numFloats > c.vertices.length && (c.vertices = this.vertices = L.newFloatArray(c.numFloats)), S.computeWorldVertices(y, 0, S.worldVerticesLength, c.vertices, 0, v), f = S.triangles, C = S.region.texture, d = S.uvs, u = S.color;
          } else if (A instanceof $t) {
            let S = A;
            l.clipStart(y, S);
            continue;
          } else {
            l.clipEndWithSlot(y);
            continue;
          }
          if (C) {
            let S = y.color, I = this.tempColor;
            I.r = g.r * S.r * u.r, I.g = g.g * S.g * u.g, I.b = g.b * S.b * u.b, I.a = g.a * S.a * u.a, n && (I.r *= I.a, I.g *= I.a, I.b *= I.a);
            let Y = this.tempColor2;
            y.darkColor ? (n ? (Y.r = y.darkColor.r * I.a, Y.g = y.darkColor.g * I.a, Y.b = y.darkColor.b * I.a) : Y.setFromColor(y.darkColor), Y.a = n ? 1 : 0) : Y.set(0, 0, 0, 1);
            let k = y.data.blendMode;
            if (k != o && (o = k, t.setBlendMode(o, n)), l.isClipping()) {
              l.clipTriangles(c.vertices, f, f.length, d, I, Y, a);
              let F = new Float32Array(l.clippedVertices), X = l.clippedTriangles;
              h && h(F, F.length, w), t.draw(C, F, X);
            } else {
              let F = c.vertices;
              if (a) for (let E = 2, R = 0, B = c.numFloats; E < B; E += w, R += 2) F[E] = I.r, F[E + 1] = I.g, F[E + 2] = I.b, F[E + 3] = I.a, F[E + 4] = d[R], F[E + 5] = d[R + 1], F[E + 6] = Y.r, F[E + 7] = Y.g, F[E + 8] = Y.b, F[E + 9] = Y.a;
              else for (let E = 2, R = 0, B = c.numFloats; E < B; E += w, R += 2) F[E] = I.r, F[E + 1] = I.g, F[E + 2] = I.b, F[E + 3] = I.a, F[E + 4] = d[R], F[E + 5] = d[R + 1];
              let X = c.vertices.subarray(0, c.numFloats);
              h && h(c.vertices, c.numFloats, w), t.draw(C, X, f);
            }
          }
          l.clipEndWithSlot(y);
        }
        l.clipEnd();
      }
      getSkeletonClipping() {
        return this.clipper;
      }
    }, T = [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0], ge = [0, 1, 2, 2, 3, 0], xe = new tt(1, 1, 1, 1), Yi = class {
      context;
      canvas;
      camera;
      batcher;
      twoColorTint = false;
      batcherShader;
      shapes;
      shapesShader;
      activeRenderer = null;
      skeletonRenderer;
      skeletonDebugRenderer;
      constructor(e, t, s = true) {
        this.canvas = e, this.context = t instanceof xt ? t : new xt(t), this.twoColorTint = s, this.camera = new vi(e.width, e.height), this.batcherShader = s ? Tt.newTwoColoredTextured(this.context) : Tt.newColoredTextured(this.context), this.batcher = new Xs(this.context, s), this.shapesShader = Tt.newColored(this.context), this.shapes = new Ps(this.context), this.skeletonRenderer = new Ri(this.context, s), this.skeletonDebugRenderer = new Ei(this.context);
      }
      dispose() {
        this.batcher.dispose(), this.batcherShader.dispose(), this.shapes.dispose(), this.shapesShader.dispose(), this.skeletonDebugRenderer.dispose();
      }
      begin() {
        this.camera.update(), this.enableRenderer(this.batcher);
      }
      drawSkeleton(e, t = false, s = -1, i = -1, r = null) {
        this.enableRenderer(this.batcher), this.skeletonRenderer.premultipliedAlpha = t, this.skeletonRenderer.draw(this.batcher, e, s, i, r);
      }
      drawSkeletonDebug(e, t = false, s) {
        this.enableRenderer(this.shapes), this.skeletonDebugRenderer.premultipliedAlpha = t, this.skeletonDebugRenderer.draw(this.shapes, e, s);
      }
      drawTexture(e, t, s, i, r, h) {
        this.enableRenderer(this.batcher), h || (h = xe);
        var l = 0;
        T[l++] = t, T[l++] = s, T[l++] = h.r, T[l++] = h.g, T[l++] = h.b, T[l++] = h.a, T[l++] = 0, T[l++] = 1, this.twoColorTint && (T[l++] = 0, T[l++] = 0, T[l++] = 0, T[l++] = 0), T[l++] = t + i, T[l++] = s, T[l++] = h.r, T[l++] = h.g, T[l++] = h.b, T[l++] = h.a, T[l++] = 1, T[l++] = 1, this.twoColorTint && (T[l++] = 0, T[l++] = 0, T[l++] = 0, T[l++] = 0), T[l++] = t + i, T[l++] = s + r, T[l++] = h.r, T[l++] = h.g, T[l++] = h.b, T[l++] = h.a, T[l++] = 1, T[l++] = 0, this.twoColorTint && (T[l++] = 0, T[l++] = 0, T[l++] = 0, T[l++] = 0), T[l++] = t, T[l++] = s + r, T[l++] = h.r, T[l++] = h.g, T[l++] = h.b, T[l++] = h.a, T[l++] = 0, T[l++] = 0, this.twoColorTint && (T[l++] = 0, T[l++] = 0, T[l++] = 0, T[l] = 0), this.batcher.draw(e, T, ge);
      }
      drawTextureUV(e, t, s, i, r, h, l, n, a, o) {
        this.enableRenderer(this.batcher), o || (o = xe);
        var c = 0;
        T[c++] = t, T[c++] = s, T[c++] = o.r, T[c++] = o.g, T[c++] = o.b, T[c++] = o.a, T[c++] = h, T[c++] = l, this.twoColorTint && (T[c++] = 0, T[c++] = 0, T[c++] = 0, T[c++] = 0), T[c++] = t + i, T[c++] = s, T[c++] = o.r, T[c++] = o.g, T[c++] = o.b, T[c++] = o.a, T[c++] = n, T[c++] = l, this.twoColorTint && (T[c++] = 0, T[c++] = 0, T[c++] = 0, T[c++] = 0), T[c++] = t + i, T[c++] = s + r, T[c++] = o.r, T[c++] = o.g, T[c++] = o.b, T[c++] = o.a, T[c++] = n, T[c++] = a, this.twoColorTint && (T[c++] = 0, T[c++] = 0, T[c++] = 0, T[c++] = 0), T[c++] = t, T[c++] = s + r, T[c++] = o.r, T[c++] = o.g, T[c++] = o.b, T[c++] = o.a, T[c++] = h, T[c++] = a, this.twoColorTint && (T[c++] = 0, T[c++] = 0, T[c++] = 0, T[c] = 0), this.batcher.draw(e, T, ge);
      }
      drawTextureRotated(e, t, s, i, r, h, l, n, a) {
        this.enableRenderer(this.batcher), a || (a = xe);
        let o = t + h, c = s + l, d = -h, f = -l, m = i - h, u = r - l, g = d, w = f, b = d, x = u, p = m, v = u, y = m, A = f, C = 0, S = 0, I = 0, Y = 0, k = 0, F = 0, X = 0, E = 0;
        if (n != 0) {
          let B = P.cosDeg(n), st = P.sinDeg(n);
          C = B * g - st * w, S = st * g + B * w, X = B * b - st * x, E = st * b + B * x, k = B * p - st * v, F = st * p + B * v, I = k + (C - X), Y = F + (S - E);
        } else C = g, S = w, X = b, E = x, k = p, F = v, I = y, Y = A;
        C += o, S += c, I += o, Y += c, k += o, F += c, X += o, E += c;
        var R = 0;
        T[R++] = C, T[R++] = S, T[R++] = a.r, T[R++] = a.g, T[R++] = a.b, T[R++] = a.a, T[R++] = 0, T[R++] = 1, this.twoColorTint && (T[R++] = 0, T[R++] = 0, T[R++] = 0, T[R++] = 0), T[R++] = I, T[R++] = Y, T[R++] = a.r, T[R++] = a.g, T[R++] = a.b, T[R++] = a.a, T[R++] = 1, T[R++] = 1, this.twoColorTint && (T[R++] = 0, T[R++] = 0, T[R++] = 0, T[R++] = 0), T[R++] = k, T[R++] = F, T[R++] = a.r, T[R++] = a.g, T[R++] = a.b, T[R++] = a.a, T[R++] = 1, T[R++] = 0, this.twoColorTint && (T[R++] = 0, T[R++] = 0, T[R++] = 0, T[R++] = 0), T[R++] = X, T[R++] = E, T[R++] = a.r, T[R++] = a.g, T[R++] = a.b, T[R++] = a.a, T[R++] = 0, T[R++] = 0, this.twoColorTint && (T[R++] = 0, T[R++] = 0, T[R++] = 0, T[R] = 0), this.batcher.draw(e, T, ge);
      }
      drawRegion(e, t, s, i, r, h) {
        this.enableRenderer(this.batcher), h || (h = xe);
        var l = 0;
        T[l++] = t, T[l++] = s, T[l++] = h.r, T[l++] = h.g, T[l++] = h.b, T[l++] = h.a, T[l++] = e.u, T[l++] = e.v2, this.twoColorTint && (T[l++] = 0, T[l++] = 0, T[l++] = 0, T[l++] = 0), T[l++] = t + i, T[l++] = s, T[l++] = h.r, T[l++] = h.g, T[l++] = h.b, T[l++] = h.a, T[l++] = e.u2, T[l++] = e.v2, this.twoColorTint && (T[l++] = 0, T[l++] = 0, T[l++] = 0, T[l++] = 0), T[l++] = t + i, T[l++] = s + r, T[l++] = h.r, T[l++] = h.g, T[l++] = h.b, T[l++] = h.a, T[l++] = e.u2, T[l++] = e.v, this.twoColorTint && (T[l++] = 0, T[l++] = 0, T[l++] = 0, T[l++] = 0), T[l++] = t, T[l++] = s + r, T[l++] = h.r, T[l++] = h.g, T[l++] = h.b, T[l++] = h.a, T[l++] = e.u, T[l++] = e.v, this.twoColorTint && (T[l++] = 0, T[l++] = 0, T[l++] = 0, T[l] = 0), this.batcher.draw(e.page.texture, T, ge);
      }
      line(e, t, s, i, r, h) {
        this.enableRenderer(this.shapes), this.shapes.line(e, t, s, i, r);
      }
      triangle(e, t, s, i, r, h, l, n, a, o) {
        this.enableRenderer(this.shapes), this.shapes.triangle(e, t, s, i, r, h, l, n, a, o);
      }
      quad(e, t, s, i, r, h, l, n, a, o, c, d, f) {
        this.enableRenderer(this.shapes), this.shapes.quad(e, t, s, i, r, h, l, n, a, o, c, d, f);
      }
      rect(e, t, s, i, r, h) {
        this.enableRenderer(this.shapes), this.shapes.rect(e, t, s, i, r, h);
      }
      rectLine(e, t, s, i, r, h, l) {
        this.enableRenderer(this.shapes), this.shapes.rectLine(e, t, s, i, r, h, l);
      }
      polygon(e, t, s, i) {
        this.enableRenderer(this.shapes), this.shapes.polygon(e, t, s, i);
      }
      circle(e, t, s, i, r, h = 0) {
        this.enableRenderer(this.shapes), this.shapes.circle(e, t, s, i, r, h);
      }
      curve(e, t, s, i, r, h, l, n, a, o) {
        this.enableRenderer(this.shapes), this.shapes.curve(e, t, s, i, r, h, l, n, a, o);
      }
      end() {
        this.activeRenderer === this.batcher ? this.batcher.end() : this.activeRenderer === this.shapes && this.shapes.end(), this.activeRenderer = null;
      }
      resize(e) {
        let t = this.canvas;
        var s = window.devicePixelRatio || 1, i = Math.round(t.clientWidth * s), r = Math.round(t.clientHeight * s);
        if ((t.width != i || t.height != r) && (t.width = i, t.height = r), this.context.gl.viewport(0, 0, t.width, t.height), e === 1) this.camera.setViewport(i, r);
        else if (e === 2) {
          let h = t.width, l = t.height, n = this.camera.viewportWidth, a = this.camera.viewportHeight, o = a / n, c = l / h, d = o < c ? n / h : a / l;
          this.camera.setViewport(h * d, l * d);
        }
        this.camera.update();
      }
      enableRenderer(e) {
        this.activeRenderer !== e && (this.end(), e instanceof Xs ? (this.batcherShader.bind(), this.batcherShader.setUniform4x4f(Tt.MVP_MATRIX, this.camera.projectionView.values), this.batcherShader.setUniformi("u_texture", 0), this.batcher.begin(this.batcherShader), this.activeRenderer = this.batcher) : e instanceof Ps ? (this.shapesShader.bind(), this.shapesShader.setUniform4x4f(Tt.MVP_MATRIX, this.camera.projectionView.values), this.shapes.begin(this.shapesShader), this.activeRenderer = this.shapes) : this.activeRenderer = this.skeletonDebugRenderer);
      }
    }, ki = ((e) => (e[e.Stretch = 0] = "Stretch", e[e.Expand = 1] = "Expand", e[e.Fit = 2] = "Fit", e))(ki || {}), _t, Dt, Ls = 0, jr = 1, Bs = 1, pe = 165, we = 108, It = 163, Zr = class {
      renderer;
      logo = null;
      spinner = null;
      angle = 0;
      fadeOut = 0;
      fadeIn = 0;
      timeKeeper = new Ee();
      backgroundColor = new tt(0.135, 0.135, 0.135, 1);
      tempColor = new tt();
      constructor(e) {
        if (this.renderer = e, this.timeKeeper.maxDelta = 9, !Dt) {
          let t = navigator.userAgent.indexOf("Safari") > -1, s = () => Ls++;
          Dt = new Image(), Dt.src = Jr, t || (Dt.crossOrigin = "anonymous"), Dt.onload = s, _t = new Image(), _t.src = Kr, t || (_t.crossOrigin = "anonymous"), _t.onload = s;
        }
      }
      dispose() {
        var _a, _b;
        (_a = this.logo) == null ? void 0 : _a.dispose(), (_b = this.spinner) == null ? void 0 : _b.dispose();
      }
      draw(e = false) {
        if (Ls < 2 || e && this.fadeOut > Bs) return;
        this.timeKeeper.update();
        let t = Math.abs(Math.sin(this.timeKeeper.totalTime + 0.25));
        this.angle -= this.timeKeeper.delta * 200 * (1 + 1.5 * Math.pow(t, 5));
        let s = this.tempColor, i = this.renderer, r = i.canvas, h = i.context.gl;
        if (i.resize(1), i.camera.position.set(r.width / 2, r.height / 2, 0), i.batcher.setBlendMode(0, true), e) {
          if (this.fadeOut += this.timeKeeper.delta * (this.timeKeeper.totalTime < 1 ? 2 : 1), this.fadeOut > Bs) return;
          s.setFromColor(this.backgroundColor), t = 1 - this.fadeOut / Bs, t = 1 - (t - 1) * (t - 1), s.a *= t, s.a > 0 && (i.camera.zoom = 1, i.begin(), i.quad(true, 0, 0, r.width, 0, r.width, r.height, 0, r.height, s, s, s, s), i.end());
        } else this.fadeIn += this.timeKeeper.delta, this.backgroundColor.a > 0 && (h.clearColor(this.backgroundColor.r, this.backgroundColor.g, this.backgroundColor.b, this.backgroundColor.a), h.clear(h.COLOR_BUFFER_BIT)), t = 1;
        t *= Math.min(this.fadeIn / jr, 1), s.set(t, t, t, t), this.logo || (this.logo = new Gt(i.context, Dt), this.spinner = new Gt(i.context, _t)), i.camera.zoom = Math.max(1, It / r.height), i.begin(), i.drawTexture(this.logo, (r.width - pe) / 2, (r.height - we) / 2, pe, we, s), this.spinner && i.drawTextureRotated(this.spinner, (r.width - It) / 2, (r.height - It) / 2, It, It, It / 2, It / 2, this.angle, s), i.end();
      }
      drawInCoordinates(e, t) {
        if (Ls < 2) return;
        this.timeKeeper.update();
        let s = this.renderer;
        s.batcher.setBlendMode(0, true), this.logo || (this.logo = new Gt(s.context, Dt), this.spinner = new Gt(s.context, _t));
        const i = e - pe / 2, r = t - we / 2;
        s.drawTexture(this.logo, i, r, pe, we), this.angle -= this.timeKeeper.delta * 500, this.spinner && s.drawTextureRotated(this.spinner, i, r - 25, It, It, It / 2, It / 2, this.angle);
      }
    }, Kr = "data:image/png;base64,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", Jr = "data:image/png;base64,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", Qr = class {
      constructor(e, t) {
        this.config = t, t.pathPrefix || (t.pathPrefix = ""), t.app || (t.app = { loadAssets: () => {
        }, initialize: () => {
        }, update: () => {
        }, render: () => {
        }, error: () => {
        }, dispose: () => {
        } }), t.webglConfig || (t.webglConfig = { alpha: true }), this.htmlCanvas = e, this.context = new xt(e, t.webglConfig), this.renderer = new Yi(e, this.context), this.gl = this.context.gl, this.assetManager = new bi(this.context, t.pathPrefix), this.input = new Ys(e), t.app.loadAssets && t.app.loadAssets(this);
        let s = () => {
          this.disposed || (requestAnimationFrame(s), this.time.update(), t.app.update && t.app.update(this, this.time.delta), t.app.render && t.app.render(this));
        }, i = () => {
          if (!this.disposed) {
            if (this.assetManager.isLoadingComplete()) {
              this.assetManager.hasErrors() ? t.app.error && t.app.error(this, this.assetManager.getErrors()) : (t.app.initialize && t.app.initialize(this), s());
              return;
            }
            requestAnimationFrame(i);
          }
        };
        requestAnimationFrame(i);
      }
      context;
      time = new Ee();
      htmlCanvas;
      gl;
      renderer;
      assetManager;
      input;
      disposed = false;
      clear(e, t, s, i) {
        this.gl.clearColor(e, t, s, i), this.gl.clear(this.gl.COLOR_BUFFER_BIT);
      }
      dispose() {
        this.config.app.dispose && this.config.app.dispose(this), this.disposed = true;
      }
    };
    return Ji(Ws);
  })();
  var spine_webgl_default3 = spine3;

  // src/spine/spineVersions.ts
  var spineVersions = {
    "3.8webgl": spine_webgl_default,
    "4.0webgl": spine_webgl_default2,
    "4.2webgl": spine_webgl_default3
  };
  var spineVersions_default = spineVersions;

  // src/spineManager.ts
  function loadAsset(assetManager, skeletonUrl, atlasUrl) {
    if (skeletonUrl.endsWith(".skel")) {
      assetManager.loadBinary(skeletonUrl);
    } else {
      assetManager.loadJson(skeletonUrl);
    }
    assetManager.loadTextureAtlas(atlasUrl);
    return assetManager;
  }
  function parseSkeleton(assetManager, spine4, skeletonUrl, atlasUrl) {
    const atlasLoader = new spine4.AtlasAttachmentLoader(
      assetManager.get(atlasUrl)
    );
    let loader;
    if (skeletonUrl.endsWith(".skel")) {
      loader = new spine4.SkeletonBinary(atlasLoader);
    } else {
      loader = new spine4.SkeletonJson(atlasLoader);
    }
    const skeletonData2 = loader.readSkeletonData(assetManager.get(skeletonUrl));
    const skeleton2 = new spine4.Skeleton(skeletonData2);
    const animationStateData = new spine4.AnimationStateData(skeletonData2);
    const animationState = new spine4.AnimationState(animationStateData);
    return { skeleton: skeleton2, animationState };
  }
  var SpineManager = class {
    version;
    constructor(version) {
      this.version = version;
    }
  };
  var Spine4Manager = class extends SpineManager {
    assetManager;
    sceneRenderer;
    constructor(version) {
      super(version);
    }
    async loadSkeleton(skeletonUrl, atlasUrl) {
      loadAsset(this.assetManager, skeletonUrl, atlasUrl);
      await this.assetManager.loadAll();
    }
  };
  var Spine42Manager = class extends Spine4Manager {
    assetManager;
    sceneRenderer;
    constructor(renderer) {
      super("4.2webgl");
      this.assetManager = new spine_webgl_default3.AssetManager(renderer.gl);
      this.sceneRenderer = new spine_webgl_default3.SceneRenderer(
        renderer.canvas,
        renderer.gl
      );
    }
    async loadSkeleton(skeletonUrl, atlasUrl) {
      await super.loadSkeleton(skeletonUrl, atlasUrl);
      return parseSkeleton(this.assetManager, spine_webgl_default3, skeletonUrl, atlasUrl);
    }
    drawSkeleton(skeleton2, tk, animationState) {
      skeleton2.updateWorldTransform(spine_webgl_default3.Physics.update);
      tk.update();
      animationState.update(tk.delta);
      animationState.apply(skeleton2);
      this.sceneRenderer.begin();
      this.sceneRenderer.drawSkeleton(skeleton2);
      this.sceneRenderer.end();
    }
  };
  var Spine40Manager = class extends Spine4Manager {
    assetManager;
    sceneRenderer;
    spine;
    constructor(renderer) {
      super("4.0webgl");
      this.assetManager = new spine_webgl_default2.AssetManager(renderer.gl);
      this.sceneRenderer = new spine_webgl_default2.SceneRenderer(
        renderer.canvas,
        renderer.gl
      );
    }
    async loadSkeleton(skeletonUrl, atlasUrl) {
      await super.loadSkeleton(skeletonUrl, atlasUrl);
      return parseSkeleton(this.assetManager, spine_webgl_default2, skeletonUrl, atlasUrl);
    }
    drawSkeleton(skeleton2, tk, animationState) {
      skeleton2.updateWorldTransform();
      tk.update();
      animationState.update(tk.delta);
      animationState.apply(skeleton2);
      this.sceneRenderer.begin();
      this.sceneRenderer.drawSkeleton(skeleton2);
      this.sceneRenderer.end();
    }
  };

  // src/util/htmlReport.ts
  function clean(obj) {
    var _a;
    if ("prototype" in obj) {
      obj.prototype = /* @__PURE__ */ Object.create(null);
    }
    Object.setPrototypeOf(obj, /* @__PURE__ */ Object.create(null));
    if (Object.getPrototypeOf(obj).constructor || ((_a = obj == null ? void 0 : obj.prototype) == null ? void 0 : _a.constructor)) {
      console.warn("clean失败", obj);
    }
    return obj;
  }
  function resolveMaybeFunc(dat) {
    if (dat instanceof Function) {
      return dat();
    } else {
      return dat;
    }
  }
  var HTMLReport = class {
    /**
     * used by blockly report
     * @returns a html string
     */
    replace;
    /**
     * used by extensions
     * @returns origin value
     */
    valueOf;
    /**
     * used by monitor
     * @returns a raw text used in monitor
     */
    toString;
    constructor(element, value, monitorValue) {
      const report = {
        //使用闭包防修改
        replace: clean(() => resolveMaybeFunc(element).innerHTML),
        valueOf: clean(() => resolveMaybeFunc(value)),
        toString: clean(() => resolveMaybeFunc(monitorValue))
      };
      Object.assign(this, report);
      Object.freeze(this);
    }
  };
  function patch(runtime2) {
    if (runtime2.visualReport.spinePatched) {
      return;
    }
    runtime2.visualReport.spinePatched = true;
    const originReport = runtime2.visualReport;
    runtime2.visualReport = function(id, value) {
      if (value instanceof HTMLReport) {
        const Runtime = this.constructor;
        this.emit(Runtime.VISUAL_REPORT, { id, value });
      } else {
        originReport.call(this, id, value);
      }
    };
    const originUpdate = runtime2.requestUpdateMonitor;
    runtime2.requestUpdateMonitor = function(monitor) {
      const value = monitor.get("value");
      if (value instanceof HTMLReport) {
        originUpdate.call(this, monitor.set("value", value.toString()));
      } else {
        originUpdate.call(this, monitor);
      }
    };
  }

  // src/util/spineReports.ts
  function domWithType(type, color, restChildren = []) {
    const container = document.createElement("div");
    let children = [];
    const reportTypeDom = document.createElement("span");
    reportTypeDom.style.fontSize = "150%";
    reportTypeDom.innerText = resolveMaybeFunc(type);
    reportTypeDom.style.color = resolveMaybeFunc(color);
    children.push(reportTypeDom);
    children = children.concat(resolveMaybeFunc(restChildren));
    children.forEach((dom, idx) => {
      container.appendChild(dom);
      if (idx !== children.length - 1) {
        container.appendChild(document.createElement("br"));
      }
    });
    return container;
  }
  var SpineSkinReport = class extends HTMLReport {
    constructor(skin, translate, name) {
      const idDom = document.createElement("span");
      const versionDom = document.createElement("span");
      const nameDom = document.createElement("span");
      function render() {
        idDom.innerText = translate("SpineSkinReport.id", {
          id: skin.id
        });
        versionDom.innerText = translate("SpineSkinReport.version", {
          version: skin.manager.version
        });
        nameDom.innerText = translate("SpineSkinReport.nameText", {
          name
        });
        return [idDom, versionDom, nameDom];
      }
      super(
        () => domWithType(
          () => translate("SpineSkinReport.type"),
          "blue",
          render
        ),
        skin,
        () => translate("SpineSkinReport.monitor", {
          id: skin.id,
          version: skin.manager.version,
          name
        })
      );
    }
  };
  var SpineSkeletonReport = class extends HTMLReport {
    constructor(skeleton2, translate, name) {
      super(
        () => domWithType(
          () => translate("SpineSkeletonReport.type"),
          "green"
        ),
        skeleton2,
        () => `(spine骨架) 名称为${name}, 共有${skeleton2.bones.length}个骨骼`
      );
    }
  };

  // assets/icon.png
  var icon_default = "data:image/png;base64,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";

  // assets/insetIcon.png
  var insetIcon_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAIGNIUk0AAHomAACAhAAA+gAAAIDoAAB1MAAA6mAAADqYAAAXcJy6UTwAAAIBUExURQAAAD+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9T+p9f///wu8gKgAAACpdFJOUwAMUo/I6Pvz4MWUCR6V8BkEevb906Bnc5NyAhK+54IWceG0DhXQhguA/MoPBsLsPwgkNEOsAYPqK0ev9/GiKDcm+j61TVS7i0v+IaGIHN5tSpsR+enRFBdffoe2jm+fIjhouc7ccOMbe6v0qbexLFyMvMvkmj2dzPjXinzGpME17YTWkk8teM+ZXuLEXXa49SogO4UFIxN1PAONsNIaYWDJB5HALjOqd2zHMijwAAAAAWJLR0SqvgZXvgAAAAd0SU1FB+kMDQYiGQ1RR2QAAAHzSURBVDjLY2AgHjAyMbOwsrFzcHIxcWOR5uFlXwkHfMz8aNICgkIrVwqLiAqKiUuwsAGVsEtKIctLy6xcKSvHA+XJKygClSgpI+RVVFeyqakjaeDW0Fy5UksbxtXRXamnD2YZGBrxCIBZxnorV5qYQhWYrTS3ANGWVtbCsqw2tnYgjj3fypXiEHkHRzYnkD3OKzldgPZou7q5g0zx8Fxp7QVW4L3SB0j6+rH5w+wMsAWpCFy50hvECwoOYQQ6K3SlGFKYgWwPY18ZHA6kI1ZGAsmoldEYYRezcmUskIpbGQ90gNDKBAwFiStXJgGp5BQgkboyDUUu3SMjM8Vz5cosIFsvG0jkrMyFBXpefkGhHixSioAiju5AonhlCQODcql/Wbk1PMYqKqOrQHHmWA0kglemgI0EA9aa2rqVK+th4djQCFIFkrBuUmpWaGkFRUrbypXwuGnvABKdGhGl6aYIR6qt7IKzRbuxJJ+claJwdo81ZgJjFFqpD+coCzFhKOhdWYjE6+hDlzfk65+AxJ1oPQlETW6FCdj5VbigaKhunwJKTSUFU0G8adNtQmagmjizcBaYtqxLiZ5dpNngPg3dTu05ChDGXI958xMEsHg7bIGaFP5st3DR4iUEcuZSpWUJpviVxC8v8clY4eqyEK8qdXQBANCmi81FtVKuAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDI1LTEyLTEzVDA2OjM0OjI1KzAwOjAw2FniSAAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyNS0xMi0xM1QwNjozNDoyNSswMDowMKkEWvQAAAAodEVYdGRhdGU6dGltZXN0YW1wADIwMjUtMTItMTNUMDY6MzQ6MjUrMDA6MDD+EXsrAAAAAElFTkSuQmCC";

  // src/index.ts
  var { BlockType, ArgumentType, runtime } = Scratch;
  var SpineConfig = class {
    _skel;
    _atlas;
    version;
    constructor(config) {
      this.version = config.version;
      this.skel = config.skel;
      this.atlas = config.atlas;
    }
    set skel(v) {
      if (v.startsWith("http")) {
        this._skel = v;
      } else {
        this._skel = `https://m.ccw.site/user_projects_assets/${v}`;
      }
    }
    get skel() {
      return this._skel;
    }
    set atlas(v) {
      if (v.startsWith("http")) {
        this._atlas = v;
      } else {
        this._atlas = `https://m.ccw.site/user_projects_assets/${v}`;
      }
    }
    get atlas() {
      return this._atlas;
    }
    toJSON() {
      return {
        skel: this.skel,
        atlas: this.atlas,
        version: this.version
      };
    }
  };
  var NS = "spineAnimation";
  var SpineExtension = class extends SimpleExt {
    translate;
    runtime;
    managers;
    renderer;
    constructor(runtime2) {
      console.log(runtime2);
      super(NS, "foo");
      this.runtime = runtime2;
      console.log(this);
      this.translate = getTranslate(runtime2);
      this.renderer = runtime2.renderer;
      patchSpineSkin(this.runtime);
      patch(this.runtime);
      this.managers = {
        "4.0webgl": new Spine40Manager(this.renderer),
        "4.2webgl": new Spine42Manager(this.renderer)
      };
    }
    getInfo() {
      this.info.name = this.translate("extensionName");
      this.info.blockIconURI = insetIcon_default;
      this.info.color1 = "#272D39";
      this.info.color2 = "#20272F";
      this.info.blocks = [
        {
          opcode: this.setSkinSkeleton.name,
          text: this.translate("setSkinSkeleton.text"),
          blockType: BlockType.COMMAND,
          arguments: {
            TARGET_NAME: {
              type: ArgumentType.STRING,
              menu: "sprite_menu"
            },
            SKELETON: {
              type: ArgumentType.NUMBER,
              defaultValue: 0
            }
          }
        },
        {
          opcode: this.loadSkeleton.name,
          text: this.translate("loadSkeleton.text"),
          blockType: BlockType.REPORTER,
          arguments: {
            CONFIG: {
              type: ArgumentType.STRING,
              menu: "skeleton_menu"
            },
            NAME: {
              type: ArgumentType.STRING,
              defaultValue: "hina"
            }
          }
        },
        {
          opcode: this.getSkeletonInSkin.name,
          text: "获取skin[SKIN]中的骨架",
          blockType: BlockType.REPORTER,
          arguments: {
            SKIN: {
              type: null
            }
          }
        },
        {
          func: this.initUI.name,
          blockType: BlockType.BUTTON,
          text: "abcd"
        }
      ];
      this.info.menus = {
        sprite_menu: {
          items: this.spriteMenu.name,
          acceptReporters: true
        },
        skeleton_menu: {
          items: this.skeletonMenu.name,
          acceptReporters: true
        }
      };
      return this.info;
    }
    spriteMenu() {
      var _a;
      const items = [
        {
          text: this.translate("spriteMenu.currentTarget"),
          value: "__this__"
        }
      ];
      for (const target of this.runtime.targets) {
        if (target.isSprite()) {
          if (target.id !== ((_a = this.runtime.getEditingTarget()) == null ? void 0 : _a.id)) {
            items.push({
              text: target.sprite.name,
              value: target.sprite.name
            });
          }
        }
      }
      return items;
    }
    skeletonMenu() {
      const menuItems = [];
      menuItems.push({
        text: "test",
        value: JSON.stringify(
          new SpineConfig({
            skel: "spine/Hina_home.skel",
            atlas: "spine/Hina_home.atlas",
            version: "4.2webgl"
          })
        )
      });
      return menuItems;
    }
    setSkinSkeleton(arg, util) {
      const { TARGET_NAME, SKELETON } = arg;
      console.log(SKELETON);
      let skinId;
      if (SKELETON instanceof SpineSkinReport) {
        skinId = SKELETON.valueOf().id;
      } else {
        skinId = Number(SKELETON.toString());
      }
      if (isNaN(skinId)) {
        console.error("请输入数字或有效的skeleton数据");
        return;
      }
      let target;
      if (TARGET_NAME === "__this__") {
        target = util.target;
      } else {
        target = this.runtime.targets.find(
          (t) => t.isSprite() && t.getName() === TARGET_NAME
        );
        if (!target) {
          console.warn(`找不到名为${TARGET_NAME}的角色`);
        }
      }
      const drawableId = target.drawableID;
      const drawable = this.runtime.renderer._allDrawables[drawableId];
      const skin = this.runtime.renderer._allSkins[skinId];
      if (skin) {
        drawable.skin = skin;
      }
    }
    async loadSkeleton(arg) {
      const { CONFIG, NAME } = arg;
      const { skel, atlas, version } = JSON.parse(CONFIG);
      if (!(skel && atlas && version in spineVersions_default)) {
        throw new Error(this.translate("loadSkeleton.configError"));
      }
      const manager = this.managers[version];
      const { skeleton: skeleton2, animationState } = await manager.loadSkeleton(
        skel,
        atlas
      );
      console.log(skeleton2, animationState);
      const skinId = this.renderer._nextSkinId++;
      const newSkin = this.renderer._allSkins[skinId] = new SpineSkin(
        skinId,
        this.renderer,
        manager,
        skeleton2,
        animationState,
        new spineVersions_default[version].TimeKeeper(),
        NAME
      );
      console.log(newSkin);
      return new SpineSkinReport(newSkin, this.translate, NAME);
    }
    initUI() {
      const s = new scratchStroageUI(this.runtime.storage, "spineAnimation");
      s.createUI();
      console.log(s);
    }
    getSkeletonInSkin(arg) {
      const { SKIN } = arg;
      if (SKIN instanceof SpineSkinReport) {
        const skin = SKIN.valueOf();
        return new SpineSkeletonReport(
          skin.skeleton,
          this.translate,
          skin.name
        );
      }
      console.error("请输入有效的spine skin");
      return "";
    }
  };
  registerExtDetail(SpineExtension, {
    info: {
      name: "spineAnimation.name",
      description: "spineAnimation.desc",
      extensionId: NS,
      collaboratorList: [
        {
          collaborator: "孟夫子驾到@ccw",
          collaboratorURL: "https://www.ccw.site/student/63c2807d669fa967f17f5559"
        },
        {
          collaborator: "乌龙茶速递@ccw",
          collaboratorURL: "https://www.ccw.site/student/68dd004586bbc77f84e309ac"
        }
      ],
      iconURL: icon_default,
      insetIconURL: insetIcon_default
    },
    l10n: {
      "zh-cn": {
        "spineAnimation.name": zh_cn_default.extensionName,
        "spineAnimation.desc": zh_cn_default.description
      },
      en: {
        "spineAnimation.name": en_default.extensionName,
        "spineAnimation.desc": en_default.description
      }
    }
  });

})();
